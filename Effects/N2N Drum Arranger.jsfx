desc:N2N Drum Arranger
version: 4.9.7
author: Rock Kennedy
about:
  # N2N Drum Arranger v4.9.6
  - RESTORED: Fixed missing code (Tabs, Grid, Scrollbar) dropped in previous updates.
  - LAYOUT: Restored spacing (Gap=70) for Pattern Settings.
  - VISUAL: Grid Cells flash white when played.
  - CONTROL: "PUSH/PULL" slider (-50 to +60).
  - NEW: Stretch modes.
  - ENGINE: Windowed Lookahead Engine active.
  - BAR MAKERS with copy paste.
  - ALL Button to make overall velocity changes.
  - Window Size Optimized.
  - Table scroll bar fixed.
provides:
  [main] .

options:gmem=ProjectSwing

// --- KIT SELECTOR SLIDER (READ ONLY) ---
slider10:/AHS_Music_Tech/N2N/DrumKits:none:Source Kit File

slider1:100<1,127,1>-Default Row Velocity
slider2:0<0,25,1>-Global Humanize
slider3:2<0,4,1{8,12,16,24,32}>-Global Subdiv
slider4:4<1,4,1>-Global Bars
slider5:1<1,512,1>-Instance ID
slider6:0<0,100,1>-Global Swing
slider7:20<1,128,1>-Visible Rows
slider8:0<0,128,1>-View Scroll
slider9:0<0,1,1{P, M}>-Swing Source (Default=P)
slider11:14<10,30,1>-Grid Row Height

@init

// =========================================================
// REGISTRATION & GROOVE MEMORY
// =========================================================
reg_base = 8000000;
// Safe Zone (500k) to avoid Pattern Data overlap
parse_scratch = 500000; 
LOCAL_GROOVE_DB = 550000; 
GMEM_GROOVE_OFFSET = 5000000; // Index in gmem

my_key == 0 ? (
    seed = floor(time_precise() * 100000) + floor(rand(100000));
    loop(seed % 10, rand(100)); 
    my_key = floor(rand(9000000)) + 1; 
);

reg_done = 0;
curr_id = slider5;

while (reg_done == 0 && curr_id <= 512) (
    slot_val = gmem[reg_base + curr_id];
    (slot_val == 0 || slot_val == my_key) ? (
        gmem[reg_base + curr_id] = my_key;
        slider5 = curr_id;
        reg_done = 1;
    ) : (
        curr_id += 1;
    );
);
slider5 > 512 ? slider5 = 512;

// =========================================================
// MEMORY MANAGEMENT & STRING MAPPING
// =========================================================
row_name_str_base = 0;   
tab_name_str_base = 128; 

STR_BUF_LINE = 200; 
STR_BUF_NAME = 201; 
STR_BUF_COLOR = 202; 
STR_BUF_SWAP = 203; 
STR_BUF_MENU = 204;

str_size = 1; 

last_load_handle = 0; last_load_lines = 0; last_load_rows = 0;
ext_noinit = 1.0; grid_height = slider11; swing_sync = 1;
save_msg_timer = 0; drag_accum_gen = 0; help_active = 0;    

// Clipboard for Pattern Metadata
cp_valid = 0; 
cp_bars = 0; cp_sub = 0; cp_hum = 0; cp_sw = 0; cp_half = 0;

// --- DATA MEMORY LAYOUT ---
MAX_TABS = 22; TOTAL_TABS = 64; MAX_ROWS = 128; MAX_STEPS = 128;
mem_pos = 0;
NEW_MAGIC_VER = 27022; 
ver_chk = mem_pos; mem_pos += 1;

ui_base = mem_pos; mem_pos += 32;
ui_edit_tab = ui_base+0; ui_selected_row = ui_base+1; ui_locked_tab = ui_base+2; ui_play_prog_tab = ui_base+3; ui_play_offset = ui_base+4; ui_anchor_valid = ui_base+5; ui_last_step = ui_base+6;

// Tab Headers
tab_w_base = mem_pos; mem_pos += TOTAL_TABS;
tab_ui_row_base = mem_pos; mem_pos += TOTAL_TABS; 
tab_col_r = mem_pos; mem_pos += TOTAL_TABS;
tab_col_g = mem_pos; mem_pos += TOTAL_TABS;
tab_col_b = mem_pos; mem_pos += TOTAL_TABS;

// Row Properties
row_mute_base = mem_pos; mem_pos += MAX_ROWS;
row_solo_base = mem_pos; mem_pos += MAX_ROWS;
row_note_base = mem_pos; mem_pos += MAX_ROWS;
row_chan_base = mem_pos; mem_pos += MAX_ROWS;
row_level_base = mem_pos; mem_pos += MAX_ROWS;
row_human_base = mem_pos; mem_pos += MAX_ROWS;
row_len_base = mem_pos; mem_pos += MAX_ROWS;
row_name_idx = mem_pos; mem_pos += MAX_ROWS;
row_offs_base = mem_pos; mem_pos += MAX_ROWS; // Timing Offset
row_color_base = mem_pos; mem_pos += MAX_ROWS;

// Pattern Overrides
bars_ov_base = mem_pos; mem_pos += MAX_TABS;
subdiv_ov_base = mem_pos; mem_pos += MAX_TABS;
hum_ov_base = mem_pos; mem_pos += MAX_TABS;
swing_ov_base = mem_pos; mem_pos += MAX_TABS;
half_speed_ov_base = mem_pos; mem_pos += MAX_TABS; 

// Playback Logic Vars
requested_start_bar = 1; 

// --- PATTERN DATA (Safe Zone: 2,000,000+) ---
mem_pos = 2000000; 

vel_stride_tab = MAX_ROWS * MAX_STEPS; vel_stride_row = MAX_STEPS;
vel_base = mem_pos; mem_pos += TOTAL_TABS * MAX_ROWS * MAX_STEPS;
grid_base = mem_pos; mem_pos += TOTAL_TABS * MAX_ROWS * MAX_STEPS;
step_len_base = mem_pos; mem_pos += TOTAL_TABS * MAX_ROWS * MAX_STEPS;

// Copy Buffers
copy_row_v_buf = mem_pos; mem_pos += MAX_STEPS; copy_row_g_buf = mem_pos; mem_pos += MAX_STEPS; copy_row_l_buf = mem_pos; mem_pos += MAX_STEPS;
copy_tab_v_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS; copy_tab_g_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS; copy_tab_l_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS;

// Memory Padding (Fix for flashing)
mem_pos += 50000;
ownership_map = mem_pos; mem_pos += MAX_STEPS;
kill_note = mem_pos; mem_pos += 128; kill_chan = mem_pos; mem_pos += 128;

// --- NEW: BAR CLIPBOARD (Safe Zone) ---
bar_copy_base = 600000; 
// --------------------------------------

// Extensions
EXT_COUNT = TOTAL_TABS - MAX_TABS;
ext_tab_w_base = mem_pos; mem_pos += EXT_COUNT; 
ext_bars_ov_base = mem_pos; mem_pos += EXT_COUNT; ext_subdiv_ov_base = mem_pos; mem_pos += EXT_COUNT; ext_hum_ov_base = mem_pos; mem_pos += EXT_COUNT; ext_swing_ov_base = mem_pos; mem_pos += EXT_COUNT;
ext_half_speed_ov_base = mem_pos; mem_pos += EXT_COUNT;

ext_vel_base = vel_base + MAX_TABS * vel_stride_tab;
ext_grid_base = grid_base + MAX_TABS * vel_stride_tab;
ext_step_len_base = step_len_base + MAX_TABS * vel_stride_tab;

kit_tmp_base = mem_pos; mem_pos += MAX_ROWS * 7; 
state_len = mem_pos;
row_flash_base = mem_pos; mem_pos += MAX_ROWS;
last_play_state = 0; capture_id = 0; capture_min = 0; capture_max = 0; capture_ptr = 0; capture_slider_idx = 0; capture_mode = 0;
scrollbar_drag_y_offset = 0;
color_popup_active = 0; color_popup_x = 0; color_popup_y = 0; color_popup_row = -1;
drag_mode = 0; last_drag_idx = -1; drag_lock_row = -1; drag_accum = 0; last_preview_note = -1; drag_mods = 0; vel_drag_mods = 0;
len_drag_active = 0; len_drag_cell_idx = 0; len_drag_max = 0;
preview_trig = 0; preview_note = 0; preview_chan = 1; preview_vel = 100;
last_play_tab = -1; last_play_offset = -1; playback_shift = 0; pc_triggered = 0;
row_drag_active = 0; row_drag_anchor = -1; row_drag_last_y = 0;
l_mb = 0; l_mx = 0; l_my = 0; last_tab_clk = 0; last_tab_idx = -1;

// =========================================================
// TAB CONFIGURATION DASHBOARD
// =========================================================
function t(id, r_ui, name, w, cr, cg, cb) (
  mem[tab_ui_row_base + id] = r_ui;
  strcpy(tab_name_str_base + id, name);
  mem[tab_w_base + id] = w;
  mem[tab_col_r + id] = cr;
  mem[tab_col_g + id] = cg;
  mem[tab_col_b + id] = cb;
);
// ---------------------------------------------------------

sectw = 90;
ttabw = 45;
hw = 58;

// ID, Row, "Name",    Width,  Red,  Grn,  Blu
t(0,   1,   "Off",       55,    0.7,  0.7,  0.7); // Gray
t(1,   1,   "Intro",  sectw,    0.2,  1.0,  1.0); // Cyan
t(2,   1,   "2",      ttabw,    0.2,  1.0,  1.0); // Cyan
t(3,   1,   "3",      ttabw,    0.2,  1.0,  1.0); // Cyan
t(4,   1,   "Verse",  sectw,    0.4,  0.6,  1.0); // Blue
t(5,   1,   "2",      ttabw,    0.4,  0.6,  1.0); // Blue
t(6,   1,   "3",      ttabw,    0.4,  0.6,  1.0); // Blue
t(7,   1,   "Pre",    sectw,    0.7,  0.4,  1.0); // Violet
t(8,   1,   "2",      ttabw,    0.7,  0.4,  1.0); // Violet
t(9,   1,   "3",      ttabw,    0.7,  0.4,  1.0); // Violet
t(10,  1,   "Chorus", sectw,    1.0,  0.4,  0.4); // Red
t(11,  1,   "2",      ttabw,    1.0,  0.4,  0.4); // Red
t(12,  1,   "3",      ttabw,    1.0,  0.4,  0.4); // Red
t(13,  1,   "Bridge", sectw,    1.0,  0.9,  0.2); // Yellow
t(14,  1,   "2",      ttabw,    1.0,  0.9,  0.2); // Yellow
t(15,  1,   "3",      ttabw,    1.0,  0.9,  0.2); // Yellow
t(16,  1,   "Outro",  sectw,    0.5,  0.8,  0.7); // Green
t(17,  1,   "2",      ttabw,    0.5,  0.8,  0.7); // Green
t(18,  1,   "3",      ttabw,    0.5,  0.8,  0.7); // Green

t(19,  1,   "H 1",    hw,    0.8,  0.8,  0.8); // Salmon
t(20,  1,   "H 2",    hw,    0.8,  0.8,  0.8);

t(21,  1,   "1<",  44,    0.7,  0.4,  1.0); // Violet
t(22,  1,   "1=",  44,    0.7,  0.4,  1.0);
t(23,  1,   "1>",  44,    0.7,  0.4,  1.0);

t(24,  1,   "1",   44,    0.8,  0.8,  0.8); // Gray
t(25,  1,   "2",   44,    0.8,  0.8,  0.8);
t(26,  1,   "3",   44,    0.8,  0.8,  0.8);
t(27,  1,   "4",   44,    0.8,  0.8,  0.8);
t(28,  1,   "5",   44,    0.8,  0.8,  0.8);

t(29,  2,   "Def",       55,    0.8,  0.8,  0.8); // Gray

t(30,  2,   "4",   ttabw,   0.2,  1.0,  1.0); // Cyan
t(31,  2,   "5",   ttabw,   0.2,  1.0,  1.0); // Cyan
t(32,  2,   "6",   ttabw,   0.2,  1.0,  1.0); // Cyan
t(33,  2,   "7",   ttabw,   0.2,  1.0,  1.0); // Cyan

t(34,  2,   "4",   ttabw,   0.4,  0.6,  1.0); // Blue
t(35,  2,   "5",   ttabw,   0.4,  0.6,  1.0); // Blue
t(36,  2,   "6",   ttabw,   0.4,  0.6,  1.0); // Blue
t(37,  2,   "7",   ttabw,   0.4,  0.6,  1.0); // Blue

t(38,  2,   "4",   ttabw,   0.7,  0.4,  1.0); // Violet
t(39,  2,   "5",   ttabw,   0.7,  0.4,  1.0); // Violet
t(40,  2,   "6",   ttabw,   0.7,  0.4,  1.0); // Violet
t(41,  2,   "7",   ttabw,   0.7,  0.4,  1.0); // Violet

t(42,  2,   "4",   ttabw,   1.0,  0.4,  0.4); // Red
t(43,  2,   "5",   ttabw,   1.0,  0.4,  0.4); // Red
t(44,  2,   "6",   ttabw,   1.0,  0.4,  0.4); // Red
t(45,  2,   "7",   ttabw,   1.0,  0.4,  0.4); // Red

t(46,  2,   "4",   ttabw,   1.0,  0.9,  0.2); // Yellow
t(47,  2,   "5",   ttabw,   1.0,  0.9,  0.2); // Yellow
t(48,  2,   "6",   ttabw,   1.0,  0.9,  0.2); // Yellow
t(49,  2,   "7",   ttabw,   1.0,  0.9,  0.2); // Yellow

t(50,  2,   "4",   ttabw,   0.5,  0.8,  0.7); // Green
t(51,  2,   "5",   ttabw,   0.5,  0.8,  0.7); // Green
t(52,  2,   "6",   ttabw,   0.5,  0.8,  0.7); // Green
t(53,  2,   "7",   ttabw,   0.5,  0.8,  0.7); // Green

t(54,  2,   "H 3",    hw,    0.8,  0.8,  0.8);
t(55,  2,   "H 4",    hw,    0.8,  0.8,  0.8);

t(56,  2,   "2<",   44,     0.8,  0.3,  0.9); // Magenta
t(57,  2,   "2=",   44,     0.8,  0.3,  0.9); // Magenta
t(58,  2,   "2>",   44,     0.8,  0.3,  0.9); // Magenta

t(59,  2,   "6",   44,    0.8,  0.8,  0.8);
t(60,  2,   "7",   44,    0.8,  0.8,  0.8);
t(61,  2,   "8",   44,    0.8,  0.8,  0.8);
t(62,  2,   "9",   44,    0.8,  0.8,  0.8);
t(63,  2,   "10",  44,    0.8,  0.8,  0.8);

// =========================================================
// GENERAL HELPER FUNCTIONS
// =========================================================
#name_menu = "Bass Drum|Bass Drum 1|Bass Drum 2|China|Clap|Conga High|Conga Low|Cowbell|Crash|Crash Cymbal 1|Crash Cymbal 2|Cymbal|FX 1|FX 2|Hand Clap|Hat Cl|Hat Pd|Hat Op|Kick|High Floor Tom|Kick 1|Kick 2|Maraca|Perc 1|Perc 2|Perc 3|Ride|Ride Bell|Rimshot|Shaker|Side Stick|Snare|Snare 1|Snare 2|Splash|Tambourine|Tom Hi|Tom Mid|Tom Lo|Triangle Mute|Triangle Open|(Empty)";
#color_menu = "White|Red|Deep Orange|Orange|Amber|Yellow|Lime|Green|Mint|Cyan|Sky|Blue|Indigo|Purple|Violet|Magenta|Rose|Grey";

EMPTY_NAME_IDX = 41;

function clamp(x,a,b) ( x<a ? a : (x>b ? b : x); );
function fmod_pos(x, m) ( m<=0 ? 0 : x - floor(x/m)*m; );

function get_menu_item(list_str, idx, out_str)
local(str_len, char_idx, item_ctr, c)
(
    strcpy(out_str, "");
    str_len = strlen(list_str);
    char_idx = 0; item_ctr = 0;
    while (item_ctr < idx && char_idx < str_len) (
        str_getchar(list_str, char_idx) == '|' ? item_ctr += 1;
        char_idx += 1;
    );
    while (char_idx < str_len) (
        c = str_getchar(list_str, char_idx);
        c == '|' ? char_idx = str_len : ( str_setchar(out_str, strlen(out_str), c); );
        char_idx += 1;
    );
);

function resolve_color_idx(str_in)
(
    matchi("*White*", str_in) ? 0 :
    matchi("*Deep*Orange*", str_in) ? 2 :
    matchi("*Orange*", str_in) ? 3 :
    matchi("*Amber*", str_in) ? 4 :
    matchi("*Yellow*", str_in) ? 5 :
    matchi("*Lime*", str_in) ? 6 :
    matchi("*Mint*", str_in) ? 8 :
    matchi("*Green*", str_in) ? 7 :
    matchi("*Cyan*", str_in) ? 9 :
    matchi("*Sky*", str_in) ? 10 :
    matchi("*Indigo*", str_in) ? 12 :
    matchi("*Blue*", str_in) ? 11 :
    matchi("*Purple*", str_in) ? 13 :
    matchi("*Violet*", str_in) ? 14 :
    matchi("*Magenta*", str_in) ? 15 :
    matchi("*Rose*", str_in) ? 16 :
    matchi("*Grey*", str_in) ? 17 :
    matchi("*Gray*", str_in) ? 17 :
    matchi("*Red*", str_in) ? 1 :
    -1; 
);

function get_d_name(idx, out) (
    get_menu_item(#name_menu, idx, out);
    strcmp(out, "(Empty)") == 0 ? strcpy(out, "");
    (strlen(out) == 0 && idx != 41) ? sprintf(out, "Drum %d", idx+1);
);

function get_t_name(idx, out) (
    strcpy(out, tab_name_str_base + idx);
    strlen(out) == 0 ? sprintf(out, "%d", idx);
);

function get_palette_values(idx) (
    idx==0 ? (cr=1.0; cg=1.0; cb=1.0;) : 
    idx==1 ? (cr=1.0; cg=0.4; cb=0.4;) :
    idx==2 ? (cr=1.0; cg=0.55; cb=0.3;) :
    idx==3 ? (cr=1.0; cg=0.7; cb=0.2;) :
    idx==4 ? (cr=1.0; cg=0.85; cb=0.2;) :
    idx==5 ? (cr=1.0; cg=1.0; cb=0.2;) :
    idx==6 ? (cr=0.7; cg=1.0; cb=0.2;) :
    idx==7 ? (cr=0.4; cg=0.9; cb=0.4;) :
    idx==8 ? (cr=0.2; cg=1.0; cb=0.7;) :
    idx==9 ? (cr=0.2; cg=0.9; cb=0.9;) :
    idx==10 ? (cr=0.2; cg=0.7; cb=1.0;) :
    idx==11 ? (cr=0.4; cg=0.6; cb=1.0;) :
    idx==12 ? (cr=0.5; cg=0.4; cb=1.0;) :
    idx==13 ? (cr=0.7; cg=0.4; cb=1.0;) :
    idx==14 ? (cr=0.9; cg=0.4; cb=1.0;) :
    idx==15 ? (cr=1.0; cg=0.4; cb=1.0;) :
    idx==16 ? (cr=1.0; cg=0.4; cb=0.7;) :
    idx==17 ? (cr=0.5; cg=0.5; cb=0.5;) :
    (cr=0.9; cg=0.9; cb=0.9;);
);

function set_ui_color(idx) ( get_palette_values(idx); gfx_set(cr, cg, cb, 1); );

function eff_bars(t) (
    b = (t<22) ? mem[bars_ov_base+t] : mem[ext_bars_ov_base+(t-22)];
    (b<1 || b>4) ? slider4 : b;
);

function eff_sub(t) (
    ov = (t<22) ? mem[subdiv_ov_base+t] : mem[ext_subdiv_ov_base+(t-22)];
    (ov<0 || ov>4) ? (ov = slider3);
    ov==0?8:ov==1?12:ov==2?16:ov==3?24:32;
);

function eff_swing(t) (
    base_swing = (slider9 == 0) ? gmem[1] : slider6;
    s = (t<22) ? mem[swing_ov_base+t] : mem[ext_swing_ov_base+(t-22)];
    s < 0 ? base_swing : s;
);

function eff_hum(t) (
    h = (t<22) ? mem[hum_ov_base+t] : mem[ext_hum_ov_base+(t-22)];
    h<0 ? slider2 : h;
);

function eff_half(t) (
    (t<22) ? mem[half_speed_ov_base+t] : mem[ext_half_speed_ov_base+(t-22)];
);

function parse_kit_line(line_slot_in, name_slot_out, note_out, chan_out, color_idx_out)
local(line_len, i, k, note_val, chan_val, name_start_idx, name_end_idx, c_idx, found_channel, col_sep_idx, col_start)
(
    mem[note_out] = -1; 
    mem[chan_out] = -1; 
    mem[color_idx_out] = -1; 
    strcpy(name_slot_out, ""); 
    
    line_len = strlen(line_slot_in);
    
    c_idx = 0; found_channel = 0;
    while (c_idx < line_len - 1 && !found_channel) (
        (str_getchar(line_slot_in, c_idx) == '/' && str_getchar(line_slot_in, c_idx+1) == '/') ? (
            k = c_idx + 2;
            while (k < line_len && str_getchar(line_slot_in, k) <= 32) (k += 1;);
            (k < line_len && str_getchar(line_slot_in, k) >= '0' && str_getchar(line_slot_in, k) <= '9') ? (
                chan_val = 0;
                while (k < line_len && str_getchar(line_slot_in, k) >= '0' && str_getchar(line_slot_in, k) <= '9') (
                    chan_val = chan_val * 10 + (str_getchar(line_slot_in, k) - '0');
                    k += 1;
                );
                (chan_val >= 1 && chan_val <= 16) ? ( mem[chan_out] = chan_val; found_channel = 1; );
            );
        );
        c_idx += 1;
    );

    !found_channel ? (
        i = 0;
        while (i < line_len && (str_getchar(line_slot_in, i) < '0' || str_getchar(line_slot_in, i) > '9')) ( i += 1; );
        
        (i < line_len) ? (
            note_val = 0;
            while (i < line_len && str_getchar(line_slot_in, i) >= '0' && str_getchar(line_slot_in, i) <= '9') (
                note_val = note_val * 10 + (str_getchar(line_slot_in, i) - '0');
                i += 1;
            );
            
            (note_val >= 0 && note_val <= 127) ? (
                mem[note_out] = note_val;
                while (i < line_len && (str_getchar(line_slot_in, i) <= 32 || str_getchar(line_slot_in, i) == ':' || str_getchar(line_slot_in, i) == '-')) ( i += 1; );
                
                name_start_idx = i;
                name_end_idx = line_len - 1;
                
                col_sep_idx = -1;
                k = name_start_idx;
                while (k < line_len - 1) (
                    (str_getchar(line_slot_in, k) == '/' && str_getchar(line_slot_in, k+1) == '/') ? (
                        col_sep_idx = k; k = line_len; 
                    );
                    k += 1;
                );
                
                col_sep_idx != -1 ? (
                    name_end_idx = col_sep_idx - 1; 
                    col_start = col_sep_idx + 2;
                    strcpy_substr(#color_tmp, line_slot_in, col_start, line_len - col_start);
                    mem[color_idx_out] = resolve_color_idx(#color_tmp);
                );

                while (name_end_idx >= name_start_idx && str_getchar(line_slot_in, name_end_idx) <= 32) ( name_end_idx -= 1; );
                
                name_end_idx >= name_start_idx ? (
                    strcpy_substr(name_slot_out, line_slot_in, name_start_idx, name_end_idx - name_start_idx + 1);
                );
                
                1; 
            );
        );
    ) : ( 1 );
);


function load_kit_from_slider()
local(handle, note_out, chan_out, color_idx_out, current_chan, cur_row_idx, parsed, i, SLOT_LINE, SLOT_NAME,
      sel_r, context_chan, context_color)
(
    note_out = 50000; chan_out = 50001; color_idx_out = 50002; 
    SLOT_LINE = STR_BUF_LINE; SLOT_NAME = STR_BUF_NAME;

    sel_r = mem[ui_selected_row];
    sel_r < 0 ? sel_r = 0; sel_r >= MAX_ROWS ? sel_r = MAX_ROWS - 1;
    context_chan = mem[row_chan_base + sel_r];
    context_color = mem[row_color_base + sel_r];
    context_chan < 1 ? context_chan = 1;

    handle = file_open(slider10);
    handle > 0 ? (
        i = 0; loop(MAX_ROWS,
            mem[row_note_base+i] = -1; mem[row_chan_base+i] = 1; mem[row_color_base+i] = 0; 
            mem[row_name_idx+i] = 41; 
            strcpy(row_name_str_base + i, ""); 
            i+=1;
        );

        current_chan = context_chan; 
        cur_row_idx = 0;
        
        while (file_string(handle, SLOT_LINE) > 0) (
            parsed = parse_kit_line(SLOT_LINE, SLOT_NAME, note_out, chan_out, color_idx_out);
            (parsed == 1) ? (
                (mem[note_out] != -1) ? ( 
                    (cur_row_idx < MAX_ROWS) ? (
                        mem[row_note_base+cur_row_idx]  = mem[note_out];
                        mem[row_chan_base+cur_row_idx]  = current_chan; 
                        
                        strlen(SLOT_NAME) > 0 ? ( strcpy(row_name_str_base + cur_row_idx, SLOT_NAME); ) 
                        : ( sprintf(row_name_str_base + cur_row_idx, "Drum %d", mem[note_out]); );
                        
                        mem[row_name_idx+cur_row_idx] = 41; 
                        mem[row_color_base+cur_row_idx] = (mem[color_idx_out] != -1) ? mem[color_idx_out] : context_color;
                        
                        cur_row_idx += 1;
                    );
                ) : ( (mem[chan_out] != -1) ? ( current_chan = mem[chan_out]; ); );
            );
            strcpy(SLOT_LINE, ""); 
        );
        file_close(handle);
    );
);


function add_kit_from_slider()
local(handle, note_out, chan_out, color_idx_out, current_chan, 
      tmp_kit_note, tmp_kit_chan, tmp_kit_color, kit_buf_idx, 
      parsed, j, insert_idx, incoming_note, incoming_chan, incoming_color, i, SLOT_LINE, SLOT_NAME, TEMP_STR_OFFSET,
      sel_r, context_chan, context_color)
(
    note_out = 50000; chan_out = 50001; color_idx_out = 50002; 
    SLOT_LINE = STR_BUF_LINE; SLOT_NAME = STR_BUF_NAME;
    
    tmp_kit_note = kit_tmp_base; tmp_kit_chan = kit_tmp_base + 128; tmp_kit_color = kit_tmp_base + 256; 
    TEMP_STR_OFFSET = 3000; 

    sel_r = mem[ui_selected_row];
    sel_r < 0 ? sel_r = 0; sel_r >= MAX_ROWS ? sel_r = MAX_ROWS - 1;
    context_chan = mem[row_chan_base + sel_r];
    context_color = mem[row_color_base + sel_r];
    context_chan < 1 ? context_chan = 1;
    insert_idx = sel_r;

    handle = file_open(slider10);
    handle > 0 ? (
        kit_buf_idx = 0;
        i = 0; loop(MAX_ROWS, mem[tmp_kit_note+i]=-1; i+=1;); 
        current_chan = context_chan; 

        while (file_string(handle, SLOT_LINE) > 0) (
            parsed = parse_kit_line(SLOT_LINE, SLOT_NAME, note_out, chan_out, color_idx_out);
            (parsed == 1) ? (
                (mem[note_out] != -1) ? (
                    (kit_buf_idx < MAX_ROWS) ? (
                        mem[tmp_kit_note + kit_buf_idx] = mem[note_out];
                        mem[tmp_kit_chan + kit_buf_idx] = current_chan;
                        mem[tmp_kit_color + kit_buf_idx] = mem[color_idx_out];
                        strcpy(TEMP_STR_OFFSET + kit_buf_idx, SLOT_NAME);
                        kit_buf_idx += 1;
                    );
                ) : ( (mem[chan_out] != -1) ? ( current_chan = mem[chan_out]; ); );
            );
            strcpy(SLOT_LINE, ""); 
        );
        file_close(handle);

        i = 0; loop(kit_buf_idx,
            incoming_note = mem[tmp_kit_note + i]; incoming_chan = mem[tmp_kit_chan + i]; incoming_color = mem[tmp_kit_color + i];
            
            while (insert_idx < MAX_ROWS && (mem[row_note_base+insert_idx] != -1 || strlen(row_name_str_base+insert_idx) > 0)) ( insert_idx += 1; );
            
            (insert_idx < MAX_ROWS) ? (
                mem[row_note_base+insert_idx]  = incoming_note;
                mem[row_chan_base+insert_idx]  = incoming_chan;
                strcpy(row_name_str_base + insert_idx, TEMP_STR_OFFSET + i);
                mem[row_color_base+insert_idx] = (incoming_color != -1) ? incoming_color : context_color;
                mem[row_mute_base+insert_idx] = 0; mem[row_solo_base+insert_idx] = 0; mem[row_name_idx+insert_idx] = 41; 
                insert_idx += 1; 
            );
            i+=1;
        );
    );
);


(mem[ver_chk] != NEW_MAGIC_VER) ? (
    // FIX: Default start tab = 29 ("Def")
    mem[ui_edit_tab] = 29;
    mem[ui_play_prog_tab] = 29;
    mem[ui_locked_tab] = -1;
    mem[ui_play_offset] = 0;

    i_d=0; loop(MAX_ROWS,
        n_val = 36 + i_d;
        while(n_val > 127) ( n_val -= 128; );
        mem[row_note_base+i_d] = n_val;
        mem[row_chan_base+i_d]=1;
        mem[row_level_base+i_d]=80; 
        mem[row_human_base+i_d]=-1;
        mem[row_name_idx+i_d] = i_d;
        mem[row_color_base+i_d]=0;
        mem[row_len_base+i_d] = 20;
        mem[row_mute_base+i_d]=0;
        mem[row_solo_base+i_d]=0;
        mem[row_offs_base+i_d]=0; // NEW: Reset Offset
        
        strcpy(row_name_str_base + i_d, "");
        
        i_d+=1;
    );

    // FIX: Using memset safely now that vel_base is at 2,000,000
    memset(vel_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    memset(grid_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    memset(step_len_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);

    t_d=0; loop(MAX_TABS,
        mem[bars_ov_base+t_d] = 0;
        mem[subdiv_ov_base+t_d] = -1; 
        mem[hum_ov_base+t_d] = -1;
        mem[swing_ov_base+t_d] = -1;
        mem[half_speed_ov_base+t_d] = 0; // Init Half speed
        t_d+=1;
    );

    t_d=0; loop(EXT_COUNT,
        mem[ext_bars_ov_base+t_d] = 0;
        mem[ext_subdiv_ov_base+t_d] = -1; 
        mem[ext_hum_ov_base+t_d] = -1;
        mem[ext_swing_ov_base+t_d] = -1;
        mem[ext_half_speed_ov_base+t_d] = 0; // Init Extension half speed
        t_d+=1;
    );

    mem[ver_chk] = NEW_MAGIC_VER;
);

function swap_rows(a, b)
local(tmp, t, basev, baseg, basel, i, offa, offb, va, vb, ga, gb, la, lb, slot_a, slot_b)
(
    a == b ? 0 :
    (
        tmp = mem[row_mute_base+a];  mem[row_mute_base+a]=mem[row_mute_base+b];  mem[row_mute_base+b]=tmp;
        tmp = mem[row_solo_base+a];  mem[row_solo_base+a]=mem[row_solo_base+b];  mem[row_solo_base+b]=tmp;
        tmp = mem[row_note_base+a];  mem[row_note_base+a]=mem[row_note_base+b];  mem[row_note_base+b]=tmp;
        tmp = mem[row_chan_base+a];  mem[row_chan_base+a]=mem[row_chan_base+b];  mem[row_chan_base+b]=tmp;
        tmp = mem[row_level_base+a]; mem[row_level_base+a]=mem[row_level_base+b]; mem[row_level_base+b]=tmp;
        tmp = mem[row_human_base+a]; mem[row_human_base+a]=mem[row_human_base+b]; mem[row_human_base+b]=tmp;
        tmp = mem[row_len_base+a];   mem[row_len_base+a]=mem[row_len_base+b];   mem[row_len_base+b]=tmp;
        tmp = mem[row_name_idx+a];   mem[row_name_idx+a]=mem[row_name_idx+b];   mem[row_name_idx+b]=tmp;
        tmp = mem[row_offs_base+a];  mem[row_offs_base+a]=mem[row_offs_base+b]; mem[row_offs_base+b]=tmp; // NEW: Swap Offset
        tmp = mem[row_color_base+a]; mem[row_color_base+a]=mem[row_color_base+b]; mem[row_color_base+b]=tmp;

        slot_a = row_name_str_base + a;
        slot_b = row_name_str_base + b;
        strcpy(STR_BUF_SWAP, slot_a);
        strcpy(slot_a, slot_b);
        strcpy(slot_b, STR_BUF_SWAP);

        t=0; loop(TOTAL_TABS,
            (t < 22) ? (
                basev = vel_base + t*vel_stride_tab;
                baseg = grid_base + t*vel_stride_tab;
                basel = step_len_base + t*vel_stride_tab;
            ) : (
                basev = ext_vel_base + (t-22)*vel_stride_tab;
                baseg = ext_grid_base + (t-22)*vel_stride_tab;
                basel = ext_step_len_base + (t-22)*vel_stride_tab;
            );
            offa = a*vel_stride_row;
            offb = b*vel_stride_row;

            i=0; loop(MAX_STEPS,
                va = mem[basev + offa + i]; vb = mem[basev + offb + i];
                mem[basev + offa + i] = vb; mem[basev + offb + i] = va;

                ga = mem[baseg + offa + i]; gb = mem[baseg + offb + i];
                mem[baseg + offa + i] = gb; mem[baseg + offb + i] = ga;

                la = mem[basel + offa + i]; lb = mem[basel + offb + i];
                mem[basel + offa + i] = lb; mem[basel + offb + i] = la;

                i+=1;
            );
            t+=1;
        );

        sel = mem[ui_selected_row];
        sel == a ? mem[ui_selected_row]=b : sel == b ? mem[ui_selected_row]=a : 0;
    );
);



@serialize
file_mem(0, 0, state_len);
i=0; loop(MAX_ROWS, file_string(0, row_name_str_base + i * str_size); i+=1;);






@block
(slider9 == 0) ? ( slider6 = gmem[1]; );

GM_BASE = 7000000 + (slider5-1)*16;
gmem[GM_BASE] != 0x44504531 ? ( gmem[GM_BASE] = 0x44504531; gmem[GM_BASE+1] = -1; gmem[GM_BASE+2] = 29; );
mem[ui_locked_tab] = gmem[GM_BASE+1];
mem[ui_play_prog_tab] = gmem[GM_BASE+2];

// SYNC GROOVE MEMORY
i_gr = 0; max_gr = 0;
loop(32, 
    val = gmem[GMEM_GROOVE_OFFSET + i_gr];
    mem[LOCAL_GROOVE_DB + i_gr] = val; 
    abs(val) > max_gr ? max_gr = abs(val);
    i_gr+=1; 
);
mem[LOCAL_GROOVE_DB + 32] = max_gr; // Store max for UI

preview_trig ? (
    preview_chan < 1 ? preview_chan = 1 : preview_chan > 16 ? preview_chan = 16;
    mem[kill_note + preview_note] > 0 ? ( midisend(0, 0x80 | (preview_chan-1), preview_note); );
    midisend(0, 0x90 | (preview_chan-1), preview_note | (preview_vel<<8));

    l_val = mem[row_len_base+mem[ui_selected_row]];
    l_ms = (l_val < 64) ? (10 + l_val * 3.75) : (250 + (l_val-64)*11.9);

    mem[kill_note + preview_note] = srate * l_ms * 0.001;
    mem[kill_chan + preview_note] = preview_chan;
    preview_trig = 0;
);

while (midirecv(off, m1, m23)) (
    status = m1 & 0xF0;
    ch = (m1 & 0x0F) + 1;
    d1 = m23 & 0x7F; 
    d2 = (m23 >> 8) & 0x7F; 

    trig_t = -2; 
    trig_o = 0;  

    (ch == 16) ? (
        
        // --- CC 0 (Bank MSB) -> Set Start Bar Offset ---
        (status == 0xB0 && d1 == 0) ? (
             requested_start_bar = d2; 
             requested_start_bar < 1 ? requested_start_bar = 1;
        ) 
        // --- PROGRAM CHANGE ---
        : (status == 0xC0) ? (
            pc = d1;
            pc == 0 ? ( trig_t = 0; ) : // OFF (Tab 0)
            pc == 101 ? ( trig_t = 29; ) : // DEF (Tab 29)
            
            (pc >= 11 && pc <= 13) ? ( trig_t = 1 + (pc - 11); ) : 
            (pc >= 14 && pc <= 17) ? ( trig_t = 30 + (pc - 14); ) : 
            (pc >= 21 && pc <= 23) ? ( trig_t = 4 + (pc - 21); ) : 
            (pc >= 24 && pc <= 27) ? ( trig_t = 34 + (pc - 24); ) : 
            (pc >= 31 && pc <= 33) ? ( trig_t = 7 + (pc - 31); ) : 
            (pc >= 34 && pc <= 37) ? ( trig_t = 38 + (pc - 34); ) : 
            (pc >= 41 && pc <= 43) ? ( trig_t = 10 + (pc - 41); ) : 
            (pc >= 44 && pc <= 47) ? ( trig_t = 42 + (pc - 44); ) : 
            (pc >= 51 && pc <= 53) ? ( trig_t = 13 + (pc - 51); ) : 
            (pc >= 54 && pc <= 57) ? ( trig_t = 46 + (pc - 54); ) : 
            (pc >= 61 && pc <= 63) ? ( trig_t = 16 + (pc - 61); ) : 
            (pc >= 64 && pc <= 67) ? ( trig_t = 50 + (pc - 64); ) : 
            (pc >= 71 && pc <= 72) ? ( trig_t = 19 + (pc - 71); ) : 
            (pc >= 73 && pc <= 74) ? ( trig_t = 54 + (pc - 73); ) : 
            (pc >= 81 && pc <= 83) ? ( trig_t = 21 + (pc - 81); ) : 
            (pc >= 84 && pc <= 86) ? ( trig_t = 56 + (pc - 84); ) : 
            (pc >= 91 && pc <= 95) ? ( trig_t = 24 + (pc - 91); ) : 
            (pc >= 96 && pc <= 100) ? ( trig_t = 59 + (pc - 96); ); 
        ) 
        // --- NOTE ON ---
        : (status == 0x90 && d2 > 0) ? (
            nn = d1;
            (nn >= 36 && nn <= 83) ? (
                rel_note = nn - 36;
                oct = floor(rel_note / 12); 
                pitch = rel_note % 12;      

                pitch == 0 ? ( trig_t = 1; ) : 
                pitch == 2 ? ( trig_t = 4; ) : 
                pitch == 4 ? ( trig_t = 7; ) : 
                pitch == 5 ? ( trig_t = 10; ) : 
                pitch == 7 ? ( trig_t = 13; ) : 
                pitch == 9 ? ( trig_t = 16; ) : 
                pitch == 11 ? ( trig_t = 29; ) : 

                (oct < 2) ? (
                    pitch == 1 ? ( trig_t = 19 + (oct*35); ) : 
                    pitch == 3 ? ( trig_t = 20 + (oct*35); ) : 
                    pitch == 6 ? ( trig_t = 21 + (oct*35); ) : 
                    pitch == 8 ? ( trig_t = 22 + (oct*35); ) : 
                    pitch == 10 ? ( trig_t = 23 + (oct*35); ) : 0; 
                )
                : (
                    u_base = (oct==2) ? 24 : 59;
                    pitch == 1 ? ( trig_t = u_base + 0; ) : 
                    pitch == 3 ? ( trig_t = u_base + 1; ) : 
                    pitch == 6 ? ( trig_t = u_base + 2; ) : 
                    pitch == 8 ? ( trig_t = u_base + 3; ) : 
                    pitch == 10 ? ( trig_t = u_base + 4; ) : 0; 
                );
            ) : ( nn == 24 ? trig_t = -1; ); 
        );

        trig_t != -2 ? (
            mem[ui_play_prog_tab] = trig_t; 
            
            // --- OFFSET LOGIC ---
            // If requested start bar > pattern length, default to 0 (Start).
            // Else, subtract 1 from bar number to get 0-based offset.
            p_bars = eff_bars(trig_t);
            (requested_start_bar > 1 && requested_start_bar <= p_bars) ? (
                trig_o = requested_start_bar - 1;
            ) : (
                trig_o = 0;
            );

            mem[ui_play_offset] = trig_o; 
            gmem[GM_BASE+2] = trig_t; 
            pc_triggered = 1; 
        ); 
    ) 
    : midisend(off, m1, m23); 
);

(play_state == 0 && last_play_state != 0) ? (
    i_k=0; loop(128,
        mem[kill_note+i_k] > 0 ? (
            k_ch = mem[kill_chan+i_k]; k_ch < 1 ? k_ch = 1;
            midisend(0, 0x80 | (k_ch-1), i_k);
            mem[kill_note+i_k]=0;
        );
        i_k+=1;
    );
    mem[ui_last_step] = -1;
);
last_play_state = play_state;

playing = (play_state & 1);
t_pl = mem[ui_locked_tab] == -1 ? mem[ui_play_prog_tab] : mem[ui_locked_tab];

// FEATURE: If Tab 0 is selected, do NOT play
playing && t_pl != 0 && t_pl != -1 ? (
    sub_v = eff_sub(t_pl); bar_v = eff_bars(t_pl); swing_v = eff_swing(t_pl);

    // --- NEW HALF SPEED LOGIC ---
    is_half = eff_half(t_pl);
    spd_m = is_half ? 0.5 : 1.0; 
    
    st_v = bar_v * sub_v; st_b = 4 / sub_v; 
    p_l = (bar_v * 4) / spd_m; // Pattern length stretches if half speed
    
    curr_tab = mem[ui_play_prog_tab]; curr_off = mem[ui_play_offset];

    (pc_triggered || curr_tab != last_play_tab || curr_off != last_play_offset) ? (
        curr_off >= bar_v ? curr_off = 0;
        
        target_beat = (curr_off * 4) / spd_m; 
        
        snap_grid = 4.0;
        
        next_grid = floor((beat_position + (snap_grid*0.5))/snap_grid) * snap_grid;
        
        natural_pos = next_grid % p_l; 
        playback_shift = target_beat - natural_pos;
        
        last_play_tab = curr_tab; last_play_offset = curr_off; pc_triggered = 0;
    );

// --- WINDOWED LOOKAHEAD PLAYBACK ENGINE (FIXED FOR 1/2 SPEED) GROOVE AND SYNC---
    // Calculates trigger times for current and next steps, applies offsets, 
    // and fires if the timestamp falls within the current audio block.
    
    
    samps_per_beat = (srate * 60) / tempo;
    block_dur_beats = samplesblock / samps_per_beat;
    
    start_b = beat_position + playback_shift;
    end_b = start_b + block_dur_beats;
    
    // 1. Define Scan Rate (0.5 for Half Speed)
    scan_rate = is_half ? 0.5 : 1.0;
    
    // Determine which grid steps are relevant for this block
    steps_per_beat_grid = sub_v / 4;
    
    // Look 1.5 beats ahead/behind (Scaled by Scan Rate)
    look_margin = steps_per_beat_grid * 1.5; 
    
    start_step_idx = floor(start_b * scan_rate * steps_per_beat_grid) - look_margin;
    end_step_idx = ceil(end_b * scan_rate * steps_per_beat_grid) + look_margin;
    
    // Safety Pointers
    h_solo = 0; s_solo_chk=0; loop(MAX_ROWS, mem[row_solo_base+s_solo_chk]?h_solo=1; s_solo_chk+=1;);
    (t_pl < 22) ? (
        cur_vel_ptr = vel_base + t_pl*vel_stride_tab;
        cur_grid_ptr = grid_base + t_pl*vel_stride_tab;
        cur_len_ptr = step_len_base + t_pl*vel_stride_tab;
    ) : (
        cur_vel_ptr = ext_vel_base + (t_pl-22)*vel_stride_tab;
        cur_grid_ptr = ext_grid_base + (t_pl-22)*vel_stride_tab;
        cur_len_ptr = ext_step_len_base + (t_pl-22)*vel_stride_tab;
    );

    // Loop through potentially active steps
    s_idx_iter = start_step_idx;
    loop((end_step_idx - start_step_idx) + 1,
        
        // 2. Calculate nominal beat time (Reverse the Scan Rate)
        step_grid_time = s_idx_iter / steps_per_beat_grid;
        step_beat_time = step_grid_time / scan_rate;
        
        // Handle Bar wrapping for pattern lookup
        grid_lookup_idx = s_idx_iter; 
        lookup_mod = st_v;
        p_step = grid_lookup_idx % lookup_mod;
        while(p_step < 0) ( p_step += lookup_mod; );
        
        // --- Calculate Swing (Pattern Grid Based) ---
        sw_amt = (swing_v / 100) * 0.33; 
        step_in_beat = (grid_lookup_idx % steps_per_beat_grid) / steps_per_beat_grid; 
        
        swing_offset_beats = 0;
        (step_in_beat >= 0.5 && step_in_beat < 1.0) ? (
             swing_offset_beats = sw_amt; 
        );

        // --- Calculate Groove Offset (Project Time Based) ---
        // FIX: Map groove to Musical Time (step_beat_time) so it repeats every bar.
        cycle_beat = step_beat_time % 4.0; 
        groove_slot = floor(cycle_beat * 8); 
        groove_slot = clamp(groove_slot, 0, 31);
        groove_val = mem[LOCAL_GROOVE_DB + groove_slot]; 
        
        // Pre-multiply by scan_rate because the final formula divides by scan_rate.
        // This ensures the absolute time offset of the groove remains constant.
        groove_offset_beats = (groove_val * 0.125) * scan_rate;

        // Iterate Rows
        r_p = 0;
        loop(MAX_ROWS,
            p_me = h_solo ? mem[row_solo_base+r_p] : (mem[row_mute_base+r_p] == 0);
            
            p_me ? (
               row_data_idx = r_p*vel_stride_row + p_step;
               
               mem[cur_grid_ptr + row_data_idx] ? (
                   // --- Calculate Total Timing ---
                   row_offs_pct = mem[row_offs_base + r_p];
                   row_offset_beats = row_offs_pct / 100.0; 
                   
                   // 3. Apply offsets 
                   // Swing/Row are stretched by scan_rate (relative feel).
                   // Groove was pre-compensated to be absolute.
                   final_offset = (swing_offset_beats + groove_offset_beats + row_offset_beats) / scan_rate;
                   
                   total_time_beats = step_beat_time + final_offset;

                   // --- Check if this time falls in current block ---
                   diff_beats = total_time_beats - start_b;
                   diff_samples = floor(diff_beats * samps_per_beat);
                   
                   (diff_samples >= 0 && diff_samples < samplesblock) ? (
                        // FIRE NOTE
                        v_p = mem[cur_vel_ptr+row_data_idx]; v_p <= 0 ? v_p = slider1;
                        eff_h = eff_hum(t_pl); h_p = (mem[row_human_base+r_p]>=0 ? mem[row_human_base+r_p] : eff_h);
                        v_p = clamp(v_p + (rand(h_p*2)-h_p), 1, 127);
                        note_to_play = mem[row_note_base+r_p]; chan_to_play = mem[row_chan_base+r_p];
                        final_vel = floor(v_p * (mem[row_level_base+r_p]/100));
                        final_vel < 1 ? final_vel = 1 : final_vel > 127 ? final_vel = 127;
                        chan_to_play < 1 ? chan_to_play = 1 : chan_to_play > 16 ? chan_to_play = 16;

                        mem[kill_note + note_to_play] > 0 ? ( k_ch = mem[kill_chan + note_to_play]; midisend(0, 0x80|(k_ch-1), note_to_play); );
                        midisend(diff_samples, 0x90|(chan_to_play-1), note_to_play|(final_vel<<8));
                        
                        // Calc Length
                        step_len_val = mem[cur_len_ptr+row_data_idx]; 
                        ms_per_step_x = (60000 / tempo) * (4 / sub_v);
                        
                        // 4. Length scaling for 1/2 speed
                        is_half ? ms_per_step_x *= 2;
                        
                        l_ms = (step_len_val == 0) ? (mem[row_len_base+r_p]*10) : (step_len_val * ms_per_step_x * 0.98);
                        
                        mem[kill_note + note_to_play] = (srate * (l_ms + (diff_samples / srate) * 1000) * 0.001);
                        mem[kill_chan + note_to_play] = chan_to_play;
                   );
               );
            );
            r_p += 1;
        );
        s_idx_iter += 1;
    );
    
 );   
    

i_k=0; loop(128,
    mem[kill_note+i_k]>0 ? (
        mem[kill_note+i_k]-=samplesblock;
        mem[kill_note+i_k]<=0 ? (
            k_ch = mem[kill_chan+i_k]; k_ch < 1 ? k_ch = 1;
            midisend(0, 0x80 | (k_ch-1), i_k);
            mem[kill_note+i_k]=0;
        );
    );
    i_k+=1;
);
































@gfx 1618 740
grid_height = slider11; 
ext_noinit = 1.0;
ext_noundo = 1; 

shift_dn = (mouse_cap & 8);
ctrl_dn  = (mouse_cap & 4);
alt_dn   = (mouse_cap & 16);

function draw_text(x,y,s,r,g,b) ( gfx_set(r,g,b,1); gfx_x=x; gfx_y=y; gfx_drawstr(s); );
function rect(x,y,w,h,r,g,b,a) ( gfx_set(r,g,b,a); gfx_rect(x,y,w,h); );

function find_covering_head(row_idx, step_idx, st_v)
local(lb, s0, ii, l)
(
    lb = 1;
    loop(step_idx,
        s0 = step_idx - lb;
        ii = row_idx*vel_stride_row + s0;
        mem[curr_pat_g_ptr + ii] ? (
            l = mem[curr_pat_l_ptr + ii];
            l < 1 ? l = 1;
            l > lb ? ( lb = 1000000; ii; ) : 0;
        ) : 0;
        lb += 1;
    );
    lb > 999999 ? ii : -1;
);

function draw_color_popup(px, py) local(i, row_hh, bw, bh, rx, ry, hover, c_name) (
    bw = 180; row_hh = 18; bh = row_hh * 18 + 6;
    px + bw > gfx_w ? px = gfx_w - bw - 2;
    py + bh > gfx_h ? py = gfx_h - bh - 2;
    px < 2 ? px = 2; py < 2 ? py = 2;

    rect(px, py, bw, bh, 0.08, 0.08, 0.08, 1);
    rect(px+1, py+1, bw-2, bh-2, 0.15, 0.15, 0.15, 1);

    i=0; loop(18,
        rx = px + 4; ry = py + 3 + i*row_hh;
        hover = (mx>=rx && mx<px+bw-4 && my>=ry && my<ry+row_hh);
        hover ? rect(rx, ry, bw-8, row_hh, 0.25,0.25,0.25,1) : 0;
        get_menu_item(#color_menu, i, #cn); 
        get_palette_values(i); 
        gfx_set(cr, cg, cb, 1);
        gfx_x = rx + 10; gfx_y = ry + 4; gfx_drawstr(#cn);
        (!mb && p_mb==1 && hover) ? ( 
            mem[row_color_base + color_popup_row] = i; 
            color_popup_active = 0; 
            mem[ui_selected_row] = color_popup_row;
        );
        i+=1;
    );

    (mb && p_mb==0 && !(mx>=px && mx<px+bw && my>=py && my<py+bh)) ? color_popup_active = 0;
);

function dr_p(x,y,lab,v_p,min_v,max_v,w) (
    draw_text(x, y, lab, 0.7,0.7,0.7);
    max_v == 100 ? sprintf(#vs, "%d%%", mem[v_p]) : sprintf(#vs, "%d", mem[v_p]);
    draw_text(x+w-25, y, #vs, 1,1,1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+20) ? (
        capture_id = v_p; capture_ptr = v_p; capture_slider_idx = 0;
        capture_min = min_v; capture_max = max_v; capture_is_signed = (min_v < 0);
        // FIX: If this is an Offset control, flag it as continuous signed
        (v_p >= row_offs_base && v_p < row_offs_base + MAX_ROWS) ? capture_mode = 2 : capture_mode = 0;
    );
);

function dr_glob(id_num, x, y, w, lab, val_in, min_v, max_v, is_subdiv, is_swing, ov_addr, is_signed, slider_idx)
  local(v, is_ov, curr_val, active_tab, target_addr)
(
    active_tab = mem[ui_edit_tab]; is_ov = 0; curr_val = val_in; target_addr = -1;
    (active_tab > 0 && ov_addr >= 0) ? (
        (active_tab < 22) ? target_addr = ov_addr + active_tab
        : (active_tab < TOTAL_TABS) ? (
            ov_addr == bars_ov_base ? target_addr = ext_bars_ov_base + (active_tab-22) :
            ov_addr == subdiv_ov_base ? target_addr = ext_subdiv_ov_base + (active_tab-22) :
            ov_addr == hum_ov_base ? target_addr = ext_hum_ov_base + (active_tab-22) :
            ov_addr == swing_ov_base ? target_addr = ext_swing_ov_base + (active_tab-22) : 0;
        );
        target_addr >= 0 ? (
            ov_val = mem[target_addr];
            (is_signed && ov_val >= 0) || (!is_signed && ov_val > 0) ? ( is_ov = 1; curr_val = ov_val; );
        );
    );

    rect(x, y, w, 20, 0.2, 0.2, 0.2, 1);
    draw_text(x+5, y+5, lab, 0.7,0.7,0.7);

    is_subdiv ? (
        v = curr_val;
        v==0?strcpy(#s,"8"):v==1?strcpy(#s,"12"):v==2?strcpy(#s,"16"):v==3?strcpy(#s,"24"):strcpy(#s,"32");
    )
    : is_swing ? ( sprintf(#s, "%d%%", curr_val); )
    : ( sprintf(#s, "%d", curr_val); );

    draw_text(x+w-35, y+5, #s, 1, 1, 1);

    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+20) ? (
        capture_id = id_num; capture_min = min_v; capture_max = max_v; capture_is_signed = is_signed; capture_mode = 0;
        (rmb && active_tab > 0 && target_addr >= 0) ? (
            capture_ptr = target_addr; capture_slider_idx = 0;
            mem[capture_ptr] < 0 ? mem[capture_ptr] = val_in;
            !is_signed && mem[capture_ptr] == 0 ? mem[capture_ptr] = val_in;
        ) : (mb) ? (
            is_ov ? ( capture_ptr = target_addr; capture_slider_idx = 0; ) : ( capture_slider_idx = slider_idx; );
        );
    );
);

gfx_clear = 0.05;
mx=mouse_x; my=mouse_y; mb=mouse_cap&1; rmb=mouse_cap&2;
p_mb=l_mb; l_mb=mb; p_mx=l_mx; l_mx=mx; p_my=l_my; l_my=my;

// FIX: Force update of keyboard modifiers immediately
gfx_getchar(); 

(!mb && !rmb) ? (
  capture_id = 0;          
  capture_slider_idx = 0;  
  len_drag_active = 0; 
  row_drag_active = 0; 
  drag_mode = 0; 
  last_drag_idx = -1; 
  drag_accum_gen = 0; 
  drag_lock_row = -1; 
);

ui_lock = (capture_id == 9999);
help_active ? capture_id = 90000;

UI_TOP_X=5; UI_TOP_Y=10; UI_GAP_X=40; UI_ROW_H=20;
HDR_X=UI_TOP_X; HDR_Y=UI_TOP_Y; HDR_W=240; HDR_H=20;
GLOB_LBL_W=180; GLOB_LBL_YOFF=0;
GW_DEFVEL_W=150; GW_ROWS_W=180; GW_INST_W=130;

ROW2_Y_OFFSET=40; ROW2_Y=UI_TOP_Y + ROW2_Y_OFFSET;
FOLLOW_LBL_X=UI_TOP_X; FOLLOW_LBL_W=55;
FOLLOW_BOX_X=UI_TOP_X + 60; FOLLOW_BOX_W=20; FOLLOW_BOX_H=16;

BTN_H=18; BTN_Y=ROW2_Y; BTN_X0=UI_TOP_X + 120;
BTN_W_COPY=109; BTN_W_PASTE=114; BTN_W_CLEAR=114; BTN_GAP=10;

PAT_LBL_W=190; PAT_BOX_H=20; PAT_BOX_W=120; PAT_BOX_GAP=70;
HIT_PAD_L=2; HIT_PAD_R=2;

function calc_vis_beat(t_in) (
    sub_v = eff_sub(t_in); 
    bar_v = eff_bars(t_in); 
    
    // --- HALF SPEED VISUAL LOGIC ---
    is_half = eff_half(t_in);
    spd_m = is_half ? 0.5 : 1.0;
    
    p_l = (bar_v * 4) / spd_m;
    
    // Determine playing tab (Safe for both 0 and -1 logic)
    playing_tab = (mem[ui_locked_tab] <= 0) ? mem[ui_play_prog_tab] : mem[ui_locked_tab];
    
    offset_add = 0; 
    (play_state & 1 && t_in == playing_tab) ? ( offset_add = playback_shift; );
    
    // --- LATENCY COMPENSATION FIX ---
    // Calculate buffer length in beats: (Samples / SampleRate) * (BPM / 60)
    buffer_beats = (samplesblock / srate) * (tempo / 60);
    
    // Subtract buffer from current position so graphics align with audio output
    visual_pos = beat_position - buffer_beats ;
    
    // Map visual position back to grid scale (* spd_m)
    play_state & 1 ? fmod_pos(visual_pos + offset_add, p_l) * spd_m : 0;
);

function btn(x,y,w,txt) (
    rect(x,y,w,BTN_H, 0.3,0.3,0.3,1);
    draw_text(x+5,y+5,txt,1,1,1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+BTN_H);
);

(mb && capture_id != 0 && capture_id != 9999 && capture_id != 12 && capture_id != 13 && capture_id != 12012 && capture_id != 42424 && capture_id != 88888 && capture_id != 77777 && capture_id != 11111) ? (
    drag_sens = (capture_max - capture_min) > 60 ? 1.0 : 5.0;
    
    // FIX: Increase sensitivity for PUSH/PULL (capture_mode == 2)
    capture_mode == 2 ? drag_sens = 5.0;

    drag_accum_gen += (mx - p_mx);
    
    abs(drag_accum_gen) >= drag_sens ? (
        inc = drag_accum_gen / drag_sens;
        inc = (inc > 0) ? floor(inc) : ceil(inc);
        drag_accum_gen -= (inc * drag_sens);
        
        capture_slider_idx > 0 ? (
            sv = slider(capture_slider_idx); 
            nv = clamp(sv + inc, capture_min, capture_max);
            slider(capture_slider_idx) = nv; 
            slider_automate(capture_slider_idx);
            capture_slider_idx == 1 ? (
                i_rst = 0;
                loop(MAX_ROWS * MAX_STEPS,
                    mem[curr_pat_g_ptr + i_rst] == 0 ? mem[curr_pat_v_ptr + i_rst] = 0;
                    i_rst += 1;
                );
            );
        ) : (
            mv = mem[capture_ptr]; 
            nv = clamp(mv + inc, capture_min, capture_max);
            
            // FIX: Allow continuous negative values if mode is 2 (Offsets)
            capture_mode != 2 && capture_is_signed ? (
               // Legacy Toggle Logic (Humanize, etc)
               nv <= 0 ? nv = -1; 
               mv == -1 && inc > 0 ? nv = 0;
            );
            
            mem[capture_ptr] = nv;
        );
    );
);

tx = UI_TOP_X; ty = UI_TOP_Y;
gfx_setfont(1, "Arial", 22, 'b');
bri = .9;
draw_text(HDR_X+4, HDR_Y+3, "N2N Drum Arranger", 0.2*bri,  1.0*bri,  1.0*bri); // Cyan
gfx_setfont(0);

row1_y = UI_TOP_Y + 5; x1 = HDR_X + HDR_W + UI_GAP_X - 10;
gfx_set(0.8,0.8,0.8,1); gfx_x = x1 + 30; gfx_y = row1_y + 5 + GLOB_LBL_YOFF; gfx_drawstr("GLOBAL SETTINGS:");

// REMOVED DEFAULT VELOCITY FROM HEADER
// SHIFTED CONTROLS LEFT

GW_ROWS_W = 170; 
GW_HEIGHT_W = 100; 
xfix = 180;
x1 = x1 + xfix ;

dr_glob(16, x1+14, row1_y, GW_ROWS_W+6, "# ROWS TO SHOW:", slider7, 1, 128,  0, 0, -1, 0, 7);  x1 += GW_ROWS_W + 33;
dr_glob(17, x1+35, row1_y, GW_HEIGHT_W+31, "HEIGHT:", slider11, 10, 30, 0, 0, -1, 0, 11); x1 += GW_HEIGHT_W + UI_GAP_X;

dr_glob(15, x1+ 75, row1_y, GW_INST_W+1,   "INST ID:", slider5, 1, 512,  0, 0, -1, 0, 5); x1 += GW_INST_W + UI_GAP_X;

btn(x1+87, row1_y, 85, " LOAD KIT") ? (
    load_kit_from_slider();
); 

btn(x1+177, row1_y, 85, " ADD KIT") ? (
    add_kit_from_slider();
);

btn(x1+402, row1_y, 18, "?") ? (
    help_active = !help_active;
);

x1 = x1 - xfix;


rect(0, 45, gfx_w, 1, 0.25, 0.25, 0.25, 1);

row2_y = ROW2_Y; 



mem[ui_locked_tab] == -1 ? mem[ui_edit_tab] = mem[ui_play_prog_tab]; 
is_follow = (mem[ui_locked_tab] == -1);

// FIX: Check for -1 instead of 0
mem[ui_locked_tab] == -1 ? mem[ui_edit_tab] = mem[ui_play_prog_tab]; 
is_follow = (mem[ui_locked_tab] == -1);

draw_text(FOLLOW_LBL_X+5, row2_y+5, "FOLLOW:", 0.8,0.8,0.8); 
rect(FOLLOW_BOX_X+5, row2_y, FOLLOW_BOX_W, FOLLOW_BOX_H, 0.2, 0.2, 0.2, 1); 
is_follow ? draw_text(FOLLOW_BOX_X+10, row2_y+5, "X", 0,1,0);

// FIX: Clicking toggles between -1 (Follow) and 0 (Off/Default) or just sets -1
(mb && p_mb == 0 && mx>=FOLLOW_BOX_X && mx<FOLLOW_BOX_X+FOLLOW_BOX_W && my>=row2_y && my<row2_y+FOLLOW_BOX_H) ? ( 
    mem[ui_locked_tab] == -1 ? mem[ui_locked_tab] = 29 : mem[ui_locked_tab] = -1; 
    gmem[GM_BASE+1] = mem[ui_locked_tab]; 
);



t_e = mem[ui_edit_tab];

// --- FEATURE: TAB 0 (OFF) DISPLAY ---
(t_e == 0) ? (
    gfx_set(1, 0.2, 0.2, 1);
    gfx_setfont(1, "Arial", 48, 'b');
    gfx_x = (gfx_w/2) - 150; 
    gfx_y = (gfx_h/2) + 50; 
    gfx_drawstr("PATTERN OFF");
    gfx_setfont(0);
) : (
    (t_e < 22) ? ( curr_pat_v_ptr = vel_base + t_e*vel_stride_tab; curr_pat_g_ptr = grid_base + t_e*vel_stride_tab; curr_pat_l_ptr = step_len_base + t_e*vel_stride_tab; )
           : ( curr_pat_v_ptr = ext_vel_base + (t_e-22)*vel_stride_tab; curr_pat_g_ptr = ext_grid_base + (t_e-22)*vel_stride_tab; curr_pat_l_ptr = ext_step_len_base + (t_e-22)*vel_stride_tab; );

    bx = BTN_X0;
    
    // --- COPY PATTERN + METADATA ---
    btn(bx-15, row2_y, BTN_W_COPY+21, " Copy Pattern") ? ( 
        memcpy(copy_tab_v_buf, curr_pat_v_ptr, vel_stride_tab); 
        memcpy(copy_tab_g_buf, curr_pat_g_ptr, vel_stride_tab); 
        memcpy(copy_tab_l_buf, curr_pat_l_ptr, vel_stride_tab);
        // Store Metadata
        cp_valid = 1;
        cp_bars = eff_bars(mem[ui_edit_tab]);
        cp_sub = eff_sub(mem[ui_edit_tab]);
        cp_hum = eff_hum(mem[ui_edit_tab]);
        cp_sw = eff_swing(mem[ui_edit_tab]);
        cp_half = eff_half(mem[ui_edit_tab]);
    ); 
    bx += BTN_W_COPY + BTN_GAP;

    // --- PASTE PATTERN + METADATA ---
    btn(bx+1, row2_y, BTN_W_PASTE+16, " Paste Pattern") ? ( 
        memcpy(curr_pat_v_ptr, copy_tab_v_buf, vel_stride_tab); 
        memcpy(curr_pat_g_ptr, copy_tab_g_buf, vel_stride_tab); 
        memcpy(curr_pat_l_ptr, copy_tab_l_buf, vel_stride_tab); 
        // Apply Metadata
        cp_valid ? (
            act_t = mem[ui_edit_tab];
            (act_t < 22) ? (
                mem[bars_ov_base+act_t] = cp_bars;
                mem[subdiv_ov_base+act_t] = (cp_sub==8?0:cp_sub==12?1:cp_sub==16?2:cp_sub==24?3:4);
                mem[hum_ov_base+act_t] = cp_hum;
                mem[swing_ov_base+act_t] = cp_sw;
                mem[half_speed_ov_base+act_t] = cp_half;
            ) : (
                mem[ext_bars_ov_base+(act_t-22)] = cp_bars;
                mem[ext_subdiv_ov_base+(act_t-22)] = (cp_sub==8?0:cp_sub==12?1:cp_sub==16?2:cp_sub==24?3:4);
                mem[ext_hum_ov_base+(act_t-22)] = cp_hum;
                mem[ext_swing_ov_base+(act_t-22)] = cp_sw;
                mem[ext_half_speed_ov_base+(act_t-22)] = cp_half;
            );
        );
    ); 
    bx += BTN_W_PASTE + BTN_GAP;

    btn(bx+12, row2_y, BTN_W_CLEAR+16, " Clear Pattern") ? ( memset(curr_pat_g_ptr, 0, vel_stride_tab); memset(curr_pat_v_ptr, 0, vel_stride_tab); memset(curr_pat_l_ptr, 0, vel_stride_tab); ); bx += BTN_W_CLEAR + BTN_GAP;

    pat_lbl_x = bx; gfx_set(0.8,0.8,0.8,1); gfx_x = pat_lbl_x; gfx_y = row2_y + 5; gfx_drawstr("    PATTERN SETTINGS:"); pat_x = pat_lbl_x + PAT_LBL_W;
    pat_y = row2_y - 0; box_w = PAT_BOX_W; box_h = PAT_BOX_H; gap_w = PAT_BOX_GAP;

    bars_x = pat_x; active_tab = mem[ui_edit_tab]; bars_addr = -1; (active_tab > 0) ? ( bars_addr = (active_tab < 22) ? (bars_ov_base + active_tab) : (ext_bars_ov_base + (active_tab-22)); );
    curr_bars = eff_bars(active_tab); rect(bars_x+11, pat_y, box_w+11, box_h, 0.2,0.2,0.2,1); draw_text(bars_x+15, pat_y+5, "BARS:", 0.7,0.7,0.7); sprintf(#s, "%d", curr_bars); draw_text(bars_x+box_w-11, pat_y+5, #s, 1,1,1);
    
    // FIX: Aligned BARS hit-detection to match visual box
    bars_hit_l = bars_x + 11; 
    bars_hit_r = bars_x + box_w + 22; 
    (mx>=bars_hit_l && mx<bars_hit_r && my>=pat_y && my<pat_y+box_h && mb && p_mb==0) ? ( capture_id = 12; drag_accum = 0; );
    (mb && capture_id == 12) ? ( drag_accum += (mx - p_mx); abs(drag_accum) > 8 ? ( step_dir = drag_accum > 0 ? 1 : -1; drag_accum = 0; target_addr = bars_addr; (active_tab > 0 && target_addr >= 0) ? ( mem[target_addr] <= 0 ? mem[target_addr] = slider4; mem[target_addr] = clamp(mem[target_addr] + step_dir, 1, 4); ); ); );

    sub_x = bars_x + box_w + gap_w; active_tab = mem[ui_edit_tab]; ov_s = eff_sub(active_tab); curr_s = (ov_s==8?0:ov_s==12?1:ov_s==16?2:ov_s==24?3:4);
    rect(sub_x+1, pat_y, box_w+11, box_h, 0.2,0.2,0.2,1); draw_text(sub_x+6, pat_y+5, "SUBDIV:", 0.7,0.7,0.7); v=curr_s; v==0?strcpy(#s,"8"):v==1?strcpy(#s,"12"):v==2?strcpy(#s,"16"):v==3?strcpy(#s,"24"):strcpy(#s,"32"); draw_text(sub_x+box_w-23, pat_y+5, #s, 1,1,1);
    
    // FIX: Aligned SUBDIV hit-detection to match visual box
    sub_hit_l = sub_x + 1; 
    sub_hit_r = sub_x + box_w + 12; 
    (mx>=sub_hit_l && mx<sub_hit_r && my>=pat_y && my<pat_y+box_h && mb && p_mb==0) ? ( capture_id = 13; drag_accum = 0; );
    (mb && capture_id == 13) ? ( drag_accum += (mx - p_mx); abs(drag_accum) > 8 ? ( step_dir = drag_accum > 0 ? 1 : -1; drag_accum = 0; target_addr = (active_tab < 22) ? (subdiv_ov_base+active_tab) : (ext_subdiv_ov_base+(active_tab-22)); mem[target_addr] < 0 ? mem[target_addr] = slider3; mem[target_addr] = clamp(mem[target_addr] + step_dir, 0, 4); ); );

    sw_x = sub_x + box_w + gap_w; rect(sw_x-8, pat_y, box_w+24, box_h, 0.2,0.2,0.2,1); draw_text(sw_x+5, pat_y+5, "SWING:", 0.7,0.7,0.7);
    act_t = mem[ui_edit_tab]; sw_addr = -1; (act_t > 0) ? ( sw_addr = (act_t < 22) ? (swing_ov_base + act_t) : (ext_swing_ov_base + (act_t-22)); );
    curr_sw = eff_swing(act_t); sprintf(#s, "%d%%", curr_sw); 

    is_sw_local = (sw_addr >= 0 && mem[sw_addr] >= 0);

    pl_x = sw_x + 55;
    rect(pl_x, pat_y, 15, 16, 0.2,0.2,0.2,1);

    is_sw_local ? draw_text(pl_x+3, pat_y+5, "M", 1,0.5,0)
                : draw_text(pl_x+3, pat_y+5, "P", 0,1,1);

    (mb && p_mb==0 && mx>=pl_x && mx<pl_x+15 && my>=pat_y-1 && my<pat_y-1+box_h) ? (
        is_sw_local
            ? ( mem[sw_addr] = -1; )                               
            : ( mem[sw_addr] = clamp(eff_swing(act_t), 0, 100); )   
    );

    draw_text(sw_x+box_w-35, pat_y+5, #s, 1,1,1);
    
    // FIX: Aligned SWING hit-detection to match expanded visual box
    sw_hit_l = pl_x + 20; 
    sw_hit_r = sw_x + box_w + 16;
    (mb && p_mb==0 && mx>=sw_hit_l && mx<sw_hit_r && my>=pat_y && my<pat_y+box_h) ? (
        (is_sw_local) ? (
            capture_id = 12012;
            capture_min = 0;
            capture_max = 100;
            capture_is_signed = 0;

            sw_addr >= 0 ? (
                mem[sw_addr] < 0 ? mem[sw_addr] = clamp(eff_swing(act_t), 0, 100);
                capture_ptr = sw_addr;
                capture_slider_idx = 0;
            );
        );
    );

    (mb && capture_id == 12012) ? ( d_delta = (mx - p_mx); mv = mem[capture_ptr]; nv = clamp(mv + d_delta, 0, 100); mem[capture_ptr] = nv; );

    hum_x = sw_x + box_w + gap_w; dr_glob(11, hum_x+9, pat_y, box_w+7, "HUMANIZE:", slider2, 0, 25, 0, 0, hum_ov_base, 1, 2);
    
// --- 1/2 SPEED TOGGLE (Conditional: Only for 24/32 Subdiv) ---
    curr_sub_val = eff_sub(mem[ui_edit_tab]);
    
    // Define X position for Stretch button (defaults to next to Humanize)
    st_x = hum_x + box_w + gap_w; 
    
    (curr_sub_val == 24 || curr_sub_val == 32) ? (
        
        hf_x = st_x-30; // Place 1/2 speed here
        st_x = hf_x + 14 + gap_w; // Push Stretch button to the right
        
        hf_act = eff_half(mem[ui_edit_tab]);
        
        // Hit Logic
        (mb && p_mb == 0 && mx>=hf_x && mx<hf_x+80 && my>=pat_y && my<pat_y+box_h) ? (
            t_addr = (mem[ui_edit_tab] < 22) ? half_speed_ov_base + mem[ui_edit_tab] : ext_half_speed_ov_base + (mem[ui_edit_tab]-22);
            mem[t_addr] = !mem[t_addr];
        );
        
        // Visuals [ 1x | 1/2 ]
        rect(hf_x, pat_y, 80, box_h, 0.2, 0.2, 0.2, 1);
        !hf_act ? ( gfx_set(0.6, 0.6, 0.6, 1); gfx_rect(hf_x, pat_y, 40, box_h); ); 
        hf_act  ? ( gfx_set(0.6, 0.6, 0.6, 1); gfx_rect(hf_x+40, pat_y, 40, box_h); ); 

        !hf_act ? gfx_set(0,0,0,1) : gfx_set(0.5,0.5,0.5,1);
        draw_text(hf_x+10, pat_y+5, "1x", 0,0,0); 

        hf_act ? gfx_set(0,0,0,1) : gfx_set(0.5,0.5,0.5,1);
        draw_text(hf_x+47, pat_y+5, "1/2", 0,0,0);
        
        gfx_set(0,0,0,1); gfx_line(hf_x+40, pat_y, hf_x+40, pat_y+box_h);
    );

    // --- SMART STRETCH MENU (Always Visible) ---
    // --- SMART STRETCH MENU (Always Visible) ---
        btn(st_x, pat_y+1, 84, " STRETCH") ? ( 
            gfx_x = st_x; gfx_y = pat_y + 20;
            sel_stretch = gfx_showmenu("Stretch Pattern 2x (Short)|Stretch Pattern 2x (Long)|Stretch Pattern 4x (Short)|Stretch Pattern 4x (Long)||Stretch Selected Row 2x (Short)|Stretch Selected Row 2x (Long)|Stretch Selected Row 4x (Short)|Stretch Selected Row 4x (Long)");
            
            sel_stretch > 0 ? (
                // 1. Determine Scope and Type
                (sel_stretch <= 4) ? ( is_pattern = 1; base_s = sel_stretch; ) : ( is_pattern = 0; base_s = sel_stretch - 4; );
                
                // 2. Determine Factor (2x or 4x)
                factor = (base_s <= 2) ? 2 : 4;
                
                // 3. Determine Length Mode (Short vs Long)
                // Evens (2, 4) are Long. Odds (1, 3) are Short.
                is_long = (base_s == 2 || base_s == 4);
                
                st_cnt = eff_bars(mem[ui_edit_tab]) * curr_sub_val;
                
                // 4. Determine Row Range
                r_start = is_pattern ? 0 : mem[ui_selected_row];
                r_end = is_pattern ? MAX_ROWS : mem[ui_selected_row] + 1;
                
                // Pointers setup
                (mem[ui_edit_tab] < 22) ? (
                    basev = vel_base + mem[ui_edit_tab]*vel_stride_tab;
                    baseg = grid_base + mem[ui_edit_tab]*vel_stride_tab;
                    basel = step_len_base + mem[ui_edit_tab]*vel_stride_tab;
                ) : (
                    basev = ext_vel_base + (mem[ui_edit_tab]-22)*vel_stride_tab;
                    baseg = ext_grid_base + (mem[ui_edit_tab]-22)*vel_stride_tab;
                    basel = ext_step_len_base + (mem[ui_edit_tab]-22)*vel_stride_tab;
                );
    
                // 5. Execute Stretch
                r_iter = r_start;
                loop(r_end - r_start,
                    row_offset = r_iter * vel_stride_row;
                    
                    // Copy current row to buffer
                    memcpy(copy_row_v_buf, basev + row_offset, st_cnt);
                    memcpy(copy_row_g_buf, baseg + row_offset, st_cnt);
                    memcpy(copy_row_l_buf, basel + row_offset, st_cnt);
                    
                    // Clear original row
                    memset(basev + row_offset, 0, st_cnt);
                    memset(baseg + row_offset, 0, st_cnt);
                    memset(basel + row_offset, 0, st_cnt);
                    
                    // Distribute steps
                    s_idx = 0; 
                    // Only process the first portion that fits into the new length
                    loop_limit = ceil(st_cnt / factor);
                    
                    loop(loop_limit,
                        target_idx = s_idx * factor;
                        
                        (target_idx < st_cnt) ? (
                            mem[basev + row_offset + target_idx] = mem[copy_row_v_buf + s_idx];
                            mem[baseg + row_offset + target_idx] = mem[copy_row_g_buf + s_idx];
                            
                            raw_len = mem[copy_row_l_buf + s_idx];
                            
                            // FIX: Logic for Length Stretching
                            // If Long: treat 0 (default) as 1, then multiply by factor.
                            // If Short: Keep original length.
                            
                            new_len = raw_len;
                            
                            is_long ? (
                                new_len = (raw_len < 1 ? 1 : raw_len) * factor;
                            );
                            
                            mem[basel + row_offset + target_idx] = new_len;
                        );
                        s_idx += 1;
                    );
                    r_iter += 1;
                );
            );
        );

    rect(0, 74, gfx_w, 1, 0.25, 0.25, 0.25, 1);
);

// --- TAB ROW 1 ---
ty = row2_y + 30; tx = 10;
gui_t = 0;
loop(TOTAL_TABS,
    my_row = mem[tab_ui_row_base + gui_t];
    (my_row == 1) ? (
        tw = mem[tab_w_base + gui_t]; 
        is_ed = (gui_t == mem[ui_edit_tab]);

        // Get Configured Color
        t_r = mem[tab_col_r + gui_t];
        t_g = mem[tab_col_g + gui_t];
        t_b = mem[tab_col_b + gui_t];

        // Draw Background
        is_ed ? (
             // Selected: Full Brightness, White Border
             rect(tx, ty, tw-5, 26, 1, 1, 1, 1); 
             rect(tx+1, ty+1, tw-7, 24, t_r, t_g, t_b, 1);
        ) : (
             // Unselected: Dimmed Color
             rect(tx, ty, tw-5, 26, t_r*0.4, t_g*0.4, t_b*0.4, 1);
        );

        get_t_name(gui_t, #tn); 
        
        // --- TEXT COLOR FIX ---
        is_ed ? (
            draw_text(tx+5, ty+9, #tn, 0, 0, 0); 
        ) : (
            draw_text(tx+5, ty+9, #tn, 1, 1, 1);
        );
        
        // --- DOUBLE CLICK LOGIC ---
        (mb && p_mb == 0 && mx>=tx && mx<tx+tw-24 && my>=ty && my<ty+26) ? ( 
            (time_precise() - last_tab_clk < 0.3 && last_tab_idx == gui_t) ? (
                mem[ui_locked_tab] = gui_t; // Double click = Lock
                
                mem[ui_edit_tab] = gui_t;   // <--- ADD THIS LINE (Force View)
                
                gmem[GM_BASE+1] = mem[ui_locked_tab]; 
                last_tab_clk = 0; 
            ) : (
                // FIX: BLINKING ISSUE. If Follow (-1) is active, don't change view on single click.
                mem[ui_locked_tab] != -1 ? (
                    mem[ui_edit_tab] = gui_t; 
                    mem[ui_play_offset] = 0; playback_shift = 0; 
                );
                mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
                last_tab_clk = time_precise(); last_tab_idx = gui_t;
            );
        );
        // --------------------------

        lx=tx+tw-24; ly=ty+5; lw=14; lh=16; 
        rect(lx,ly,lw,lh, 0.1,0.1,0.1,1); 
        
        (mb && p_mb == 0 && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( mem[ui_locked_tab]=(mem[ui_locked_tab]==gui_t?-1:gui_t); gmem[GM_BASE+1]=mem[ui_locked_tab]; mem[ui_play_offset] = 0; playback_shift = 0; );
        (rmb && !p_rmb && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( mem[ui_edit_tab] = gui_t; mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; );
        
        mem[ui_locked_tab] == gui_t ? rect(lx+2,ly+2,lw-4,lh-4, 0.3,.6,.7,1); 
        (mem[ui_play_prog_tab] == gui_t) ? (gfx_set(1,1,0,1); gfx_circle(tx+tw-17, ty+13, 2, 1););
        tx+=tw;
    );
    gui_t+=1;
);

// --- TAB ROW 2 ---
ty += 30; tx = 10;
gui_t = 0;
loop(TOTAL_TABS,
    my_row = mem[tab_ui_row_base + gui_t];
    (my_row == 2) ? (
        tw = mem[tab_w_base + gui_t]; 
        is_ed = (gui_t == mem[ui_edit_tab]);

        // Get Configured Color
        t_r = mem[tab_col_r + gui_t];
        t_g = mem[tab_col_g + gui_t];
        t_b = mem[tab_col_b + gui_t];

        // Draw Background
        is_ed ? (
             // Selected: Full Brightness, White Border
             rect(tx, ty, tw-5, 26, 1, 1, 1, 1); 
             rect(tx+1, ty+1, tw-7, 24, t_r, t_g, t_b, 1);
        ) : (
             // Unselected: Dimmed Color
             rect(tx, ty, tw-5, 26, t_r*0.4, t_g*0.4, t_b*0.4, 1);
        );

        get_t_name(gui_t, #tn); 
        
        // --- TEXT COLOR FIX ---
        is_ed ? (
            draw_text(tx+5, ty+9, #tn, 0, 0, 0); 
        ) : (
            draw_text(tx+5, ty+9, #tn, 1, 1, 1);
        );
        
        // --- DOUBLE CLICK LOGIC ---
        (mb && p_mb == 0 && mx>=tx && mx<tx+tw-24 && my>=ty && my<ty+26) ? ( 
            (time_precise() - last_tab_clk < 0.3 && last_tab_idx == gui_t) ? (
                mem[ui_locked_tab] = gui_t; // Double click = Lock
                
                mem[ui_edit_tab] = gui_t;   // <--- ADD THIS LINE (Force View)
                
                gmem[GM_BASE+1] = mem[ui_locked_tab]; 
                last_tab_clk = 0; 
            ) : (
                // FIX: BLINKING ISSUE. If Follow (-1) is active, don't change view on single click.
                mem[ui_locked_tab] != -1 ? (
                    mem[ui_edit_tab] = gui_t; 
                    mem[ui_play_offset] = 0; playback_shift = 0; 
                );
                mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
                last_tab_clk = time_precise(); last_tab_idx = gui_t;
            );
        );
        // --------------------------

        lx=tx+tw-24; ly=ty+5; lw=14; lh=16; 
        rect(lx,ly,lw,lh, 0.1,0.1,0.1,1); 
        
        (mb && p_mb == 0 && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( mem[ui_locked_tab]=(mem[ui_locked_tab]==gui_t?-1:gui_t); gmem[GM_BASE+1]=mem[ui_locked_tab]; mem[ui_play_offset] = 0; playback_shift = 0; );
        (rmb && !p_rmb && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( mem[ui_edit_tab] = gui_t; mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; );
        
        mem[ui_locked_tab] == gui_t ? rect(lx+2,ly+2,lw-4,lh-4, 0.3,.6,.7,1); 
        (mem[ui_play_prog_tab] == gui_t) ? (gfx_set(1,1,0,1); gfx_circle(tx+tw-17, ty+13, 2, 1););
        tx+=tw;
    );
    gui_t+=1;
);

// --- GRID DRAWING (ONLY IF NOT TAB 0) ---
(t_e != 0) ? (
    t_e = mem[ui_edit_tab]; sel_r = mem[ui_selected_row]; sel_r >= MAX_ROWS ? (sel_r = MAX_ROWS - 1; mem[ui_selected_row] = sel_r;);

    ty+=30; pk_w = (gfx_w-20)/128; rect(10, ty, gfx_w-20, 32, 0.02, 0.02, 0.02, 1);
    i_p=0; loop(128,
        px=10+i_p*pk_w; m=i_p%12; is_blk=(m==1||m==3||m==6||m==8||m==10); is_sel = (mem[row_note_base+sel_r] == i_p);
    is_blk
      ? ( is_sel
            ? rect(px, ty, pk_w-1, 30, 0.22, 0.52, 0.64, 1)   
            : rect(px, ty, pk_w-1, 30, 0.2,  0.2,  0.2,  1);
        )
      : ( is_sel
            ? rect(px, ty, pk_w-1, 30, 0.46, 0.78, 0.88, 1)   
            : rect(px, ty, pk_w-1, 30, 0.8,  0.8,  0.8,  1);
        );
        is_hover = (mx>=px && mx<px+pk_w && my>=ty && my<ty+32);
        (mb && is_hover && (p_mb == 0 || last_preview_note != i_p)) ? ( mem[row_note_base+sel_r]=i_p; preview_note = i_p; preview_chan = mem[row_chan_base+sel_r]; preview_vel = 100; preview_trig = 1; last_preview_note = i_p; );
        i_p+=1;
    );
    mb == 0 ? last_preview_note = -1;

    ty+=38; draw_text(10, ty, "DRUM:", 0.7,0.7,0.7); 

    strlen(row_name_str_base + sel_r * str_size) > 0 ? (
        strcpy(#dn_cur, row_name_str_base + sel_r * str_size);
    ) : (
        get_d_name(mem[row_name_idx+sel_r], #dn_cur); 
    );

    set_ui_color(mem[row_color_base+sel_r]); gfx_x=65; gfx_y=ty; gfx_drawstr(#dn_cur);
    (rmb && mx>=65 && mx<160 && my>=ty && my<ty+20) ? ( sel = gfx_showmenu(#name_menu); sel > 0 ? ( mem[row_name_idx+sel_r] = sel-1; strcpy(row_name_str_base + sel_r, ""); ) );

    dr_p(270, ty, "NOTE:", row_note_base+sel_r, 0, 127, 85);
    dr_p(440, ty, "CHAN:", row_chan_base+sel_r, 1, 16, 75); 
    dr_p(610, ty, "LENG:",  row_len_base+sel_r,  0, 127, 75); 
    dr_p(780, ty, "LEVEL:",row_level_base+sel_r, 0, 100, 85);
    dr_p(980, ty, "HUM:",  row_human_base+sel_r, -1, 100, 75);
    dr_p(1180, ty, "PUSH/PULL:", row_offs_base+sel_r, -50, 60, 125); 
    
    // --- GROOVE DEBUG INDICATOR ---
    gr_max = mem[LOCAL_GROOVE_DB + 32];
    gr_x = 1242; gr_y = ty-118;
    
    gfx_set(0.6, 0.6, 0.6, 1);
    gfx_x = gr_x - 30; gfx_y = gr_y - 4; gfx_drawstr("GRV:");

    gr_max == 0 ? gfx_set(0.3, 0.3, 0.3, 1) : (gr_max > 1.0 ? gfx_set(1, 0, 0, 1) : gfx_set(0, 1, 0, 1));
    gfx_circle(gr_x, gr_y-1, 4, 1);

    ty+=12; s_v=eff_sub(t_e); st_v=eff_bars(t_e)*s_v;
    
    // Calculate Playback Index for Flash Logic
    // Must be done before both loops
    playing_tab = (mem[ui_locked_tab] <= 0) ? mem[ui_play_prog_tab] : mem[ui_locked_tab];
    (play_state & 1 && playing_tab == t_e) ? ( 
        vis_beat = calc_vis_beat(t_e); 
        play_step_idx = floor(vis_beat * (s_v/4)); 
    ) : play_step_idx = -1;

    btn(10, ty+8, 95, " Copy Row") ? ( memcpy(copy_row_v_buf, curr_pat_v_ptr + sel_r*vel_stride_row, MAX_STEPS); memcpy(copy_row_g_buf, curr_pat_g_ptr + sel_r*vel_stride_row, MAX_STEPS); memcpy(copy_row_l_buf, curr_pat_l_ptr + sel_r*vel_stride_row, MAX_STEPS); );
    btn(10, ty+28, 95, " Paste Row") ? ( memcpy(curr_pat_v_ptr + sel_r*vel_stride_row, copy_row_v_buf, MAX_STEPS); memcpy(curr_pat_g_ptr + sel_r*vel_stride_row, copy_row_g_buf, MAX_STEPS); memcpy(curr_pat_l_ptr + sel_r*vel_stride_row, copy_row_l_buf, MAX_STEPS); );
    
    // --- ALL BUTTON ---
    all_mode = mem[ui_vel_edit_all];
    
    // Toggle: Enable/Disable Global Velocity Edit
        btn(115, ty+28, 35, "ALL") ? ( mem[ui_vel_edit_all] = !mem[ui_vel_edit_all]; );
    
    
    // Visual State (Orange when active)
    all_mode ? ( gfx_set(1, 0.8, 0.2, 1); gfx_rect(115, ty+28, 35, 18); gfx_set(0,0,0,1); gfx_x=120; gfx_y=ty+33; gfx_drawstr("ALL"); );
    
    
    btn(10, ty+48, 95, " Clear Row") ? ( memset(curr_pat_g_ptr + sel_r*vel_stride_row, 0, MAX_STEPS); memset(curr_pat_v_ptr + sel_r*vel_stride_row, 0, MAX_STEPS); memset(curr_pat_l_ptr + sel_r*vel_stride_row, 0, MAX_STEPS); );

    gx_s=220; sb_w = 20; gx_w = gfx_w - gx_s - sb_w - 5; cw_v=gx_w/st_v;
    
    // --- NEW "DEF" SLIDER (Left of Grid) ---
    def_w = 28; def_x = gx_s - def_w - 4; def_h = 70;
    
    // Background
    rect(def_x, ty, def_w, def_h, 0.2, 0.2, 0.2, 1);
    
    // Bar (Inactive Intro Color: 0.08, 0.4, 0.4)
    gfx_set(0.08, 0.4, 0.4, 1);
    val_h = floor((slider1 / 127) * (def_h - 2));
    val_h < 2 ? val_h = 2;
    gfx_rect(def_x + 1, ty + def_h - val_h - 1, def_w - 2, val_h);
    
    // Label
    gfx_set(1, 1, 1, 0.8);
    gfx_x = def_x + 3; gfx_y = ty + 5; gfx_drawstr("DEF");
    
    // Number
    sprintf(#dv, "%d", slider1);
    gfx_x = def_x + 3; gfx_y = ty + def_h - 15; gfx_drawstr(#dv);
    
    // Logic
    (mb && mx >= def_x && mx < def_x + def_w && my >= ty && my < ty + def_h && capture_id == 0) ? ( capture_id = 11111; );
    (capture_id == 11111) ? (
        new_val = 127 - floor( ( (my - ty) / def_h ) * 127 );
        new_val = clamp(new_val, 1, 127);
        slider1 = new_val;
        slider_automate(slider1);
        
        i_rst = 0;
        loop(MAX_ROWS * MAX_STEPS,
             mem[curr_pat_g_ptr + i_rst] == 0 ? mem[curr_pat_v_ptr + i_rst] = 0;
             i_rst += 1;
        );
    );
    // ---------------------------------------

    rect(gx_s, ty, gx_w, 70, 0.2, 0.2, 0.2, 1);
    !mb ? vel_drag_mods = 0;

    (rmb && capture_id == 88888) ? (
         
         abs_cell = len_drag_cell_idx;
         row_idx = floor(abs_cell / vel_stride_row);
         row_base = row_idx * vel_stride_row;
         step_idx = abs_cell % vel_stride_row; 

         head_x = gx_s + (step_idx * cw_v);
         dist_pixels = mx - head_x;
         
         raw_l = ceil(dist_pixels / cw_v);
         raw_l < 1 ? raw_l = 1;

         
         drag_mods = 0; ctrl_dn ? drag_mods |= 1; shift_dn ? drag_mods |= 2;

         
         beat_steps = s_v / 4; 
         total_bars = st_v / s_v; 
         step_in_bar = step_idx % s_v;
         step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
         bar_idx = floor(step_idx / s_v);

         
         drag_mods == 0 ? (
             
             local_max = st_v - step_idx;
             final = raw_l > local_max ? local_max : raw_l;
             mem[curr_pat_l_ptr + row_base + step_idx] = final;
         ) : (drag_mods == 1) ? ( 
             
             bb=0; loop(total_bars, 
                 tgt = bb*s_v + step_in_bar; 
                 tgt < st_v ? (
                    local_max = st_v - tgt;
                    final = raw_l > local_max ? local_max : raw_l;
                    mem[curr_pat_l_ptr + row_base + tgt] = final;
                    
                    mem[curr_pat_g_ptr + row_base + tgt] = 1; 
                 );
                 bb+=1; 
             );
         ) : (drag_mods == 2) ? ( 
             
             bt=0; loop(4, 
                 tgt = bar_idx*s_v + bt*beat_steps + step_in_beat;
                 (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? (
                    local_max = st_v - tgt;
                    final = raw_l > local_max ? local_max : raw_l;
                    mem[curr_pat_l_ptr + row_base + tgt] = final;
                    mem[curr_pat_g_ptr + row_base + tgt] = 1;
                 );
                 bt+=1;
             );
         ) : ( 
             
             bb=0; loop(total_bars,
                 bt=0; loop(4,
                     tgt = bb*s_v + bt*beat_steps + step_in_beat;
                     tgt < st_v ? (
                        local_max = st_v - tgt;
                        final = raw_l > local_max ? local_max : raw_l;
                        mem[curr_pat_l_ptr + row_base + tgt] = final;
                        mem[curr_pat_g_ptr + row_base + tgt] = 1;
                     );
                     bt+=1;
                 );
                 bb+=1;
             );
         );
    );

    all_mode = mem[ui_vel_edit_all];
    all_preview_v = clamp(floor((1-(my-ty)/70)*127), 1, 127);

    skip_vel_draw = 0;
    active_note_idx = -1; 


    s_i=0; loop(st_v,
        idx_v = sel_r*vel_stride_row + s_i;
        
        
all_mode = mem[ui_vel_edit_all];

all_mode ? (
    vx_L = gx_s + s_i*cw_v;
    is_col_hover = (mx >= vx_L && mx < vx_L + cw_v);
    is_in_vel_box = (my >= ty && my < ty+70);

    v_store = mem[curr_pat_v_ptr + idx_v];
    def_v = (v_store > 0) ? v_store : slider1;

    v_disp = (mb && capture_id == 77777 && is_col_hover && is_in_vel_box)
             ? all_preview_v
             : def_v;

    bar_h = floor((v_disp/127) * 68); bar_h < 2 ? bar_h = 2;

    rect(vx_L, ty+70-bar_h, cw_v-1, bar_h, 0.3, 0.3, 0.3, 1);
) : (
    // Normal mode (your existing behavior)
    skip_vel_draw > 0 ? ( skip_vel_draw -= 1; ) : (
        g_on = mem[curr_pat_g_ptr+idx_v];
        step_len = mem[curr_pat_l_ptr+idx_v];
        draw_w = cw_v;
        step_len > 1 ? ( draw_w = cw_v * step_len; skip_vel_draw = step_len - 1; );

        v_store = mem[curr_pat_v_ptr+idx_v];
        v_disp = (v_store > 0) ? v_store : slider1;

        bar_h = floor((v_disp/127) * 68); bar_h < 2 ? bar_h = 2;
        c_idx = mem[row_color_base+sel_r]; get_palette_values(c_idx);

        g_on ? (
            min_b = (c_idx == 0) ? 0.60 : 0.50; rng_b = 1.0 - min_b;
            v_scale = min_b + (rng_b * (v_disp / 127));

            (play_step_idx == s_i) ? (
                gfx_set(1, 1, 1, 0.95);
            ) : (
                gfx_set(cr * v_scale, cg * v_scale, cb * v_scale, 1);
            );

            gfx_rect(gx_s+s_i*cw_v, ty+70-bar_h, draw_w-1, bar_h);
        )
        : (
            rect(gx_s+s_i*cw_v, ty+70-bar_h, cw_v-1, bar_h, 0.3, 0.3, 0.3, 1);
        );
    );
);
    
    vx_L = gx_s+s_i*cw_v; vx_R = vx_L+cw_v;
    is_col_hover = (mx >= vx_L && mx < vx_R);
    is_box_hover = (is_col_hover && my >= ty && my < ty+70);
    
    (mb && p_mb == 0 && is_box_hover && capture_id == 0) ? ( capture_id = 77777; );
    
    do_update = 0;
    (capture_id == 77777 && mb && is_col_hover) ? do_update = 1; 
    (capture_id == 0 && mb && is_box_hover) ? do_update = 1;     
    
    do_update ? (
        p_mb == 0 ? ( vel_drag_mods = 0; ctrl_dn ? vel_drag_mods |= 1; shift_dn ? vel_drag_mods |= 2; );
        
        new_v = floor((1-(my-ty)/70)*127); 
        new_v < 1 ? new_v = 1 : new_v > 127 ? new_v = 127;
        
        beat_steps = s_v/4; total_bars = st_v / s_v; step_idx = s_i; 
        step_in_bar = step_idx % s_v; 
        step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
        bar_idx = floor(step_idx / s_v);

        
        
        vel_drag_mods == 0 ? ( 
                    mem[ui_vel_edit_all] ? (
                        // Apply to ALL rows
                        r_it = 0; loop(MAX_ROWS,
                            mem[curr_pat_v_ptr + r_it*vel_stride_row + s_i] = new_v;
                            r_it+=1;
                        );
                    ) : (
                        // Apply to selected row only
                        mem[curr_pat_v_ptr + idx_v] = new_v; 
                    );
                )
        
        
        : (vel_drag_mods == 1) ? ( 
            bb=0; loop(total_bars, 
                tgt = bb*s_v + step_in_bar; 
                tgt < st_v ? ( i2 = sel_r*vel_stride_row + tgt; mem[curr_pat_v_ptr + i2] = new_v; ); 
                bb+=1; 
            ); 
        )
        : (vel_drag_mods == 2) ? ( 
            bt=0; loop(4, 
                tgt = bar_idx*s_v + bt*beat_steps + step_in_beat; 
                (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? ( ii = sel_r*vel_stride_row + tgt; mem[curr_pat_v_ptr+ii] = new_v; ); 
                bt+=1; 
            ); 
        )
        : ( 
            bb=0; loop(total_bars, 
                bt=0; loop(4, 
                    tgt = bb*s_v + bt*beat_steps + step_in_beat; 
                    tgt < st_v ? ( ii = sel_r*vel_stride_row + tgt; mem[curr_pat_v_ptr+ii] = new_v; ); 
                    bt+=1; 
                ); 
                bb+=1; 
            ); 
        ); 
    ); 
    s_i+=1;
);


// --- BAR RULER & CONTEXT MENU ---
    ruler_h = 15; gap_h = 2;
    ruler_y = ty + 72;
    grid_y = ruler_y + ruler_h + gap_h; // Push Main Grid Down
    row_h = grid_height;

    // --- 1/2 Speed Calculation ---
    is_half = eff_half(t_e);
    
    // How many grid steps exist in one logical pattern bar?
    raw_steps_per_bar = st_v / eff_bars(t_e);
    
    // If 1/2 speed, a visual bar is only HALF those steps (music is slower)
    vis_steps_per_bar = is_half ? (raw_steps_per_bar / 2) : raw_steps_per_bar;
    
    // Calculate pixel width of one visual bar
    vis_bar_w = cw_v * vis_steps_per_bar;
    
    // If 1/2 speed, we show double the amount of bars (1 Bar Pattern = 2 Bars Time)
    bar_count = eff_bars(t_e) * (is_half ? 2 : 1);
    
    b_idx = 0;
    loop(bar_count,
        bx = gx_s + b_idx * vis_bar_w;
        
        // Draw Ruler Background
        rect(bx, ruler_y, vis_bar_w-1, ruler_h, 0.5, 0.5, 0.5, 1);
        sprintf(#bnum, "%d", b_idx + 1);
        draw_text(bx + 1, ruler_y + 2, #bnum, 1.0, 1.0, 1.0);
        
        // Interaction: Left Click for Context Menu
        (mb && p_mb == 0 && mx >= bx && mx < bx + vis_bar_w && my >= ruler_y && my < ruler_y + ruler_h) ? (
            gfx_x = mx; gfx_y = my;
            sel_menu = gfx_showmenu("Copy Bar|Paste Bar|Clear Bar");
            
            op_len = vis_steps_per_bar;
            op_start = b_idx * op_len;
            
            // 1. Copy Bar to Buffer
            sel_menu == 1 ? ( 
                r_it = 0; loop(MAX_ROWS,
                    src_offset = r_it * vel_stride_row + op_start;
                    dst_offset = r_it * 96; // Buffer Stride (Max 32 steps * 3 layers)
                    memcpy(bar_copy_base + dst_offset, curr_pat_v_ptr + src_offset, op_len);
                    memcpy(bar_copy_base + dst_offset + 32, curr_pat_g_ptr + src_offset, op_len);
                    memcpy(bar_copy_base + dst_offset + 64, curr_pat_l_ptr + src_offset, op_len);
                    r_it += 1;
                );
            );
            
            // 2. Paste Bar from Buffer
            sel_menu == 2 ? ( 
                r_it = 0; loop(MAX_ROWS,
                    src_offset = r_it * 96;
                    dst_offset = r_it * vel_stride_row + op_start;
                    memcpy(curr_pat_v_ptr + dst_offset, bar_copy_base + src_offset, op_len);
                    memcpy(curr_pat_g_ptr + dst_offset, bar_copy_base + src_offset + 32, op_len);
                    memcpy(curr_pat_l_ptr + dst_offset, bar_copy_base + src_offset + 64, op_len);
                    r_it += 1;
                );
            );
            
            // 3. Clear Bar
            sel_menu == 3 ? ( 
                r_it = 0; loop(MAX_ROWS,
                    dst_offset = r_it * vel_stride_row + op_start;
                    memset(curr_pat_v_ptr + dst_offset, 0, op_len);
                    memset(curr_pat_g_ptr + dst_offset, 0, op_len);
                    memset(curr_pat_l_ptr + dst_offset, 0, op_len);
                    r_it += 1;
                );
            );
        );
        b_idx += 1;
    );

    !mb ? ( last_drag_idx = -1; drag_mods = 0; vel_drag_mods = 0; drag_mode = 0; row_drag_active = 0; row_drag_last_y = 0; row_drag_anchor = -1; );




    scroll_val = slider8; visible_rows = slider7; max_scroll = MAX_ROWS - visible_rows; max_scroll < 0 ? max_scroll = 0;
    scroll_val > max_scroll ? (scroll_val = max_scroll; slider8 = max_scroll;);
    sb_w = 20; sb_x = gfx_w - sb_w - 2; sb_y = grid_y; sb_h = visible_rows * row_h;
    handle_h_pct = visible_rows / MAX_ROWS; handle_h = sb_h * handle_h_pct; handle_h < 15 ? handle_h = 15;
    available_track = sb_h - handle_h; available_track < 1 ? available_track = 1; 
    scroll_pct = (max_scroll > 0) ? (scroll_val / max_scroll) : 0; handle_y = sb_y + (scroll_pct * available_track);
    is_sb_hover = (mx >= sb_x && mx < sb_x + sb_w && my >= sb_y && my < sb_y + sb_h); is_sb_drag = (capture_id == 9999);
    (mb && p_mb == 0 && is_sb_hover) ? ( capture_id = 9999; scrollbar_drag_y_offset = my - handle_y; );
    (mb && capture_id == 9999) ? ( target_y = my - scrollbar_drag_y_offset; rel_y = target_y - sb_y; new_pct = rel_y / available_track; new_val = floor(new_pct * max_scroll + 0.5); new_val = clamp(new_val, 0, max_scroll); slider8 = new_val; );
    scroll_offset = slider8;

    row_drag_active = row_drag_active; row_drag_last_y = row_drag_last_y; row_drag_anchor = row_drag_anchor;
    row_drag_x0 = 60; row_drag_x1 = gx_s - 5;      

    gfx_set(0,0,0,1); gfx_rect(0, grid_y, gfx_w, gfx_h - grid_y);
    r_v = 0; loop(visible_rows,
        r_g = r_v + scroll_offset; ry = grid_y + r_v*row_h;
        r_g==sel_r ? rect(10, ry, gx_w+gx_s-10, row_h-1, 0.12, 0.12, 0.12, 1) : rect(10, ry, gx_w+gx_s-10, row_h-1, 0, 0, 0, 1);
        mem[row_mute_base+r_g]?draw_text(15,ry+3,"M",1,0,0):draw_text(15,ry+3,"M",0.4,0.4,0.4);
        mem[row_solo_base+r_g]?draw_text(32,ry+3,"S",0,1,1):draw_text(32,ry+3,"S",0.4,0.4,0.4);
        STRING_SLOT_ID = row_name_str_base + r_g; 
        strlen(STRING_SLOT_ID) > 0 ? ( strcpy(#gn_row, STRING_SLOT_ID); ) : ( get_d_name(mem[row_name_idx+r_g], #gn_row); );
        set_ui_color(mem[row_color_base+r_g]); gfx_x=53; gfx_y=ry+6; gfx_circle(gfx_x, gfx_y, 4, 1); gfx_x=65; gfx_y=ry+3; gfx_drawstr(#gn_row);
        (mb && p_mb==0 && mx>=65 && mx<165 && my>=ry+3 && my<ry+18) ? ( preview_note = mem[row_note_base+r_g]; preview_chan = mem[row_chan_base+r_g]; preview_vel = 100; preview_trig = 1; mem[ui_selected_row] = r_g; mem[ui_vel_edit_all] = 0; ); 
        (mb && p_mb==0 && mx>=48 && mx<58 && my>=ry+1 && my<ry+11) ? ( color_popup_active = 1; color_popup_x = mx; color_popup_y = my; color_popup_row = r_g; );
        (rmb && mx>=60 && mx<gx_s && my>=ry && my<ry+row_h) ? ( c_sel = gfx_showmenu(#name_menu); c_sel > 0 ? ( mem[row_name_idx+r_g] = c_sel-1; strcpy(STRING_SLOT_ID, ""); ); );
        
(mb && p_mb == 0 && capture_id == 0 && !color_popup_active && mx<gx_s && my>=ry && my<ry+row_h && !rmb && !(mx>=48 && mx<58) && !(mx>=65 && mx<165)) ? ( 
            mx<28 ? mem[row_mute_base+r_g] = !mem[row_mute_base+r_g] : 
            mx<45 ? mem[row_solo_base+r_g] = !mem[row_solo_base+r_g] : 
            ( 
                mem[ui_selected_row] = r_g; 
                mem[ui_vel_edit_all] = 0; // <--- FORCE OFF
            ); 
        );
        
        
        (mb && p_mb==0 && !ui_lock && mx>=row_drag_x0 && mx<row_drag_x1 && my>=ry && my<ry+row_h && !rmb && (mouse_cap & 16)) ? ( row_drag_active = 1; row_drag_last_y = my; row_drag_anchor = r_g; capture_id = 42424; );
        (mb && capture_id == 42424 && row_drag_active) ? ( dy = my - row_drag_last_y; abs(dy) >= (row_h*0.5) ? ( dir = dy > 0 ? 1 : -1; tgt = row_drag_anchor + dir; (tgt >= 0 && tgt < MAX_ROWS) ? ( swap_rows(row_drag_anchor, tgt); row_drag_anchor = tgt; row_drag_last_y = my; ) : ( row_drag_last_y = my; ); ); );

        get_palette_values(mem[row_color_base+r_g]); memset(ownership_map, -1, MAX_STEPS); 
        s_i = 0; loop(st_v, idx_v = r_g*vel_stride_row + s_i; mem[curr_pat_g_ptr+idx_v] ? ( l = mem[curr_pat_l_ptr+idx_v]; l < 1 ? l = 1; k = 0; loop(l, (s_i + k < st_v) ? ( mem[ownership_map + s_i + k] = idx_v; ); k+=1; ); ); s_i+=1; );



        s_i=0; loop(st_v,
            idx_v = r_g*vel_stride_row + s_i; cx_g = gx_s + s_i*cw_v; owner_idx = mem[ownership_map + s_i];
            is_head = (owner_idx == idx_v); is_tail = (owner_idx != -1 && owner_idx != idx_v); is_empty = (owner_idx == -1); 
            
            is_head ? (
                step_len = mem[curr_pat_l_ptr+idx_v]; draw_w = cw_v; step_len > 1 ? ( draw_w = cw_v * step_len; );
                v_store = mem[curr_pat_v_ptr+idx_v]; v_disp = (v_store>0?v_store:slider1);
                
                c_idx = mem[row_color_base+r_g];
                get_palette_values(c_idx); 

                
                
                min_b = (c_idx == 0) ? 0.60 : 0.50;
                rng_b = 1.0 - min_b;

                v_scale = min_b + (rng_b * (v_disp / 127)); 
                
                // FLASH LOGIC FOR BOTTOM GRID (v4.9.1)
                (play_step_idx == s_i) ? (
                    gfx_set(1, 1, 1, 0.95); 
                ) : (
                    gfx_set(cr*v_scale, cg*v_scale, cb*v_scale, 1); 
                );
                
                gfx_rect(cx_g, ry+1, draw_w-1, row_h-3);
                
                
            ) : is_empty ? (
                q_div = s_v/4; e_div = s_v/8;
                one_brite = .5;
                (s_i % s_v == 0) ? rect(cx_g, ry+1, cw_v-1, row_h-3, 0.20*one_brite, 1*one_brite, 1*one_brite, .8)
                : (s_i % q_div == 0) ? rect(cx_g, ry+1, cw_v-1, row_h-3, 0.30, 0.30, 0.30, 1) 
                : (s_v == 32 && (s_i % e_div == 0)) ? rect(cx_g, ry+1, cw_v-1, row_h-3, .08, .08, .08, 1) 
                : rect(cx_g, ry+1, cw_v-1, row_h-3, 0.15, 0.15, 0.15, 1);
            );

            
            (mb && mx>=cx_g && mx<cx_g+cw_v && my>=ry && my<ry+row_h && capture_id == 0) ? (
                        
                        drag_lock_row == -1 ? drag_lock_row = r_g;
            
                        
                        // Grid painting is ALWAYS single row, regardless of ALL button
                                                (r_g == drag_lock_row && !is_tail) ? (
                            cell_id = r_g*1000 + s_i;
                            p_mb == 0 ? ( drag_mode = mem[curr_pat_g_ptr+idx_v] ? 2 : 1; drag_mods = 0; ctrl_dn ? drag_mods |= 1; shift_dn ? drag_mods |= 2; );
                            (cell_id != last_drag_idx) ? (
                                beat_steps = s_v/4; total_bars = st_v / s_v; step_idx = s_i; step_in_bar = step_idx % s_v; step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; bar_idx = floor(step_idx / s_v);
                                
                                
drag_mods == 0 ? ( 
                                    drag_mode == 1 ? ( 
                                        mem[curr_pat_g_ptr+idx_v] = 1; 
                                        mem[curr_pat_l_ptr+idx_v] = 0; // Reset Length
                                        mem[curr_pat_v_ptr+idx_v] <= 0 ? mem[curr_pat_v_ptr+idx_v] = slider1; 
                                    ) : ( 
                                        mem[curr_pat_g_ptr+idx_v] = 0; 
                                        mem[curr_pat_v_ptr+idx_v] = 0; 
                                        mem[curr_pat_l_ptr+idx_v] = 0; 
                                    ); 
                                )
                                
                                
                                                    : (drag_mods == 1) ? ( bb=0; loop(total_bars, tgt = bb*s_v + step_in_bar; tgt < st_v ? ( ii = r_g*vel_stride_row + tgt; drag_mode == 1 ? ( mem[curr_pat_g_ptr+ii] = 1; mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; ) : ( mem[curr_pat_g_ptr+ii] = 0; mem[curr_pat_v_ptr+ii] = 0; mem[curr_pat_l_ptr+ii] = 0; ); ); bb+=1; ); )
                                                    : (drag_mods == 2) ? ( bt=0; loop(4, tgt = bar_idx*s_v + bt*beat_steps + step_in_beat; (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? ( ii = r_g*vel_stride_row + tgt; drag_mode == 1 ? ( mem[curr_pat_g_ptr+ii] = 1; mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; ) : ( mem[curr_pat_g_ptr+ii] = 0; mem[curr_pat_v_ptr+ii] = 0; mem[curr_pat_l_ptr+ii] = 0; ); ); bt+=1; ); )
                                                    : ( bb=0; loop(total_bars, bt=0; loop(4, tgt = bb*s_v + bt*beat_steps + step_in_beat; tgt < st_v ? ( ii = r_g*vel_stride_row + tgt; drag_mode == 1 ? ( mem[curr_pat_g_ptr+ii] = 1; mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; ) : ( mem[curr_pat_g_ptr+ii] = 0; mem[curr_pat_v_ptr+ii] = 0; mem[curr_pat_l_ptr+ii] = 0; ); ); bt+=1; ); bb+=1; ); );
                                mem[ui_selected_row] = r_g; last_drag_idx = cell_id;
                            );
                        );
                    );
            (rmb && mx>=cx_g && mx<cx_g+cw_v && my>=ry && my<ry+row_h && capture_id == 0) ? (
                target_head = -1; owner_idx != -1 ? ( target_head = owner_idx; is_clicked_head = (mem[curr_pat_g_ptr + idx_v] != 0); is_clicked_head && !ctrl_dn ? ( under = find_covering_head(r_g, s_i, st_v); under != -1 ? target_head = under; ); ) : ( target_head = idx_v; mem[curr_pat_g_ptr + target_head] = 1; mem[curr_pat_v_ptr + target_head] <= 0 ? mem[curr_pat_v_ptr + target_head] = slider1; mem[curr_pat_l_ptr + target_head] = 1; );
                capture_id = 88888; len_drag_active = 1; len_drag_cell_idx = target_head; head_pos = target_head % st_v; len_drag_max = st_v - head_pos;
            );
            s_i+=1;
        );

        r_v+=1;
    );
    // ===============================================
    // PASTE THIS HERE (After the loop finishes)
    // ===============================================
    
    // --- DRAW SCROLLBAR ---
    // 1. Draw Track (Background)
    gfx_set(0.15, 0.15, 0.15, 1);
    gfx_rect(sb_x, sb_y, sb_w, sb_h);
    
    // 2. Draw Handle
    // Highlight if dragging or hovering
    is_sb_drag || is_sb_hover ? gfx_set(0.6, 0.6, 0.6, 1) : gfx_set(0.35, 0.35, 0.35, 1);
    
    // Ensure handle has minimum size and fits strictly within track
    draw_h = handle_h; draw_y = handle_y;
    draw_y < sb_y ? draw_y = sb_y; 
    draw_y + draw_h > sb_y + sb_h ? draw_y = sb_y + sb_h - draw_h;
    
    gfx_rect(sb_x + 2, draw_y, sb_w - 4, draw_h);
    

    playing ? (
        t_n = mem[ui_locked_tab] == 0 ? mem[ui_play_prog_tab] : (mem[ui_locked_tab] > 0 ? mem[ui_locked_tab] : mem[ui_play_prog_tab]);
        t_n == t_e ? (
            vis_beat = calc_vis_beat(t_n);
            p_l = eff_bars(t_n) * 4;
            phx = gx_s + (vis_beat/p_l)*gx_w;
            rect(phx-1, grid_y, 3, slider7*row_h, 0, 1, 0, 0.4);
        );
    );

    color_popup_active && color_popup_row >= 0 ? draw_color_popup(color_popup_x, color_popup_y);
    is_over_grid = (my > grid_y);
    mouse_wheel != 0 && is_over_grid && !shift_dn && !ctrl_dn && !alt_dn && capture_id != 88888 ? (
        scroll_amt = (mouse_wheel > 0) ? -1 : 1;
        new_scroll = slider8 + scroll_amt;
        max_scroll = MAX_ROWS - slider7; max_scroll < 0 ? max_scroll = 0;
        new_scroll = clamp(new_scroll, 0, max_scroll);
        slider8 = new_scroll;
        mouse_wheel = 0;
    );
); 

help_active ? (
    
    gfx_set(0,0,0,0.85);
    gfx_rect(0,0,gfx_w,gfx_h);

    
    hw = 550; hh = 520; 
    hx = (gfx_w-hw)/2; 
    hy = (gfx_h-hh)/2;
    
    
    rect(hx, hy, hw, hh, 0.2, 0.2, 0.2, 1);
    
    
    gfx_set(1,1,1,1);

    
    gfx_x = hx+20; gfx_y = hy+20;
    gfx_drawstr("SCOPE OF SETTINGS:");
    
    gfx_x = hx+20; gfx_y += 20;
    gfx_drawstr(" - GLOBAL SETTINGS: Affect all Patterns (Tabs)");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - PATTERN SETTINGS: Affect only the viewed Pattern");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - ROW SETTINGS: Affect only the selected Row");
    
    
    gfx_y += 25; 
    gfx_x = hx+20; 
    gfx_drawstr("TAB & VIEW FUNCTIONS:");
    
    gfx_x = hx+20; gfx_y += 20;
    gfx_drawstr(" - Select Tab: Views the Tab's Pattern");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - Tab's Lock Box: Green - Playback is locked to the Tab");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - Tab's Lock Box: Black - Playback is not locked to the Tab");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - Double-Click Tab: View Pattern AND Lock tab to playback");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - Follow [x]: View and playback follow incoming MIDI commands");
    
    
    gfx_y += 25; 
    gfx_x = hx+20;
    gfx_drawstr("GRID EDITING:");
    
    gfx_x = hx+20; gfx_y += 20;
    gfx_drawstr(" - Click+Drag: Paint steps and velocity bars");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - CTRL+Drag: Edit all pattern Bars simultaneously");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - SHIFT+Drag: Edit all pattern Beats simultaneously");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - Right-Click Drag: Set Note Durations (create long notes)");

    
    gfx_y += 25; 
    gfx_x = hx+20;
    gfx_drawstr("ROW OPERATIONS:");
    
    gfx_x = hx+20; gfx_y += 20;
    gfx_drawstr(" - ALT+Drag Name: Move/Swap Rows");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - Click Color Dot: Change Row Color");
    
    
    gfx_y += 25; 
    gfx_x = hx+20;
    gfx_drawstr("SETTINGS:");
    
    gfx_x = hx+20; gfx_y += 20;
    gfx_drawstr(" - HUM: -1 follows Global Slider");
     
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - Swing P: Uses Project Swing (Numbers2Notes)");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - [1x | 1/2]: Playback speed for 24/32 SubDivs");
    
    gfx_x = hx+20; gfx_y += 16;
    gfx_drawstr(" - PUSH/PULL: Adjust timing per row (+ = Lag, - = Push)");

    
    ok_w = 60; ok_h = 25; 
    ok_x = hx + hw - ok_w - 20; 
    ok_y = hy + hh - ok_h - 20;
    
    rect(ok_x, ok_y, ok_w, ok_h, 0.4, 0.4, 0.4, 1);
    gfx_set(1,1,1,1);
    gfx_x = ok_x + 18; 
    gfx_y = ok_y + 5; 
    gfx_drawstr("OK");
    
    
    mb ? (
        (mx>=ok_x && mx<ok_x+ok_w && my>=ok_y && my<ok_y+ok_h) ? (
            help_active = 0;
            capture_id = 90000; 
        ) : (
            capture_id = 90000; 
        );
    );
);
