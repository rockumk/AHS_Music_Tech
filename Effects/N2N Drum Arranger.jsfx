desc:N2N Drum Arranger
version: 5.8.7
author: Rock Kennedy
about:
  # N2N Drum Arranger v5.8.7
  - FIXED: Pattern Settings (Bars, Subdiv, Swing) now load correctly from Legacy presets.
  - TECHNICAL: Corrected legacy memory read from Interleaved (Wrong) to Sequential Arrays (Right).
  - MAPPING: Uses the user-verified mapping table for both Grid Data and Pattern Settings.
  - INSTANCE ID: Locked to prevent changes via presets.
provides:
  [data] ../Data/DrumArranger/*.txt > AHS_Music_Tech/DrumArranger/
options:maxmem=32000000
options:gmem=N2N_Ecosystem_RSKennedy

slider10:/AHS_Music_Tech/DrumArranger:*:File Selection - Drumkits and Pattern(s)
slider1:100<1,127,1>-Default Row Velocity
slider2:0<0,25,1>-Global Humanize
slider3:2<0,4,1{8,12,16,24,32}>-Global Subdiv
slider4:4<1,4,1>-Global Bars
slider5:1<1,512,1>-Instance ID
slider6:0<0,100,1>-Global Swing
slider7:20<1,128,1>-Visible Rows
slider8:0<0,128,1>-View Scroll
slider9:0<0,1,1{P, M}>-Swing Source (Default=P)
slider11:14<10,30,1>-Grid Row Height

@init
version_display = "v5.8.7";

// =========================================================
// REGISTRATION & GROOVE MEMORY
// =========================================================
reg_base = 8000000;
parse_scratch = 500000; 
LOCAL_GROOVE_DB = 550000; 
GMEM_GROOVE_OFFSET = 5000000;
inv_map_base = 6000000;

// --- CUE STATE MACHINE VARIABLES ---
cue_armed = 0; cue_target_tab = -1; cue_source_type = -1; cue_source_addr = -1;    
cue_clear_mode = 0; cue_clear_addr = -1; cue_clear_pending = 0;   
midi_note_cue_pending = 0; midi_note_cue_val = 0;      
pc_cue_pending = 0; pc_cue_val = 0;
last_bar_checked = -1; midi_cue_tab = -1; midi_cue_source = -1;    
gmem_queued_tab = -1; gmem_cue_armed = 0; pos_in_bar = 0; beats_to_bar = 0;

GMEM_INV_BASE = 7500000; LOC_TAB_POPULATED = 60000;
GMEM_MODE_BASE = 7100000; GMEM_GLOBAL_ADDR = 7100200;
GMEM_TYPE_BASE = 7100300; GMEM_INST_BASE = 7100500;
GMEM_TYPE_REPORT = 8100000; MY_TYPE_ID = 1;
gmem_cue_active = 0; last_beat_chk = 0; 

my_key == 0 ? (
    seed = floor(time_precise() * 100000) + floor(rand(100000));
    loop(seed % 10, rand(100)); 
    my_key = floor(rand(9000000)) + 1; 
);

reg_done = 0; curr_id = slider5;
// Safety loop to find a slot or claim the current one
while (reg_done == 0 && curr_id <= 512) (
    slot_val = gmem[reg_base + curr_id];
    (slot_val == 0 || slot_val == my_key) ? (
        gmem[reg_base + curr_id] = my_key;
        slider5 = curr_id;
        reg_done = 1;
    ) : (
        curr_id += 1;
    );
);
slider5 > 512 ? slider5 = 512;
my_slot = slider5; // STORE THE ASSIGNED SLOT

// =========================================================
// MEMORY MANAGEMENT
// =========================================================
row_name_str_base = 0;   
STR_BUF_LINE = 650; STR_BUF_NAME = 651; STR_BUF_COLOR = 652; STR_BUF_SWAP = 653; STR_BUF_MENU = 654;
N2N_DIR_BUF = 1005; N2N_FILENAME = 1006; N2N_TEMP_LINE = 1007; N2N_NAME_BUF = 1008;  
N2N_GRID_HEX = 1009; N2N_VEL_HEX = 1010; N2N_LEN_HEX = 1011;
str_size = 1;
last_load_handle = 0; last_load_lines = 0; last_load_rows = 0;
ext_noinit = 1.0; grid_height = slider11; swing_sync = 1;
last_kit_idx = slider10; last_maint_time = 0;
save_msg_timer = 0; drag_accum_gen = 0; help_active = 0;    
cp_valid = 0; cp_bars = 0; cp_sub = 0; cp_hum = 0; cp_sw = 0; cp_half = 0;

// --- CONFIGURATION EXPANSION ---
MAX_TABS = 28; 
TOTAL_TABS = 80; 
MAX_ROWS = 128; MAX_STEPS = 128;

NEW_MAGIC_VER = 27030;
LEGACY_MAGIC_VER = 27022; // v5.6.0 identifier

ver_chk = 700;

// --- RELOCATE NEW MEMORY TO 10,000,000 ---
// Leaves 0 - 7,000,000 free for legacy load
mem_pos = 10000000;

ui_base = mem_pos; mem_pos += 32;
ui_edit_tab = ui_base+0; ui_selected_row = ui_base+1; ui_locked_tab = ui_base+2; ui_play_prog_tab = ui_base+3; ui_play_offset = ui_base+4; ui_anchor_valid = ui_base+5; ui_last_step = ui_base+6;

// Memory Pointers (80 Tabs)
tab_w_base = mem_pos; mem_pos += TOTAL_TABS;
tab_ui_row_base = mem_pos; mem_pos += TOTAL_TABS; 
tab_col_r = mem_pos; mem_pos += TOTAL_TABS;
tab_col_g = mem_pos; mem_pos += TOTAL_TABS;
tab_col_b = mem_pos; mem_pos += TOTAL_TABS;

row_mute_base = mem_pos; mem_pos += MAX_ROWS;
row_solo_base = mem_pos; mem_pos += MAX_ROWS;
row_note_base = mem_pos; mem_pos += MAX_ROWS;
row_chan_base = mem_pos; mem_pos += MAX_ROWS;
row_level_base = mem_pos; mem_pos += MAX_ROWS;
row_human_base = mem_pos; mem_pos += MAX_ROWS;
row_len_base = mem_pos; mem_pos += MAX_ROWS;
row_name_idx = mem_pos; mem_pos += MAX_ROWS;
row_offs_base = mem_pos; mem_pos += MAX_ROWS;
row_color_base = mem_pos; mem_pos += MAX_ROWS;

bars_ov_base = mem_pos; mem_pos += TOTAL_TABS;
subdiv_ov_base = mem_pos; mem_pos += TOTAL_TABS;
hum_ov_base = mem_pos; mem_pos += TOTAL_TABS;
swing_ov_base = mem_pos; mem_pos += TOTAL_TABS;
half_speed_ov_base = mem_pos; mem_pos += TOTAL_TABS; 

requested_start_bar = 1; 

vel_stride_tab = MAX_ROWS * MAX_STEPS; vel_stride_row = MAX_STEPS;

// Contiguous Memory for all 80 tabs
vel_base = mem_pos; mem_pos += TOTAL_TABS * vel_stride_tab;
grid_base = mem_pos; mem_pos += TOTAL_TABS * vel_stride_tab;
step_len_base = mem_pos; mem_pos += TOTAL_TABS * vel_stride_tab;

copy_row_v_buf = mem_pos; mem_pos += MAX_STEPS; 
copy_row_g_buf = mem_pos; mem_pos += MAX_STEPS; 
copy_row_l_buf = mem_pos; mem_pos += MAX_STEPS;
copy_tab_v_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS; 
copy_tab_g_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS; 
copy_tab_l_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS;

mem_pos += 50000;
ownership_map = mem_pos; mem_pos += MAX_STEPS;
kill_note = mem_pos; mem_pos += 128; 
kill_chan = mem_pos; mem_pos += 128;

bar_copy_base = 1500000; // Safe temp buffer

// EXT pointers nulled
ext_tab_w_base = 0; ext_bars_ov_base = 0; ext_subdiv_ov_base = 0; 
ext_hum_ov_base = 0; ext_swing_ov_base = 0; ext_half_speed_ov_base = 0;
ext_vel_base = 0; ext_grid_base = 0; ext_step_len_base = 0;

kit_tmp_base = mem_pos; mem_pos += MAX_ROWS * 7; 
state_len = mem_pos; 
row_flash_base = mem_pos; mem_pos += MAX_ROWS;

// --- LEGACY MAP (Original v5.6 Addresses) ---
OLD_UI_BASE = 701;
OLD_TAB_W = 733;
OLD_TAB_UI = OLD_TAB_W + 64;
OLD_TAB_R = OLD_TAB_UI + 64;
OLD_TAB_G = OLD_TAB_R + 64;
OLD_TAB_B = OLD_TAB_G + 64;
OLD_ROW_START = OLD_TAB_B + 64;
// 1280 = 10 attributes * 128 rows. 
// OLD_OV_START = OLD_ROW_START + 1280 = 1053 + 1280 = 2333
OLD_OV_START = 2333; 
OLD_GRID_START = 2000000;

// --- INVENTORY MAP INITIALIZATION ---
i = 0; loop(128, mem[inv_map_base+i] = -1; i+=1; );
mem[inv_map_base + 0] = 0; // Off
// Intro A-D
i=0; loop(4, mem[inv_map_base + 1+i] = 11+i; i+=1; ); 
// Verse 1 A-D
i=0; loop(4, mem[inv_map_base + 5+i] = 36+i; i+=1; ); 
// Pre 1 A-D
i=0; loop(4, mem[inv_map_base + 9+i] = 48+i; i+=1; ); 
// Chorus 1 A-D
i=0; loop(4, mem[inv_map_base + 13+i] = 60+i; i+=1; ); 
// Bridge A-D
i=0; loop(4, mem[inv_map_base + 17+i] = 72+i; i+=1; ); 
// H1, H2
i=0; loop(2, mem[inv_map_base + 21+i] = 20+i; i+=1; ); 
// Fills 1<, 1=, 1>
i=0; loop(3, mem[inv_map_base + 23+i] = 26+i; i+=1; ); 
// Def
mem[inv_map_base + 26] = 25; 
// 1,2,3,4,5
i=0; loop(5, mem[inv_map_base + 27+i] = 27+i; i+=1; );
// Verse 2
i=0; loop(4, mem[inv_map_base + 32+i] = 40+i; i+=1; );
// Pre 2
i=0; loop(4, mem[inv_map_base + 36+i] = 52+i; i+=1; );
// Chorus 2
i=0; loop(4, mem[inv_map_base + 40+i] = 64+i; i+=1; );
// Solo
i=0; loop(4, mem[inv_map_base + 44+i] = 76+i; i+=1; );
// H3, H4
i=0; loop(2, mem[inv_map_base + 48+i] = 22+i; i+=1; );
// Fills 2<, 2=, 2>
i=0; loop(3, mem[inv_map_base + 50+i] = 29+i; i+=1; );
// Min 6-10
mem[inv_map_base + 53] = 19;
i=0; loop(5, mem[inv_map_base + 54+i] = 54+i; i+=1; );
// Verse 3
i=0; loop(4, mem[inv_map_base + 59+i] = 44+i; i+=1; );
// Pre 3
i=0; loop(4, mem[inv_map_base + 63+i] = 56+i; i+=1; );
// Chorus 3
i=0; loop(4, mem[inv_map_base + 67+i] = 68+i; i+=1; );
// Outro
i=0; loop(4, mem[inv_map_base + 71+i] = 80+i; i+=1; );
// RSV
i=0; loop(5, mem[inv_map_base + 75+i] = 84+i; i+=1; );

// =========================================================
// TAB CONFIGURATION DASHBOARD
// =========================================================
function t(id, r_ui, name, w, cr, cg, cb) (
  mem[tab_ui_row_base + id] = r_ui;
  mem[tab_w_base + id] = w;
  mem[tab_col_r + id] = cr;
  mem[tab_col_g + id] = cg;
  mem[tab_col_b + id] = cb;
);

ttabw = 45; hw = ttabw; sectw = ttabw * 2; ftabs = 60;

t(0,   1,   "Off",       ftabs,    0.5,  0.5,  0.5);
t(1,   1,   "Intro",    hw *2,    0.2,  1.0,  1.0);
t(2,   1,   "B",        hw,    0.2,  1.0,  1.0);
t(3,   1,   "C",        hw,    0.2,  1.0,  1.0);
t(4,   1,   "D",        hw,    0.2,  1.0,  1.0);
t(5,   1,   "Verse 1",  sectw,    0.5,  0.7,  1.0);
t(6,   1,   "B",        ttabw,    0.5,  0.7,  1.0);
t(7,   1,   "C",        ttabw,    0.5,  0.7,  1.0);
t(8,   1,   "D",        ttabw,    0.5,  0.7,  1.0);
t(9,   1,   "Pre 1",    sectw,    0.8,  0.5,  1.0);
t(10,  1,   "B",        ttabw,    0.8,  0.5,  1.0);
t(11,  1,   "C",        ttabw,    0.8,  0.5,  1.0);
t(12,  1,   "D",        ttabw,    0.8,  0.5,  1.0);
t(13,  1,   "Chorus 1", sectw,    1.0,  0.4,  0.4);
t(14,  1,   "B",        ttabw,    1.0,  0.4,  0.4);
t(15,  1,   "C",        ttabw,    1.0,  0.4,  0.4);
t(16,  1,   "D",        ttabw,    1.0,  0.4,  0.4);
t(17,  1,   "Bridge",   sectw,    1.0,  0.9,  0.2);
t(18,  1,   "B",        ttabw,    1.0,  0.9,  0.2);
t(19,  1,   "C",        ttabw,    1.0,  0.9,  0.2);
t(20,  1,   "D",        ttabw,    1.0,  0.9,  0.2);
t(21,  1,   "H1",      hw,       0.8,  0.8,  0.8);
t(22,  1,   "H2",      hw,       0.8,  0.8,  0.8);
t(23,  1,   "1<",       hw,       0.8,  0.5,  1.0);
t(24,  1,   "1=",       hw,       0.8,  0.5,  1.0);
t(25,  1,   "1>",       hw,       0.8,  0.5,  1.0);

t(26,  2,   "Def",       ftabs,    0.7,  0.7,  0.9);
t(27,  2,   "1",        hw,    0.8,  0.8,  0.8);
t(28,  2,   "2",        hw,    0.8,  0.8,  0.8);
t(29,  2,   "3",        hw,    0.8,  0.8,  0.8);
t(30,  2,   "4",        hw,    0.8,  0.8,  0.8);
t(31,  2,   "5",        hw,    0.8,  0.8,  0.8);
t(32,  2,   "Verse 2",    sectw,   0.5,  0.7,  1.0);
t(33,  2,   "B",          ttabw,   0.5,  0.7,  1.0);
t(34,  2,   "C",          ttabw,   0.5,  0.7,  1.0);
t(35,  2,   "D",          ttabw,   0.5,  0.7,  1.0);
t(36,  2,   "Pre 2",      sectw,   0.8,  0.5,  1.0);
t(37,  2,   "B",          ttabw,   0.8,  0.5,  1.0);
t(38,  2,   "C",          ttabw,   0.8,  0.5,  1.0);
t(39,  2,   "D",          ttabw,   0.8,  0.5,  1.0);
t(40,  2,   "Chorus 2",   sectw,   1.0,  0.4,  0.4);
t(41,  2,   "B",          ttabw,   1.0,  0.4,  0.4);
t(42,  2,   "C",          ttabw,   1.0,  0.4,  0.4);
t(43,  2,   "D",          ttabw,   1.0,  0.4,  0.4);
t(44,  2,   "Solo",       sectw,   1,  0.6,  0.3);
t(45,  2,   "B",          ttabw,   1,  0.6,  0.3);
t(46,  2,   "C",          ttabw,   1,  0.6,  0.3);
t(47,  2,   "D",          ttabw,   1,  0.6,  0.3);
t(48,  2,   "H3",    hw,    0.8,  0.8,  0.8);
t(49,  2,   "H4",    hw,    0.8,  0.8,  0.8);
t(50,  2,   "2<",   hw,     0.9,  0.4,  1);
t(51,  2,   "2=",   hw,     0.9,  0.4,  1);
t(52,  2,   "2>",   hw,     0.9,  0.4,  1);

t(53,  3,   "Min",       ftabs,    0.9,  0.7,  0.7);
t(54,  3,   "6",   hw,    0.8,  0.8,  0.8);
t(55,  3,   "7",   hw,    0.8,  0.8,  0.8);
t(56,  3,   "8",   hw,    0.8,  0.8,  0.8);
t(57,  3,   "9",   hw,    0.8,  0.8,  0.8);
t(58,  3,   "10",  hw,    0.8,  0.8,  0.8);
t(59,  3,   "Verse 3",    sectw,   0.5,  0.7,  1.0);
t(60,  3,   "B",          ttabw,   0.5,  0.7,  1.0);
t(61,  3,   "C",          ttabw,   0.5,  0.7,  1.0);
t(62,  3,   "D",          ttabw,   0.5,  0.7,  1.0);
t(63,  3,   "Pre 3",      sectw,   0.8,  0.5,  1.0);
t(64,  3,   "B",          ttabw,   0.8,  0.5,  1.0);
t(65,  3,   "C",          ttabw,   0.8,  0.5,  1.0);
t(66,  3,   "D",          ttabw,   0.8,  0.5,  1.0);
t(67,  3,   "Chorus 3",   sectw,   1.0,  0.4,  0.4);
t(68,  3,   "B",          ttabw,   1.0,  0.4,  0.4);
t(69,  3,   "C",          ttabw,   1.0,  0.4,  0.4);
t(70,  3,   "D",          ttabw,   1.0,  0.4,  0.4);
t(71,  3,   "Outro",      sectw,   0.5,  0.8,  0.7);
t(72,  3,   "B",          ttabw,   0.5,  0.8,  0.7);
t(73,  3,   "C",          ttabw,   0.5,  0.8,  0.7);
t(74,  3,   "D",          ttabw,   0.5,  0.8,  0.7);
t(75,  3,   "rsv",    hw,    0.8,  0.8,  0.8);
t(76,  3,   "rsv",    hw,    0.8,  0.8,  0.8);
t(77,  3,   "rsv",   hw,     0.9,  0.4,  1);
t(78,  3,   "rsv",   hw,     0.9,  0.4,  1);
t(79,  3,   "rsv",   hw,     0.9,  0.4,  1);

// =========================================================
// GENERAL HELPER FUNCTIONS
// =========================================================
#name_menu = "Bass Drum|Bass Drum 1|Bass Drum 2|China|Clap|Conga High|Conga Low|Cowbell|Crash|Crash Cymbal 1|Crash Cymbal 2|Cymbal|FX 1|FX 2|Hand Clap|Hat Cl|Hat Pd|Hat Op|Kick|High Floor Tom|Kick 1|Kick 2|Maraca|Perc 1|Perc 2|Perc 3|Ride|Ride Bell|Rimshot|Shaker|Side Stick|Snare|Snare 1|Snare 2|Splash|Tambourine|Tom Hi|Tom Mid|Tom Lo|Triangle Mute|Triangle Open|(Empty)";
#color_menu = "White|Red|Deep Orange|Orange|Amber|Yellow|Lime|Green|Mint|Cyan|Sky|Blue|Indigo|Purple|Violet|Magenta|Rose|Grey";

EMPTY_NAME_IDX = 41;

function clamp(x,a,b) ( x<a ? a : (x>b ? b : x); );
function fmod_pos(x, m) ( m<=0 ? 0 : x - floor(x/m)*m; );

function get_menu_item(list_str, idx, out_str)
local(str_len, char_idx, item_ctr, c)
(
    strcpy(out_str, "");
    str_len = strlen(list_str);
    char_idx = 0; item_ctr = 0;
    while (item_ctr < idx && char_idx < str_len) (
        str_getchar(list_str, char_idx) == '|' ? item_ctr += 1;
        char_idx += 1;
    );
    while (char_idx < str_len) (
        c = str_getchar(list_str, char_idx);
        c == '|' ? char_idx = str_len : ( str_setchar(out_str, strlen(out_str), c); );
        char_idx += 1;
    );
);

function auto_fit_rows(y_start, row_h)
local(avail_height, calc_rows)
(
    avail_height = gfx_h - y_start;
    (avail_height > 0 && row_h > 0) ? (
        calc_rows = floor(avail_height / row_h);
        calc_rows < 1 ? calc_rows = 1;
        calc_rows > 128 ? calc_rows = 128;
        slider7 != calc_rows ? (
            slider7 = calc_rows;
            slider_automate(slider7);
        );
    );
);

function flush_inventory_to_gmem()
local(inst_offset, i, m0, m1, m2, m3, target_pc, idx, rem)
(
    inst_offset = GMEM_INV_BASE + (floor(slider5) - 1) * 4;
    m0=0; m1=0; m2=0; m3=0;
    i=0; loop(TOTAL_TABS, 
        mem[LOC_TAB_POPULATED + i] ? (
            target_pc = mem[inv_map_base + i];
            target_pc >= 0 ? (
                idx = floor(target_pc / 32);
                rem = target_pc % 32;
                idx == 0 ? m0 |= (1 << rem);
                idx == 1 ? m1 |= (1 << rem);
                idx == 2 ? m2 |= (1 << rem);
                idx == 3 ? m3 |= (1 << rem);
            );
        );
        i += 1;
    );
    gmem[inst_offset+0] = m0;
    gmem[inst_offset+1] = m1;
    gmem[inst_offset+2] = m2;
    gmem[inst_offset+3] = m3;
);

function check_tab_population(t_idx)
local(ptr, k, has_d)
(
    has_d = 0;
    ptr = grid_base + t_idx*vel_stride_tab;
    k = 0; 
    while (k < vel_stride_tab && has_d == 0) (
        mem[ptr + k] > 0 ? has_d = 1;
        k += 1;
    );
    mem[LOC_TAB_POPULATED + t_idx] = has_d;
);

function scan_active_tab() (
    check_tab_population(mem[ui_edit_tab]);
    flush_inventory_to_gmem();
);

function scan_all_tabs() local(i) (
    i = 0; loop(TOTAL_TABS, check_tab_population(i); i+=1; );
    flush_inventory_to_gmem();
);

function import_n2n_data(bank_mode) ( 0; );
function export_n2n_data(bank_mode) ( 0; );

function resolve_color_idx(str_in)
(
    matchi("*White*", str_in) ? 0 :
    matchi("*Deep*Orange*", str_in) ? 2 :
    matchi("*Orange*", str_in) ? 3 :
    matchi("*Amber*", str_in) ? 4 :
    matchi("*Yellow*", str_in) ? 5 :
    matchi("*Lime*", str_in) ? 6 :
    matchi("*Mint*", str_in) ? 8 :
    matchi("*Green*", str_in) ? 7 :
    matchi("*Cyan*", str_in) ? 9 :
    matchi("*Sky*", str_in) ? 10 :
    matchi("*Indigo*", str_in) ? 12 :
    matchi("*Blue*", str_in) ? 11 :
    matchi("*Purple*", str_in) ? 13 :
    matchi("*Violet*", str_in) ? 14 :
    matchi("*Magenta*", str_in) ? 15 :
    matchi("*Rose*", str_in) ? 16 :
    matchi("*Grey*", str_in) ? 17 :
    matchi("*Gray*", str_in) ? 17 :
    matchi("*Red*", str_in) ? 1 :
    matchi("*Pianoblack*", str_in) ? 100 :
    matchi("*Pianowhite*", str_in) ? 101 :
    -1; 
);

function get_d_name(idx, out) (
    get_menu_item(#name_menu, idx, out);
    strcmp(out, "(Empty)") == 0 ? strcpy(out, "");
    (strlen(out) == 0 && idx != 41) ? sprintf(out, "Drum %d", idx+1);
);

function get_t_name(idx, out) (
    idx == 0 ?  strcpy(out, "Off") :
    idx == 1 ?  strcpy(out, "Intro A") :
    idx == 2 ?  strcpy(out, "B") :
    idx == 3 ?  strcpy(out, "C") :
    idx == 4 ?  strcpy(out, "D") :
    idx == 5 ?  strcpy(out, "Verse 1") :
    idx == 6 ?  strcpy(out, "B") :
    idx == 7 ?  strcpy(out, "C") :
    idx == 8 ?  strcpy(out, "D") :
    idx == 9 ?  strcpy(out, "Pre 1") :
    idx == 10 ? strcpy(out, "B") :
    idx == 11 ? strcpy(out, "C") :
    idx == 12 ? strcpy(out, "D") :
    idx == 13 ? strcpy(out, "Chorus 1") :
    idx == 14 ? strcpy(out, "B") :
    idx == 15 ? strcpy(out, "C") :
    idx == 16 ? strcpy(out, "D") :
    idx == 17 ? strcpy(out, "Bridge") :
    idx == 18 ? strcpy(out, "B") :
    idx == 19 ? strcpy(out, "C") :
    idx == 20 ? strcpy(out, "D") :
    idx == 21 ? strcpy(out, "H1") :
    idx == 22 ? strcpy(out, "H2") :
    idx == 23 ? strcpy(out, "1<") :
    idx == 24 ? strcpy(out, "1=") :
    idx == 25 ? strcpy(out, "1>") :
    idx == 26 ? strcpy(out, "Def") :
    idx == 27 ? strcpy(out, "1") :
    idx == 28 ? strcpy(out, "2") :
    idx == 29 ? strcpy(out, "3") :
    idx == 30 ? strcpy(out, "4") :
    idx == 31 ? strcpy(out, "5") :
    idx == 32 ? strcpy(out, "Verse 2") :
    idx == 33 ? strcpy(out, "B") :
    idx == 34 ? strcpy(out, "C") :
    idx == 35 ? strcpy(out, "D") :
    idx == 36 ? strcpy(out, "Pre 2") :
    idx == 37 ? strcpy(out, "B") :
    idx == 38 ? strcpy(out, "C") :
    idx == 39 ? strcpy(out, "D") :
    idx == 40 ? strcpy(out, "Chorus 2") :
    idx == 41 ? strcpy(out, "B") :
    idx == 42 ? strcpy(out, "C") :
    idx == 43 ? strcpy(out, "D") :
    idx == 44 ? strcpy(out, "Solo") :
    idx == 45 ? strcpy(out, "B") :
    idx == 46 ? strcpy(out, "C") :
    idx == 47 ? strcpy(out, "D") :
    idx == 48 ? strcpy(out, "H3") :
    idx == 49 ? strcpy(out, "H4") :
    idx == 50 ? strcpy(out, "2<") :
    idx == 51 ? strcpy(out, "2=") :
    idx == 52 ? strcpy(out, "2>") :
    idx == 53 ? strcpy(out, "Min") :
    idx == 54 ? strcpy(out, "6") :
    idx == 55 ? strcpy(out, "7") :
    idx == 56 ? strcpy(out, "8") :
    idx == 57 ? strcpy(out, "9") :
    idx == 58 ? strcpy(out, "10") :
    idx == 59 ? strcpy(out, "Verse 3") :
    idx == 60 ? strcpy(out, "B") :
    idx == 61 ? strcpy(out, "C") :
    idx == 62 ? strcpy(out, "D") :
    idx == 63 ? strcpy(out, "Pre 3") :
    idx == 64 ? strcpy(out, "B") :
    idx == 65 ? strcpy(out, "C") :
    idx == 66 ? strcpy(out, "D") :
    idx == 67 ? strcpy(out, "Chorus 3") :
    idx == 68 ? strcpy(out, "B") :
    idx == 69 ? strcpy(out, "C") :
    idx == 70 ? strcpy(out, "D") :
    idx == 71 ? strcpy(out, "Outro") :
    idx == 72 ? strcpy(out, "B") :
    idx == 73 ? strcpy(out, "C") :
    idx == 74 ? strcpy(out, "D") : 
    idx == 75 ? strcpy(out, "rsv") :
    idx == 76 ? strcpy(out, "rsv") :
    idx == 77 ? strcpy(out, "rsv") :
    idx == 78 ? strcpy(out, "rsv") :
    idx == 79 ? strcpy(out, "rsv") :  
    sprintf(out, "%d", idx);
);


function get_palette_values(idx) (
    idx==0 ? (lcr=1.0; lcg=1.0; lcb=1.0;) : 
    idx==1 ? (lcr=1.0; lcg=0.4; lcb=0.4;) :
    idx==2 ? (lcr=1.0; lcg=0.55; lcb=0.3;) :
    idx==3 ? (lcr=1.0; lcg=0.7; lcb=0.2;) :
    idx==4 ? (lcr=1.0; lcg=0.85; lcb=0.2;) :
    idx==5 ? (lcr=1.0; lcg=1.0; lcb=0.2;) :
    idx==6 ? (lcr=0.7; lcg=1.0; lcb=0.2;) :
    idx==7 ? (lcr=0.4; lcg=0.9; lcb=0.4;) :
    idx==8 ? (lcr=0.2; lcg=1.0; lcb=0.7;) :
    idx==9 ? (lcr=0.2; lcg=0.9; lcb=0.9;) :
    idx==10 ? (lcr=0.2; lcg=0.7; lcb=1.0;) :
    idx==11 ? (lcr=0.4; lcg=0.6; lcb=1.0;) :
    idx==12 ? (lcr=0.5; lcg=0.4; lcb=1.0;) :
    idx==13 ? (lcr=0.7; lcg=0.4; lcb=1.0;) :
    idx==14 ? (lcr=0.9; lcg=0.4; lcb=1.0;) :
    idx==15 ? (lcr=1.0; lcg=0.4; lcb=1.0;) :
    idx==16 ? (lcr=1.0; lcg=0.4; lcb=0.7;) :
    idx==17 ? (lcr=0.5; lcg=0.5; lcb=0.5;) :
    (lcr=0.9; lcg=0.9; lcb=0.9;);
    cr = lcr; cg = lcg; cb = lcb;
);

function set_ui_color(idx) ( get_palette_values(idx); gfx_set(cr, cg, cb, 1); );

function eff_bars(t) (
    b = mem[bars_ov_base+t];
    (b<1 || b>4) ? slider4 : b;
);

function eff_sub(t) (
    ov = mem[subdiv_ov_base+t];
    (ov<0 || ov>4) ? (ov = slider3);
    ov==0?8:ov==1?12:ov==2?16:ov==3?24:32;
);

function eff_swing(t) (
    base_swing = (slider9 == 0) ? gmem[1] : slider6;
    s = mem[swing_ov_base+t];
    s < 0 ? base_swing : s;
);

function eff_hum(t) (
    h = mem[hum_ov_base+t];
    h<0 ? slider2 : h;
);

function eff_half(t) (
    mem[half_speed_ov_base+t];
);

function parse_kit_line(line_slot_in, name_slot_out, note_out, chan_out, color_idx_out)
local(line_len, i, k, note_val, chan_val, name_start_idx, name_end_idx, c_idx, found_channel, col_sep_idx, col_start, name_len, max_name_len)
(
    max_name_len = 20; 
    mem[note_out] = -1; 
    mem[chan_out] = -1; 
    mem[color_idx_out] = -1; 
    strcpy(name_slot_out, ""); 
    line_len = strlen(line_slot_in);
    c_idx = 0; found_channel = 0;
    while (c_idx < line_len - 1 && !found_channel) (
        (str_getchar(line_slot_in, c_idx) == '/' && str_getchar(line_slot_in, c_idx+1) == '/') ? (
            k = c_idx + 2;
            while (k < line_len && str_getchar(line_slot_in, k) <= 32) (k += 1;);
            (k < line_len && str_getchar(line_slot_in, k) >= '0' && str_getchar(line_slot_in, k) <= '9') ? (
                chan_val = 0;
                while (k < line_len && str_getchar(line_slot_in, k) >= '0' && str_getchar(line_slot_in, k) <= '9') (
                    chan_val = chan_val * 10 + (str_getchar(line_slot_in, k) - '0');
                    k += 1;
                );
                (chan_val >= 1 && chan_val <= 16) ? ( mem[chan_out] = chan_val; found_channel = 1; );
            );
        );
        c_idx += 1;
    );
    !found_channel ? (
        i = 0;
        while (i < line_len && (str_getchar(line_slot_in, i) < '0' || str_getchar(line_slot_in, i) > '9')) ( i += 1; );
        (i < line_len) ? (
            note_val = 0;
            while (i < line_len && str_getchar(line_slot_in, i) >= '0' && str_getchar(line_slot_in, i) <= '9') (
                note_val = note_val * 10 + (str_getchar(line_slot_in, i) - '0');
                i += 1;
            );
            (note_val >= 0 && note_val <= 127) ? (
                mem[note_out] = note_val;
                while (i < line_len && (str_getchar(line_slot_in, i) <= 32 || str_getchar(line_slot_in, i) == ':' || str_getchar(line_slot_in, i) == '-')) ( i += 1; );
                name_start_idx = i;
                name_end_idx = line_len - 1;
                col_sep_idx = -1;
                k = name_start_idx;
                while (k < line_len - 1) (
                    (str_getchar(line_slot_in, k) == '/' && str_getchar(line_slot_in, k+1) == '/') ? (
                        col_sep_idx = k; k = line_len; 
                    );
                    k += 1;
                );
                col_sep_idx != -1 ? (
                    name_end_idx = col_sep_idx - 1; 
                    col_start = col_sep_idx + 2;
                    strcpy_substr(#color_tmp, line_slot_in, col_start, line_len - col_start);
                    mem[color_idx_out] = resolve_color_idx(#color_tmp);
                );
                while (name_end_idx >= name_start_idx && str_getchar(line_slot_in, name_end_idx) <= 32) ( name_end_idx -= 1; );
                name_end_idx >= name_start_idx ? (
                    name_len = name_end_idx - name_start_idx + 1;
                    name_len > max_name_len ? name_len = max_name_len;
                    strcpy_substr(name_slot_out, line_slot_in, name_start_idx, name_len);
                );
                1; 
            );
        );
    ) : ( 1 );
);

function load_kit_from_slider()
local(handle, note_out, chan_out, color_idx_out, current_chan, cur_row_idx, parsed, i, SLOT_LINE, SLOT_NAME,
      sel_r, context_chan, context_color)
(
    note_out = 50000; chan_out = 50001; color_idx_out = 50002; 
    SLOT_LINE = STR_BUF_LINE; SLOT_NAME = STR_BUF_NAME;
    sel_r = mem[ui_selected_row];
    sel_r < 0 ? sel_r = 0; sel_r >= MAX_ROWS ? sel_r = MAX_ROWS - 1;
    context_chan = mem[row_chan_base + sel_r];
    context_color = mem[row_color_base + sel_r];
    context_chan < 1 ? context_chan = 1;
    handle = file_open(slider10);
    handle > 0 ? (
        i = 0; loop(MAX_ROWS,
            mem[row_note_base+i] = -1; mem[row_chan_base+i] = 1; mem[row_color_base+i] = 0; 
            mem[row_name_idx+i] = 41; 
            strcpy(row_name_str_base + i, ""); 
            i+=1;
        );
        current_chan = context_chan; 
        cur_row_idx = 0;
        while (file_string(handle, SLOT_LINE) > 0) (
            parsed = parse_kit_line(SLOT_LINE, SLOT_NAME, note_out, chan_out, color_idx_out);
            (parsed == 1) ? (
                (mem[note_out] != -1) ? ( 
                    (cur_row_idx < MAX_ROWS) ? (
                        mem[row_note_base+cur_row_idx]  = mem[note_out];
                        mem[row_chan_base+cur_row_idx]  = current_chan; 
                        strlen(SLOT_NAME) > 0 ? ( strcpy(row_name_str_base + cur_row_idx, SLOT_NAME); ) 
                        : ( sprintf(row_name_str_base + cur_row_idx, "Drum %d", mem[note_out]); );
                        mem[row_name_idx+cur_row_idx] = 41; 
                        mem[row_color_base+cur_row_idx] = (mem[color_idx_out] != -1) ? mem[color_idx_out] : context_color;
                        cur_row_idx += 1;
                    );
                ) : ( (mem[chan_out] != -1) ? ( current_chan = mem[chan_out]; ); );
            );
            strcpy(SLOT_LINE, ""); 
        );
        file_close(handle);
    );
);

function add_kit_from_slider()
local(handle, note_out, chan_out, color_idx_out, current_chan, 
      tmp_kit_note, tmp_kit_chan, tmp_kit_color, kit_buf_idx, 
      parsed, j, insert_idx, incoming_note, incoming_chan, incoming_color, i, SLOT_LINE, SLOT_NAME, TEMP_STR_OFFSET,
      sel_r, context_chan, context_color)
(
    note_out = 50000; chan_out = 50001; color_idx_out = 50002; 
    SLOT_LINE = STR_BUF_LINE; SLOT_NAME = STR_BUF_NAME;
    tmp_kit_note = kit_tmp_base; tmp_kit_chan = kit_tmp_base + 128; tmp_kit_color = kit_tmp_base + 256; 
    TEMP_STR_OFFSET = 3000; 
    sel_r = mem[ui_selected_row];
    sel_r < 0 ? sel_r = 0; sel_r >= MAX_ROWS ? sel_r = MAX_ROWS - 1;
    context_chan = mem[row_chan_base + sel_r];
    context_color = mem[row_color_base + sel_r];
    context_chan < 1 ? context_chan = 1;
    insert_idx = sel_r;
    handle = file_open(slider10);
    handle > 0 ? (
        kit_buf_idx = 0;
        i = 0; loop(MAX_ROWS, mem[tmp_kit_note+i]=-1; i+=1;); 
        current_chan = context_chan; 
        while (file_string(handle, SLOT_LINE) > 0) (
            parsed = parse_kit_line(SLOT_LINE, SLOT_NAME, note_out, chan_out, color_idx_out);
            (parsed == 1) ? (
                (mem[note_out] != -1) ? (
                    (kit_buf_idx < MAX_ROWS) ? (
                        mem[tmp_kit_note + kit_buf_idx] = mem[note_out];
                        mem[tmp_kit_chan + kit_buf_idx] = current_chan;
                        mem[tmp_kit_color + kit_buf_idx] = mem[color_idx_out];
                        strlen(SLOT_NAME) > 20 ? (
                            strcpy_substr(TEMP_STR_OFFSET + kit_buf_idx, SLOT_NAME, 0, 20);
                        ) : (
                            strcpy(TEMP_STR_OFFSET + kit_buf_idx, SLOT_NAME);
                        );
                        kit_buf_idx += 1;
                    );
                ) : ( (mem[chan_out] != -1) ? ( current_chan = mem[chan_out]; ); );
            );
            strcpy(SLOT_LINE, ""); 
        );
        file_close(handle);
        i = 0; loop(kit_buf_idx,
            incoming_note = mem[tmp_kit_note + i]; incoming_chan = mem[tmp_kit_chan + i]; incoming_color = mem[tmp_kit_color + i];
            while (insert_idx < MAX_ROWS && (mem[row_note_base+insert_idx] != -1 || strlen(row_name_str_base + insert_idx) > 0)) ( insert_idx += 1; );
            (insert_idx < MAX_ROWS) ? (
                mem[row_note_base+insert_idx]  = incoming_note;
                mem[row_chan_base+insert_idx]  = incoming_chan;
                strcpy(row_name_str_base + insert_idx, TEMP_STR_OFFSET + i);
                mem[row_color_base+insert_idx] = (incoming_color != -1) ? incoming_color : context_color;
                mem[row_mute_base+insert_idx] = 0; mem[row_solo_base+insert_idx] = 0; mem[row_name_idx+insert_idx] = 41; 
                insert_idx += 1; 
            );
            i+=1;
        );
    );
);

(mem[ver_chk] != NEW_MAGIC_VER) ? (
    mem[ui_edit_tab] = 26; // Default to 'Def' (Tab 26)
    mem[ui_play_prog_tab] = 26;
    mem[ui_locked_tab] = -1;
    mem[ui_play_offset] = 0;
    i_d=0; loop(MAX_ROWS,
        n_val = 36 + i_d;
        while(n_val > 127) ( n_val -= 128; );
        mem[row_note_base+i_d] = n_val;
        mem[row_chan_base+i_d]=1;
        mem[row_level_base+i_d]=80; 
        mem[row_human_base+i_d]=-1;
        mem[row_name_idx+i_d] = i_d;
        mem[row_color_base+i_d]=0;
        mem[row_len_base+i_d] = 20;
        mem[row_mute_base+i_d]=0;
        mem[row_solo_base+i_d]=0;
        mem[row_offs_base+i_d]=0;
        strcpy(row_name_str_base + i_d, "");
        i_d+=1;
    );
    memset(vel_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    memset(grid_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    memset(step_len_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    t_d=0; loop(TOTAL_TABS,
        mem[bars_ov_base+t_d] = 0;
        mem[subdiv_ov_base+t_d] = -1; 
        mem[hum_ov_base+t_d] = -1;
        mem[swing_ov_base+t_d] = -1;
        mem[half_speed_ov_base+t_d] = 0;
        t_d+=1;
    );
    mem[ver_chk] = NEW_MAGIC_VER;
);

function swap_rows(a, b)
local(tmp, t, basev, baseg, basel, i, offa, offb, va, vb, ga, gb, la, lb, slot_a, slot_b)
(
    a == b ? 0 :
    (
        tmp = mem[row_mute_base+a];  mem[row_mute_base+a]=mem[row_mute_base+b];  mem[row_mute_base+b]=tmp;
        tmp = mem[row_solo_base+a];  mem[row_solo_base+a]=mem[row_solo_base+b];  mem[row_solo_base+b]=tmp;
        tmp = mem[row_note_base+a];  mem[row_note_base+a]=mem[row_note_base+b];  mem[row_note_base+b]=tmp;
        tmp = mem[row_chan_base+a];  mem[row_chan_base+a]=mem[row_chan_base+b];  mem[row_chan_base+b]=tmp;
        tmp = mem[row_level_base+a]; mem[row_level_base+a]=mem[row_level_base+b]; mem[row_level_base+b]=tmp;
        tmp = mem[row_human_base+a]; mem[row_human_base+a]=mem[row_human_base+b]; mem[row_human_base+b]=tmp;
        tmp = mem[row_len_base+a];   mem[row_len_base+a]=mem[row_len_base+b];   mem[row_len_base+b]=tmp;
        tmp = mem[row_name_idx+a];   mem[row_name_idx+a]=mem[row_name_idx+b];   mem[row_name_idx+b]=tmp;
        tmp = mem[row_offs_base+a];  mem[row_offs_base+a]=mem[row_offs_base+b]; mem[row_offs_base+b]=tmp;
        tmp = mem[row_color_base+a]; mem[row_color_base+a]=mem[row_color_base+b]; mem[row_color_base+b]=tmp;
        slot_a = row_name_str_base + a;
        slot_b = row_name_str_base + b;
        strcpy(STR_BUF_SWAP, slot_a);
        strcpy(slot_a, slot_b);
        strcpy(slot_b, STR_BUF_SWAP);
        t=0; loop(TOTAL_TABS,
            basev = vel_base + t*vel_stride_tab;
            baseg = grid_base + t*vel_stride_tab;
            basel = step_len_base + t*vel_stride_tab;
            offa = a*vel_stride_row;
            offb = b*vel_stride_row;
            i=0; loop(MAX_STEPS,
                va = mem[basev + offa + i]; vb = mem[basev + offb + i];
                mem[basev + offa + i] = vb; mem[basev + offb + i] = va;
                ga = mem[baseg + offa + i]; gb = mem[baseg + offb + i];
                mem[baseg + offa + i] = gb; mem[baseg + offb + i] = ga;
                la = mem[basel + offa + i]; lb = mem[basel + offb + i];
                mem[basel + offa + i] = lb; mem[basel + offb + i] = la;
                i+=1;
            );
            t+=1;
        );
        sel = mem[ui_selected_row];
        sel == a ? mem[ui_selected_row]=b : sel == b ? mem[ui_selected_row]=a : 0;
    );
);

scan_all_tabs();
freembuf(state_len + MAX_ROWS * str_size)

@serialize
preserved_id = slider5; // Save Instance ID before anything happens

file_avail(0) > 0 ? (
    // LOADING
    file_var(0, loaded_ver);
    
    // --- LOAD "WHERE IT WAS" (v5.6 -> v5.8) ---
    // We load the file directly into the Original Slots (0...7M).
    
    (loaded_ver == LEGACY_MAGIC_VER) ? (
        
        // 1. Read the Entire File State into Low Memory (0..7M)
        file_mem(0, 0, 7000000); 
        i=0; loop(MAX_ROWS, file_string(0, row_name_str_base + i * str_size); i+=1;);
        
        // 2. MIGRATE DATA (Copy Low Mem -> High Mem)
        
        // --- ROWS (Attributes only) ---
        memcpy(row_mute_base, OLD_ROW_START, 1280);
        
        // --- LOOP 0-63 (OLD TABS) AND MAP TO NEW ---
        // Mapping Logic: Preserve A,B,C flows. Move Bank 2 to Bank 2 slots.
        t_old = 0;
        loop(64,
            t_new = 
            (t_old == 0) ? 0 : 
            (t_old == 1) ? 1 : (t_old == 2) ? 2 : (t_old == 3) ? 3 : 
            (t_old == 4) ? 5 : (t_old == 5) ? 6 : (t_old == 6) ? 7 : 
            (t_old == 7) ? 9 : (t_old == 8) ? 10 : (t_old == 9) ? 11 : 
            (t_old == 10) ? 13 : (t_old == 11) ? 14 : (t_old == 12) ? 15 : 
            (t_old == 13) ? 17 : (t_old == 14) ? 18 : (t_old == 15) ? 19 : 
            (t_old == 16) ? 71 : (t_old == 17) ? 72 : (t_old == 18) ? 73 : 
            (t_old == 19) ? 21 : (t_old == 20) ? 22 : 
            (t_old == 21) ? 23 : (t_old == 22) ? 24 : (t_old == 23) ? 25 : 
            (t_old == 24) ? 27 : (t_old == 25) ? 28 : (t_old == 26) ? 29 : 
            (t_old == 27) ? 30 : (t_old == 28) ? 31 : 
            (t_old == 29) ? 26 : 
            (t_old == 30) ? 4 : 
            (t_old == 31) ? 44 : (t_old == 32) ? 45 : (t_old == 33) ? 46 : 
            (t_old == 34) ? 8 : 
            (t_old == 35) ? 32 : (t_old == 36) ? 33 : (t_old == 37) ? 34 : 
            (t_old == 38) ? 12 : 
            (t_old == 39) ? 36 : (t_old == 40) ? 37 : (t_old == 41) ? 38 : 
            (t_old == 42) ? 16 : 
            (t_old == 43) ? 40 : (t_old == 44) ? 41 : (t_old == 45) ? 42 : 
            (t_old == 46) ? 20 : 
            (t_old == 47) ? 47 : 
            (t_old == 48) ? 75 : (t_old == 49) ? 76 : 
            (t_old == 50) ? 74 : 
            (t_old == 51) ? 77 : (t_old == 52) ? 78 : (t_old == 53) ? 79 : 
            (t_old == 54) ? 48 : (t_old == 55) ? 49 : 
            (t_old == 56) ? 50 : (t_old == 57) ? 51 : (t_old == 58) ? 52 : 
            (t_old == 59) ? 54 : (t_old == 60) ? 55 : (t_old == 61) ? 56 : 
            (t_old == 62) ? 57 : (t_old == 63) ? 58 : 
            t_old;

            // --- 1. UI PROPERTIES (SKIPPED) ---
            // We intentionally DO NOT copy W, UI_ROW, COL_R/G/B.
            // This forces the imported data to adopt the new v5.8 layout.

            // --- 2. OVERRIDES (Bars, Subdiv, etc) ---
            src_ov_base = 0;
            (t_old < 22) ? (
                // MAIN OVERRIDES (Tabs 0-21)
                // In v5.6, these were SEQUENTIAL arrays (Bars[0..21], then Sub[0..21])
                // NOT interleaved.
                
                OLD_BARS = OLD_OV_START;
                OLD_SUB  = OLD_BARS + 22;
                OLD_HUM  = OLD_SUB + 22;
                OLD_SW   = OLD_HUM + 22;
                OLD_HALF = OLD_SW + 22;
                
                mem[bars_ov_base + t_new]       = mem[OLD_BARS + t_old];
                mem[subdiv_ov_base + t_new]     = mem[OLD_SUB + t_old];
                mem[hum_ov_base + t_new]        = mem[OLD_HUM + t_old];
                mem[swing_ov_base + t_new]      = mem[OLD_SW + t_old];
                mem[half_speed_ov_base + t_new] = mem[OLD_HALF + t_old];
                
            ) : (
                // EXT OVERRIDES (Tabs 22-63)
                // Base address calculated from v5.6 memory map: 5,245,690
                // These were also SEQUENTIAL arrays of size 42 (64-22).
                
                EXT_OFFSET = t_old - 22;
                
                EXT_BARS = 5245690;
                EXT_SUB  = EXT_BARS + 42;
                EXT_HUM  = EXT_SUB + 42;
                EXT_SW   = EXT_HUM + 42;
                EXT_HALF = EXT_SW + 42;
                
                mem[bars_ov_base + t_new]       = mem[EXT_BARS + EXT_OFFSET];
                mem[subdiv_ov_base + t_new]     = mem[EXT_SUB + EXT_OFFSET];
                mem[hum_ov_base + t_new]        = mem[EXT_HUM + EXT_OFFSET];
                mem[swing_ov_base + t_new]      = mem[EXT_SW + EXT_OFFSET];
                mem[half_speed_ov_base + t_new] = mem[EXT_HALF + EXT_OFFSET];
            );

            // --- 3. GRID DATA (Velocity, Steps, Length) ---
            src_vel = OLD_GRID_START + (t_old * vel_stride_tab);
            src_grid = OLD_GRID_START + (64 * vel_stride_tab) + (t_old * vel_stride_tab);
            src_len = OLD_GRID_START + (128 * vel_stride_tab) + (t_old * vel_stride_tab);
            
            dst_vel = vel_base + (t_new * vel_stride_tab);
            dst_grid = grid_base + (t_new * vel_stride_tab);
            dst_len = step_len_base + (t_new * vel_stride_tab);
            
            memcpy(dst_vel, src_vel, vel_stride_tab);
            memcpy(dst_grid, src_grid, vel_stride_tab);
            memcpy(dst_len, src_len, vel_stride_tab);
            
            t_old += 1;
        );
        
        scan_all_tabs();
        
    ) : (loaded_ver >= NEW_MAGIC_VER) ? (
        // Normal Load (High Memory)
        file_mem(0, 0, state_len);
        i=0; loop(MAX_ROWS, file_string(0, row_name_str_base + i * str_size); i+=1;);
        
        t=0; loop(TOTAL_TABS,
            file_var(0, val); mem[bars_ov_base + t] = val;
            file_var(0, val); mem[subdiv_ov_base + t] = val;
            file_var(0, val); mem[hum_ov_base + t] = val;
            file_var(0, val); mem[swing_ov_base + t] = val;
            file_var(0, val); mem[half_speed_ov_base + t] = val;
            t+=1;
        );
        
        file_mem(0, vel_base, TOTAL_TABS * vel_stride_tab);
        file_mem(0, grid_base, TOTAL_TABS * vel_stride_tab);
        file_mem(0, step_len_base, TOTAL_TABS * vel_stride_tab);
        file_avail(0) >= 0 ? ( scan_all_tabs(); );
    );
    
    // RESTORE ID
    slider5 = preserved_id;
    
) : (
    // SAVING
    file_var(0, NEW_MAGIC_VER);
    file_mem(0, 0, state_len);
    i=0; loop(MAX_ROWS, file_string(0, row_name_str_base + i * str_size); i+=1;);
    
    t=0; loop(TOTAL_TABS,
        val = mem[bars_ov_base + t]; file_var(0, val);
        val = mem[subdiv_ov_base + t]; file_var(0, val);
        val = mem[hum_ov_base + t]; file_var(0, val);
        val = mem[swing_ov_base + t]; file_var(0, val);
        val = mem[half_speed_ov_base + t]; file_var(0, val);
        t+=1;
    );
    
    file_mem(0, vel_base, TOTAL_TABS * vel_stride_tab);
    file_mem(0, grid_base, TOTAL_TABS * vel_stride_tab);
    file_mem(0, step_len_base, TOTAL_TABS * vel_stride_tab);
);

@block
(slider9 == 0) ? ( slider6 = gmem[1]; );
(slider10 != last_kit_idx) ? (
    load_kit_from_slider();
    last_kit_idx = slider10;
);

(slider5 != last_reported_id) ? (
    scan_all_tabs();
    last_reported_id = slider5;
);

// INSTANCE ID LOCK (Self-Healing Logic)
(slider5 != my_slot) ? (
    slider5 = my_slot;
    slider_automate(slider5);
);

// TRACK IDENTITY
GMEM_INFO_BASE = 8200000;
my_info_idx = GMEM_INFO_BASE + ((slider5 - 1) * 4);
track_num = gmem[my_info_idx];
track_r = gmem[my_info_idx + 1];
track_g = gmem[my_info_idx + 2];
track_b = gmem[my_info_idx + 3];

GM_BASE = 7000000 + (slider5-1)*16;
gmem[GM_BASE] != 0x44504531 ? ( gmem[GM_BASE] = 0x44504531; gmem[GM_BASE+1] = -1; gmem[GM_BASE+2] = 26; );
mem[ui_locked_tab] = gmem[GM_BASE+1];
mem[ui_play_prog_tab] = gmem[GM_BASE+2];

// SYNC GROOVE MEMORY
i_gr = 0; max_gr = 0;
loop(32, 
    val = gmem[GMEM_GROOVE_OFFSET + i_gr];
    val < -12 ? val = -12 : val > 12 ? val = 12;
    mem[LOCAL_GROOVE_DB + i_gr] = val; 
    abs(val) > max_gr ? max_gr = abs(val);
    i_gr+=1; 
);
mem[LOCAL_GROOVE_DB + 32] = max_gr;

// =========================================================
// CUE SYSTEM LOGIC
// =========================================================

// 1. REPORT TYPE (I am Drums)
(slider5 > 0) ? ( gmem[GMEM_TYPE_REPORT + slider5 - 1] = MY_TYPE_ID; );

function get_tab_from_pc(pc_val) (
    pc_val == 0 ? 0 : // Off
    (pc_val >= 1 && pc_val <= 5) ? 27 + (pc_val - 1) : // 1-5 -> Tabs 27-31
    (pc_val >= 6 && pc_val <= 10) ? 54 + (pc_val - 6) : // 6-10 -> Tabs 54-58
    pc_val == 19 ? 53 : // Min
    pc_val == 20 ? 21 : // H1
    pc_val == 21 ? 22 : // H2
    pc_val == 22 ? 48 : // H3
    pc_val == 23 ? 49 : // H4
    pc_val == 24 ? 0 : // Off
    pc_val == 25 ? 26 : // Def
    pc_val == 26 ? 23 : // F1<
    pc_val == 27 ? 24 : // F1=
    pc_val == 28 ? 25 : // F1>
    pc_val == 29 ? 50 : // F2<
    pc_val == 30 ? 51 : // F2=
    pc_val == 31 ? 52 : // F2>
    (pc_val >= 32 && pc_val <= 35) ? 1 + (pc_val - 32) : // Intro A-D -> 1-4
    (pc_val >= 36 && pc_val <= 39) ? 5 + (pc_val - 36) : // Verse 1 A-D -> 5-8
    (pc_val >= 40 && pc_val <= 43) ? 32 + (pc_val - 40) : // Verse 2 A-D -> 32-35
    (pc_val >= 44 && pc_val <= 47) ? 59 + (pc_val - 44) : // Verse 3 A-D -> 59-62
    (pc_val >= 48 && pc_val <= 51) ? 9 + (pc_val - 48) : // Pre 1 A-D -> 9-12
    (pc_val >= 52 && pc_val <= 55) ? 36 + (pc_val - 52) : // Pre 2 A-D -> 36-39
    (pc_val >= 56 && pc_val <= 59) ? 63 + (pc_val - 56) : // Pre 3 A-D -> 63-66
    (pc_val >= 60 && pc_val <= 63) ? 13 + (pc_val - 60) : // Chorus 1 A-D -> 13-16
    (pc_val >= 64 && pc_val <= 67) ? 40 + (pc_val - 64) : // Chorus 2 A-D -> 40-43
    (pc_val >= 68 && pc_val <= 71) ? 67 + (pc_val - 68) : // Chorus 3 A-D -> 67-70
    (pc_val >= 72 && pc_val <= 75) ? 17 + (pc_val - 72) : // Bridge A-D -> 17-20
    (pc_val >= 76 && pc_val <= 79) ? 44 + (pc_val - 76) : // Solo A-D -> 44-47
    (pc_val >= 80 && pc_val <= 83) ? 71 + (pc_val - 80) : // Outro A-D -> 71-74
    (pc_val >= 84 && pc_val <= 88) ? 75 + (pc_val - 84) : // Rsv -> 75-79
    -2; // Unmapped
);

// --- A. MIDI INPUT & IMMEDIATE MAPPING ---
while (midirecv(off, m1, m23)) (
    status = m1 & 0xF0;
    ch = (m1 & 0x0F) + 1;
    d1 = m23 & 0x7F; 
    d2 = (m23 >> 8) & 0x7F; 
    
    midisend(off, m1, m23);

    (ch == 16) ? (
        (status == 0xB0 && d1 == 0) ? (
             requested_start_bar = d2; 
             requested_start_bar < 1 ? requested_start_bar = 1;
        ) 
        : (status == 0xC0) ? (
            pc = d1;
            trig_t = get_tab_from_pc(pc);
            (trig_t != -2) ? (
                midi_cue_tab = trig_t;
                midi_cue_source = 2; // 2=PC
            );
        ) 
        : (status == 0x90 && d2 > 0) ? (
            nn = d1;
            trig_t = -2;
            (nn >= 36 && nn <= 83) ? (
                rel_note = nn - 36;
                oct = floor(rel_note / 12); 
                pitch = rel_note % 12;      
                pitch == 0 ? ( trig_t = 1; ) : 
                pitch == 2 ? ( trig_t = 4; ) : 
                pitch == 4 ? ( trig_t = 7; ) : 
                pitch == 5 ? ( trig_t = 10; ) : 
                pitch == 7 ? ( trig_t = 13; ) : 
                pitch == 9 ? ( trig_t = 16; ) : 
                pitch == 11 ? ( trig_t = 29; ) : 
                (oct < 2) ? (
                    pitch == 1 ? ( trig_t = 19 + (oct*35); ) : 
                    pitch == 3 ? ( trig_t = 20 + (oct*35); ) : 
                    pitch == 6 ? ( trig_t = 21 + (oct*35); ) : 
                    pitch == 8 ? ( trig_t = 22 + (oct*35); ) : 
                    pitch == 10 ? ( trig_t = 23 + (oct*35); ) : 0; 
                ) : (
                    u_base = (oct==2) ? 24 : 59;
                    pitch == 1 ? ( trig_t = u_base + 0; ) : 
                    pitch == 3 ? ( trig_t = u_base + 1; ) : 
                    pitch == 6 ? ( trig_t = u_base + 2; ) : 
                    pitch == 8 ? ( trig_t = u_base + 3; ) : 
                    pitch == 10 ? ( trig_t = u_base + 4; ) : 0; 
                );
            ) : ( nn == 24 ? trig_t = -1; ); 
            
            (trig_t != -2) ? (
                midi_cue_tab = trig_t;
                midi_cue_source = 0; // 0=Note
            );
        );
    );
);

// --- B. GATHER GMEM INPUT (Continuous Monitor) ---
gmem_cue_tab = -1;
gmem_source_addr = -1;

c_inst = gmem[GMEM_INST_BASE + slider5 - 1];
c_type = gmem[GMEM_TYPE_BASE + MY_TYPE_ID];
c_glob = gmem[GMEM_GLOBAL_ADDR];

(c_inst > 0) ? ( raw_val = c_inst; gmem_source_addr = GMEM_INST_BASE + slider5 - 1; ) :
(c_type > 0) ? ( raw_val = c_type; gmem_source_addr = GMEM_TYPE_BASE + MY_TYPE_ID; ) :
(c_glob > 0) ? ( raw_val = c_glob; gmem_source_addr = GMEM_GLOBAL_ADDR; ) : ( raw_val = 0; );

(raw_val > 0) ? (
    t_cue = get_tab_from_pc(raw_val - 1);
    (t_cue != -2) ? (
        gmem_cue_tab = t_cue;
    );
);

// --- C. DECISION LOGIC (Who Wins?) ---
final_target_tab = -1;
final_source_type = -1; 

(midi_cue_source == 0 && midi_cue_tab > -1) ? (
    final_target_tab = midi_cue_tab;
    final_source_type = 0;
) :
(gmem_cue_tab > -1 && gmem_source_addr != cue_clear_addr) ? (
    final_target_tab = gmem_cue_tab;
    final_source_type = 1;
) :
(midi_cue_source == 2 && midi_cue_tab > -1) ? (
    final_target_tab = midi_cue_tab;
    final_source_type = 2;
);

(final_target_tab > -1) ? (
    cue_armed = 1;
    cue_target_tab = final_target_tab;
    (cue_target_tab != mem[ui_play_prog_tab] && final_source_type == 1) ? (
         mem[ui_locked_tab] = -1; 
         gmem[GM_BASE+1] = -1; 
    );
    (final_source_type == 1) ? ( cue_clear_addr = gmem_source_addr; ) : ( cue_clear_addr = -1; );
);

// --- D. EXECUTION (The Bar Line) ---
(tempo > 0.001) ? ( samps_per_beat = (srate * 60) / tempo; ) : ( samps_per_beat = srate; );
block_dur_beats = samplesblock / samps_per_beat;
check_pos = beat_position + block_dur_beats;
current_bar_num = floor(check_pos / 4);

(play_state == 0 && cue_armed) ? ( current_bar_num = -999; last_bar_checked = -998; );

(current_bar_num != last_bar_checked) ? (
    last_bar_checked = current_bar_num;
    (cue_armed) ? (
        mem[ui_play_prog_tab] = cue_target_tab;
        mem[ui_play_offset] = 0;
        playback_shift = 0;
        gmem[GM_BASE+2] = cue_target_tab;
        pc_triggered = 1;
        cue_armed = 0;
        cue_clear_pending = 1;
        midi_cue_tab = -1; 
        midi_cue_source = -1;
    );
);

// --- E. CLEANUP (Beat 1.1) ---
pos_in_bar = beat_position % 4.0;
(cue_clear_addr >= 0 && cue_clear_pending) ? (
    (pos_in_bar >= 0.0 && pos_in_bar < 2.0) ? (
        gmem[cue_clear_addr] = 0;
        cue_clear_addr = -1;
        cue_clear_pending = 0;
    );
);

// --- F. RESTORED AUDIO PREVIEW LOGIC ---
preview_trig ? (
    preview_chan < 1 ? preview_chan = 1 : preview_chan > 16 ? preview_chan = 16;
    mem[kill_note + preview_note] > 0 ? ( k_ch = mem[kill_chan + preview_note]; midisend(0, 0x80 | (k_ch-1), preview_note); );
    midisend(0, 0x90 | (preview_chan-1), preview_note | (preview_vel<<8));
    l_val = mem[row_len_base+mem[ui_selected_row]];
    l_ms = (l_val < 64) ? (10 + l_val * 3.75) : (250 + (l_val-64)*11.9);
    mem[kill_note + preview_note] = srate * l_ms * 0.001;
    mem[kill_chan + preview_note] = preview_chan;
    preview_trig = 0;
);

(time_precise() - last_maint_time > 3.0) ? (
    scan_all_tabs();
    last_maint_time = time_precise();
);

(play_state == 0 && last_play_state != 0) ? (
    i_k=0; loop(128,
        mem[kill_note+i_k] > 0 ? (
            k_ch = mem[kill_chan+i_k]; k_ch < 1 ? k_ch = 1;
            midisend(0, 0x80 | (k_ch-1), i_k);
            mem[kill_note+i_k]=0;
        );
        i_k+=1;
    );
    mem[ui_last_step] = -1;
);
last_play_state = play_state;

playing = (play_state & 1);
t_pl = mem[ui_locked_tab] == -1 ? mem[ui_play_prog_tab] : mem[ui_locked_tab];

playing && t_pl != 0 && t_pl != -1 ? (
    sub_v = eff_sub(t_pl); bar_v = eff_bars(t_pl); swing_v = eff_swing(t_pl);
    is_half = eff_half(t_pl);
    spd_m = is_half ? 0.5 : 1.0; 
    st_v = bar_v * sub_v; 
    p_l = (bar_v * 4) / spd_m;
    curr_tab = mem[ui_play_prog_tab]; 
    curr_off = mem[ui_play_offset];
    (pc_triggered || curr_tab != last_play_tab || curr_off != last_play_offset) ? (
        curr_off >= bar_v ? curr_off = 0;
        target_beat = (curr_off * 4) / spd_m; 
        snap_grid = 4.0;
        next_grid = floor((beat_position + (snap_grid*0.5))/snap_grid) * snap_grid;
        natural_pos = next_grid % p_l; 
        playback_shift = target_beat - natural_pos;
        last_play_tab = curr_tab; 
        last_play_offset = curr_off; 
        pc_triggered = 0;
    );
    samps_per_beat = (srate * 60) / tempo;
    block_dur_beats = samplesblock / samps_per_beat;
    start_b = beat_position + playback_shift;
    end_b = start_b + block_dur_beats;
    scan_rate = is_half ? 0.5 : 1.0;
    steps_per_beat_grid = sub_v / 4;
    look_margin = steps_per_beat_grid * 1.5; 
    start_step_idx = floor(start_b * scan_rate * steps_per_beat_grid) - look_margin;
    end_step_idx = ceil(end_b * scan_rate * steps_per_beat_grid) + look_margin;
    h_solo = 0; 
    s_solo_chk=0; 
    loop(MAX_ROWS, mem[row_solo_base+s_solo_chk]?h_solo=1; s_solo_chk+=1;);
    (t_pl < 22) ? (
        cur_vel_ptr = vel_base + t_pl*vel_stride_tab;
        cur_grid_ptr = grid_base + t_pl*vel_stride_tab;
        cur_len_ptr = step_len_base + t_pl*vel_stride_tab;
    ) : (
        cur_vel_ptr = vel_base + t_pl*vel_stride_tab;
        cur_grid_ptr = grid_base + t_pl*vel_stride_tab;
        cur_len_ptr = step_len_base + t_pl*vel_stride_tab;
    );
    s_idx_iter = start_step_idx;
    loop((end_step_idx - start_step_idx) + 1,
        step_grid_time = s_idx_iter / steps_per_beat_grid;
        step_beat_time = step_grid_time / scan_rate;
        grid_lookup_idx = s_idx_iter; 
        lookup_mod = st_v;
        p_step = grid_lookup_idx % lookup_mod;
        while(p_step < 0) ( p_step += lookup_mod; );
        sw_amt = (swing_v / 100) * 0.33; 
        step_in_beat = (grid_lookup_idx % steps_per_beat_grid) / steps_per_beat_grid; 
        swing_offset_beats = 0;
        (step_in_beat >= 0.5 && step_in_beat < 1.0) ? ( swing_offset_beats = sw_amt; );
        cycle_beat = step_beat_time % 4.0; 
        groove_slot = floor(cycle_beat * 8); 
        groove_slot = clamp(groove_slot, 0, 31);
        groove_val = mem[LOCAL_GROOVE_DB + groove_slot]; 
        groove_offset_beats = (groove_val * 0.125) * scan_rate;
        r_p = 0;
        loop(MAX_ROWS,
            p_me = h_solo ? mem[row_solo_base+r_p] : (mem[row_mute_base+r_p] == 0);
            p_me ? (
               row_data_idx = r_p*vel_stride_row + p_step;
               mem[cur_grid_ptr + row_data_idx] ? (
                   row_offs_pct = mem[row_offs_base + r_p];
                   row_offset_beats = row_offs_pct / 100.0; 
                   final_offset = (swing_offset_beats + groove_offset_beats + row_offset_beats) / scan_rate;
                   total_time_beats = step_beat_time + final_offset;
                   diff_beats = total_time_beats - start_b;
                   diff_samples = floor(diff_beats * samps_per_beat);
                   (diff_samples >= 0 && diff_samples < samplesblock) ? (
                        v_p = mem[cur_vel_ptr+row_data_idx]; 
                        v_p <= 0 ? v_p = slider1;
                        eff_h = eff_hum(t_pl); 
                        h_p = (mem[row_human_base+r_p]>=0 ? mem[row_human_base+r_p] : eff_h);
                        v_p = clamp(v_p + (rand(h_p*2)-h_p), 1, 127);
                        note_to_play = mem[row_note_base+r_p]; 
                        chan_to_play = mem[row_chan_base+r_p];
                        final_vel = floor(v_p * (mem[row_level_base+r_p]/100));
                        final_vel < 1 ? final_vel = 1 : final_vel > 127 ? final_vel = 127;
                        chan_to_play < 1 ? chan_to_play = 1 : chan_to_play > 16 ? chan_to_play = 16;
                        mem[kill_note + note_to_play] > 0 ? ( 
                            k_ch = mem[kill_chan + note_to_play]; 
                            midisend(0, 0x80|(k_ch-1), note_to_play); 
                        );
                        midisend(diff_samples, 0x90|(chan_to_play-1), note_to_play|(final_vel<<8));
                        step_len_val = mem[cur_len_ptr+row_data_idx]; 
                        ms_per_step_x = (60000 / tempo) * (4 / sub_v);
                        is_half ? ms_per_step_x *= 2;
                        l_ms = (step_len_val == 0) ? (mem[row_len_base+r_p]*10) : (step_len_val * ms_per_step_x * 0.98);
                        mem[kill_note + note_to_play] = (srate * (l_ms + (diff_samples * 1.0 / srate) * 1000.0) * 0.001);
                        mem[kill_chan + note_to_play] = chan_to_play;
                   );
               );
            );
            r_p += 1;
        );
        s_idx_iter += 1;
    );
 );   
i_k=0; 
loop(128,
    mem[kill_note+i_k]>0 ? (
        mem[kill_note+i_k]-=samplesblock;
        mem[kill_note+i_k]<=0 ? (
            k_ch = mem[kill_chan+i_k]; 
            k_ch < 1 ? k_ch = 1;
            midisend(0, 0x80 | (k_ch-1), i_k);
            mem[kill_note+i_k]=0;
        );
    );
    i_k+=1;
);













@gfx 1618 780
grid_height = slider11; 
ext_noinit = 1.0;
ext_noundo = 1; 

// Add missing UI base offset
ui_vel_edit_all = ui_base + 7;

shift_dn = (mouse_cap & 8);
ctrl_dn  = (mouse_cap & 4);
alt_dn   = (mouse_cap & 16);

function draw_text(x,y,s,r,g,b) ( gfx_set(r,g,b,1); gfx_x=x; gfx_y=y; gfx_drawstr(s); );
function rect(x,y,w,h,r,g,b,a) ( gfx_set(r,g,b,a); gfx_rect(x,y,w,h); );

function find_covering_head(row_idx, step_idx, st_v)
local(lb, s0, ii, l)
(
    lb = 1;
    loop(step_idx,
        s0 = step_idx - lb;
        ii = row_idx*vel_stride_row + s0;
        mem[curr_pat_g_ptr + ii] ? (
            l = mem[curr_pat_l_ptr + ii];
            l < 1 ? l = 1;
            l > lb ? ( lb = 1000000; ii; ) : 0;
        ) : 0;
        lb += 1;
    );
    lb > 999999 ? ii : -1;
);

function draw_color_popup(px, py) local(i, row_hh, bw, bh, rx, ry, hover, c_name) (
    bw = 180; row_hh = 18; bh = row_hh * 18 + 6;
    px + bw > gfx_w ? px = gfx_w - bw - 2;
    py + bh > gfx_h ? py = gfx_h - bh - 2;
    px < 2 ? px = 2; py < 2 ? py = 2;
    rect(px, py, bw, bh, 0.08, 0.08, 0.08, 1);
    rect(px+1, py+1, bw-2, bh-2, 0.15, 0.15, 0.15, 1);
    i=0; loop(18,
        rx = px + 4; ry = py + 3 + i*row_hh;
        hover = (mx>=rx && mx<px+bw-4 && my>=ry && my<ry+row_hh);
        hover ? rect(rx, ry, bw-8, row_hh, 0.25,0.25,0.25,1) : 0;
        get_menu_item(#color_menu, i, #cn); 
        get_palette_values(i); 
        gfx_set(cr, cg, cb, 1);
        gfx_x = rx + 10; gfx_y = ry + 4; gfx_drawstr(#cn);
        (!mb && p_mb==1 && hover) ? ( 
            mem[row_color_base + color_popup_row] = i; 
            color_popup_active = 0; 
            mem[ui_selected_row] = color_popup_row;
        );
        i+=1;
    );
    (mb && p_mb==0 && !(mx>=px && mx<px+bw && my>=py && my<py+bh)) ? color_popup_active = 0;
);

function dr_p(x,y,lab,v_p,min_v,max_v,w) (
    draw_text(x, y, lab, 0.7,0.7,0.7);
    max_v == 100 ? sprintf(#vs, "%d%%", mem[v_p]) : sprintf(#vs, "%d", mem[v_p]);
    draw_text(x+w-25, y, #vs, 1,1,1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+20) ? (
        capture_id = v_p; capture_ptr = v_p; capture_slider_idx = 0;
        capture_min = min_v; capture_max = max_v; capture_is_signed = (min_v < 0);
        (v_p >= row_offs_base && v_p < row_offs_base + MAX_ROWS) ? capture_mode = 2 : capture_mode = 0;
    );
);

function dr_glob(id_num, x, y, w, lab, val_in, min_v, max_v, is_subdiv, is_swing, ov_addr, is_signed, slider_idx)
  local(v, is_ov, curr_val, active_tab, target_addr)
(
    active_tab = mem[ui_edit_tab]; is_ov = 0; curr_val = val_in; target_addr = -1;
    (active_tab > 0 && ov_addr >= 0) ? (
        target_addr = ov_addr + active_tab; // Flat memory access
        target_addr >= 0 ? (
            ov_val = mem[target_addr];
            (is_signed && ov_val >= 0) || (!is_signed && ov_val > 0) ? ( is_ov = 1; curr_val = ov_val; );
        );
    );
    rect(x, y, w, 20, 0.2, 0.2, 0.2, 1);
    draw_text(x+5, y+2, lab, 0.7,0.7,0.7);
    is_subdiv ? (
        v = curr_val;
        v==0?strcpy(#s,"8"):v==1?strcpy(#s,"12"):v==2?strcpy(#s,"16"):v==3?strcpy(#s,"24"):strcpy(#s,"32");
    )
    : is_swing ? ( sprintf(#s, "%d%%", curr_val); )
    : ( sprintf(#s, "%d", curr_val); );
    draw_text(x+w-35, y+2, #s, 1, 1, 1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+20) ? (
        capture_id = id_num; capture_min = min_v; capture_max = max_v; capture_is_signed = is_signed; capture_mode = 0;
        (rmb && active_tab > 0 && target_addr >= 0) ? (
            capture_ptr = target_addr; capture_slider_idx = 0;
            mem[capture_ptr] < 0 ? mem[capture_ptr] = val_in;
            !is_signed && mem[capture_ptr] == 0 ? mem[capture_ptr] = val_in;
        ) : (mb) ? (
            is_ov ? ( capture_ptr = target_addr; capture_slider_idx = 0; ) : ( capture_slider_idx = slider_idx; );
        );
    );
);

gfx_clear = 0.05;
mx = mouse_x; my = mouse_y;
mb = mouse_cap & 1;
rmb = mouse_cap & 2;

p_mb  = l_mb;  
p_rmb = l_rmb; 
p_mx = l_mx; 
p_my = l_my; 

(p_mb == 1 && mb == 0 && !color_popup_active) ? ( scan_active_tab(); );

(!mb && !rmb) ? (
  capture_id = 0;          
  capture_slider_idx = 0;  
  len_drag_active = 0; 
  row_drag_active = 0; 
  drag_mode = 0; 
  last_drag_idx = -1; 
  drag_accum_gen = 0; 
  drag_lock_row = -1; 
);

l_mb = mb;
l_rmb = rmb;
l_mx = mx;
l_my = my;

gfx_getchar(); 

ui_lock = (capture_id == 9999);
help_active ? capture_id = 90000;

UI_TOP_X=5; UI_TOP_Y=10; UI_GAP_X=40; UI_ROW_H=20;
HDR_X=UI_TOP_X; HDR_Y=UI_TOP_Y; HDR_W=240; HDR_H=20;
GLOB_LBL_W=180; GLOB_LBL_YOFF=0;
GW_DEFVEL_W=150; GW_ROWS_W=180; GW_INST_W=130;

ROW2_Y_OFFSET=30; ROW2_Y=UI_TOP_Y + ROW2_Y_OFFSET;
FOLLOW_LBL_X=UI_TOP_X; FOLLOW_LBL_W=55;
FOLLOW_BOX_X=UI_TOP_X + 60; FOLLOW_BOX_W=20; FOLLOW_BOX_H=16;

BTN_H=20; BTN_Y=ROW2_Y; BTN_X0=UI_TOP_X + 120;
BTN_W_COPY=109; BTN_W_PASTE=114; BTN_W_CLEAR=114; BTN_GAP=10;

PAT_LBL_W=190; PAT_BOX_H=20; PAT_BOX_W=120; PAT_BOX_GAP=70;
HIT_PAD_L=2; HIT_PAD_R=2;

function calc_vis_beat(t_in) (
    sub_v = eff_sub(t_in); 
    bar_v = eff_bars(t_in); 
    is_half = eff_half(t_in);
    spd_m = is_half ? 0.5 : 1.0;
    p_l = (bar_v * 4) / spd_m;
    playing_tab = (mem[ui_locked_tab] <= 0) ? mem[ui_play_prog_tab] : mem[ui_locked_tab];
    offset_add = 0; 
    (play_state & 1 && t_in == playing_tab) ? ( offset_add = playback_shift; );
    buffer_beats = (samplesblock / srate) * (tempo / 60);
    visual_pos = beat_position - buffer_beats ;
    play_state & 1 ? fmod_pos(visual_pos + offset_add, p_l) * spd_m : 0;
);

function btn(x,y,w,txt) (
    rect(x,y,w,BTN_H, 0.3,0.3,0.3,1);
    draw_text(x+5,y+1,txt,1,1,1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+BTN_H);
);

(mb && capture_id != 0 && capture_id != 9999 && capture_id != 12 && capture_id != 13 && capture_id != 12012 && capture_id != 42424 && capture_id != 88888 && capture_id != 77777 && capture_id != 11111) ? (
    drag_sens = (capture_max - capture_min) > 60 ? 1.0 : 5.0;
    capture_mode == 2 ? drag_sens = 5.0;
    drag_accum_gen += (mx - p_mx);
    abs(drag_accum_gen) >= drag_sens ? (
        inc = drag_accum_gen / drag_sens;
        inc = (inc > 0) ? floor(inc) : ceil(inc);
        drag_accum_gen -= (inc * drag_sens);
        capture_slider_idx > 0 ? (
            sv = slider(capture_slider_idx); 
            nv = clamp(sv + inc, capture_min, capture_max);
            slider(capture_slider_idx) = nv; 
            slider_automate(capture_slider_idx);
            capture_slider_idx == 1 ? (
                i_rst = 0;
                loop(MAX_ROWS * MAX_STEPS,
                    mem[curr_pat_g_ptr + i_rst] == 0 ? mem[curr_pat_v_ptr + i_rst] = 0;
                    i_rst += 1;
                );
            );
        ) : (
            mv = mem[capture_ptr]; 
            nv = clamp(mv + inc, capture_min, capture_max);
            capture_mode != 2 && capture_is_signed ? (
               nv <= 0 ? nv = -1; 
               mv == -1 && inc > 0 ? nv = 0;
            );
            mem[capture_ptr] = nv;
        );
    );
);

tx = UI_TOP_X; ty = UI_TOP_Y;
gfx_setfont(1, "Arial", 30, 'b');
bri = .9;
draw_text(HDR_X+2, HDR_Y-6 , "N2N Drum Arranger", 0.2*bri,  1.0*bri,  1.0*bri);
gfx_setfont(0);

tx = UI_TOP_X; ty = UI_TOP_Y;
gfx_setfont(1, "Arial", 12  , 'b');
bri = .9;

row1_y = UI_TOP_Y -3; 
x1 = HDR_X + HDR_W + UI_GAP_X - 10;
gfx_set(0.8,0.8,0.8,1); 
gfx_x = x1 + 44; 
gfx_y = row1_y + 5 + GLOB_LBL_YOFF; 
gfx_setfont(1, "Arial", 16, 'b');
gfx_drawstr("GLOBAL SETTINGS:");
gfx_setfont(0);         
        
GW_ROWS_W = 170; 
GW_HEIGHT_W = 100; 
xfix = 180;
x1 = x1 + xfix;

track_num > 0 ? (  // Background Box (Using Track Color)
rect(x1+39, row1_y-15, 1256, 44, track_r, track_g, track_b, 1);
rect(x1+760, row1_y+4, 63, 20,.1,.1,.1,1);

lum = (track_r * 0.299) + (track_g * 0.587) + (track_b * 0.114);
lum > 0.5 ? gfx_set(0,0,0,1) : gfx_set(1,1,1,1);
sprintf(#trk_str, "Track");
gfx_measurestr(#trk_str, tw, th);
gfx_x = x1+943 + (60-tw)/2;
gfx_y = row1_y-4 + (18-th)/2;
gfx_setfont(1, "Arial", 22, 'b');
gfx_drawstr(#trk_str);
gfx_setfont(0);

sprintf(#trk_str2, "%d", track_num);
gfx_measurestr(#trk_str2, tw, th);
gfx_x = x1+989 + (60-tw)/2;
gfx_y = row1_y-18 + (18-th)/2;
gfx_setfont(1, "Arial", 48, 'b');
gfx_drawstr(#trk_str2);
gfx_setfont(0);
);

gfx_setfont(1, "Arial", 16, 'b');

dr_glob(16, x1+39, row1_y+3, GW_ROWS_W+51, "  MAX ROWS TO SHOW:", slider7, 1, 128,  0, 0, -1, 0, 7);  
x1 += GW_ROWS_W + 33;
dr_glob(17, x1+62, row1_y+3, GW_HEIGHT_W+30, "  HEIGHT:", slider11, 10, 30, 0, 0, -1, 0, 11); 
x1 += GW_HEIGHT_W + UI_GAP_X;
dr_glob(15, x1+ 57, row1_y+3, GW_INST_W+1, "  INST ID:", slider5, 1, 512,  0, 0, -1, 0, 5); 
x1 += GW_INST_W + UI_GAP_X;

btn(x1+22, row1_y+4, 85, "RELOAD KIT") ? ( load_kit_from_slider(); ); 
btn(x1+314, row1_y+4, 18, "?") ? ( help_active = !help_active; );

// --- N2N IO BUTTONS ---
io_x = x1 + 112; gap = 33;
btn(io_x, row1_y+4, 27, "<") ? ( gfx_set(1,0,0,1); import_n2n_data(0); ); // Import Single
btn(io_x+gap, row1_y+4, 27, "<") ? ( gfx_set(1,0,0,1); import_n2n_data(1); ); // Import Bank
btn(io_x+gap*2, row1_y+4, 29, "   >") ? ( gfx_set(1,0,0,1); export_n2n_data(1); ); // Export Bank
btn(io_x+gap*3+1, row1_y+4, 30, "   >") ? ( gfx_set(1,0,0,1); export_n2n_data(0); ); // Export Single
rect(io_x+9, row1_y + 13, 13, 1, 1, 1, 1, 1);
rect(io_x+44, row1_y + 12, 12, 1, 1, 1, 1, 1);
rect(io_x+44, row1_y + 14, 12, 1, 1, 1, 1, 1);
rect(io_x+73, row1_y + 12, 12, 1, 1, 1, 1, 1);
rect(io_x+73, row1_y + 14, 12, 1, 1, 1, 1, 1);
rect(io_x+107, row1_y + 13, 13, 1, 1, 1, 1, 1);

gfx_setfont(0);       
x1 = x1 - xfix;
//rect(0, 37, gfx_w, 1, 0.25, 0.25, 0.25, 1);
row2_y = ROW2_Y; 

mem[ui_locked_tab] == -1 ? mem[ui_edit_tab] = mem[ui_play_prog_tab]; 
is_follow = (mem[ui_locked_tab] == -1);
gfx_setfont(1, "Arial", 16, 'b');
draw_text(FOLLOW_LBL_X+5, row2_y+20, "FOLLOW\n   MIDI\n  CUES:", 0.8,0.8,0.8); 

gfx_circle(FOLLOW_BOX_X+21, row2_y+36, 7, 0); // Outer
gfx_circle(FOLLOW_BOX_X+21, row2_y+36, 6.5, 0); // Middle
gfx_circle(FOLLOW_BOX_X+21, row2_y+36, 6, 0); // Middle
gfx_circle(FOLLOW_BOX_X+21, row2_y+36, 5.5, 0); // Middle
gfx_circle(FOLLOW_BOX_X+21, row2_y+35, 5, 0); // Inner
rect(FOLLOW_BOX_X+11, row2_y+37, FOLLOW_BOX_W+1, FOLLOW_BOX_H, 0.5, 0.5, 0.5, 1);
gfx_setfont(1, "Arial", 21, 'b');
is_follow ? draw_text(FOLLOW_BOX_X+15, row2_y+36, "X", 0,1,0);
is_follow ? rect(FOLLOW_BOX_X+11, row2_y+37, FOLLOW_BOX_W+1, FOLLOW_BOX_H,0.2*bri,  1.0*bri,  1.0*bri, 1);
gfx_setfont(1, "Arial", 16, 'b');
(mb && p_mb == 0 && mx>=FOLLOW_BOX_X-100 && mx<FOLLOW_BOX_X+FOLLOW_BOX_W+12 && my>=row2_y-37 && my<row2_y+38+FOLLOW_BOX_H) ? ( 
    mem[ui_locked_tab] == -1 ? mem[ui_locked_tab] = 26 : mem[ui_locked_tab] = -1; 
    gmem[GM_BASE+1] = mem[ui_locked_tab]; 
);

// =========================================================
// RE-ORDERED: TABS NOW DRAW FIRST (At Top)
// =========================================================

// --- TAB ROW 1 ---
ty = row2_y; // Reset Y to top of section
tx = 120;
gui_t = 0;
loop(TOTAL_TABS,
    my_row = mem[tab_ui_row_base + gui_t];
    (my_row == 1) ? (
        tw = mem[tab_w_base + gui_t]; 
        is_ed = (gui_t == mem[ui_edit_tab]);
        t_r = mem[tab_col_r + gui_t];
        t_g = mem[tab_col_g + gui_t];
        t_b = mem[tab_col_b + gui_t];
        is_ed ? (
             rect(tx, ty, tw-5, 26, 1, 1, 1, 1); 
             rect(tx+1, ty+1, tw-7, 24, t_r, t_g, t_b, 1);
        ) : (
             rect(tx, ty, tw-5, 26, t_r*0.4, t_g*0.4, t_b*0.4, 1);
        );
        get_t_name(gui_t, #tn); 
        gfx_setfont(1, "Arial", 16, 'b');
        is_ed ? ( draw_text(tx+5, ty+5, #tn, 0, 0, 0); ) : ( draw_text(tx+5, ty+4, #tn, 1, 1, 1); );
        gfx_setfont(0);  
        (mb && p_mb == 0 && mx>=tx && mx<tx+tw-24 && my>=ty && my<ty+26) ? ( 
            (time_precise() - last_tab_clk < 0.3 && last_tab_idx == gui_t) ? (
                mem[ui_locked_tab] = gui_t; 
                mem[ui_edit_tab] = gui_t;   
                gmem[GM_BASE+1] = mem[ui_locked_tab]; 
                last_tab_clk = 0; 
            ) : (
                mem[ui_locked_tab] != -1 ? (
                    mem[ui_edit_tab] = gui_t; 
                    mem[ui_play_offset] = 0; 
                    playback_shift = 0; 
                );
                mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
                last_tab_clk = time_precise(); 
                last_tab_idx = gui_t;
            );
        );
        
        gfx_set(0.0, 0.0, 0.0, 1); 
        gfx_circle(tx+tw-17, ly=ty+8, 6, 0); 
        gfx_circle(tx+tw-17, ly=ty+8, 5, 0); 
        gfx_circle(tx+tw-17, ly=ty+8, 4, 0); 
        
        lx=tx+tw-25; ly=ty+9; lw=17; lh=14;   
        rect(lx,ly,lw,lh, 0.1,0.1,0.1,1); 
        (mb && p_mb == 0 && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_locked_tab]=(mem[ui_locked_tab]==gui_t?-1:gui_t); 
            gmem[GM_BASE+1]=mem[ui_locked_tab]; 
            mem[ui_play_offset] = 0; 
            playback_shift = 0; 
        );
        (rmb && !p_rmb && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_edit_tab] = gui_t; 
            mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
        );
        
        mem[ui_locked_tab] == gui_t ? rect(lx+1,ly+2,lw-2,lh-3, 0.3,.9,.7,1);  
        (mem[ui_play_prog_tab] == gui_t) ? (gfx_set(1,.5 ,0,1); gfx_circle(tx+tw-17, ty+16, 4, 1);); 
        mem[LOC_TAB_POPULATED + gui_t] ? (
            gfx_set(1, 1, 1, 1);
            gfx_rect(tx-1, ty-1, 4, 24);
            gfx_rect(tx-1, ty-2, 41, 4);
            gfx_rect(tx-1, ty+23, 21, 4);
        );
        tx+=tw;
    );
    gui_t+=1;
); 

// --- TAB ROW 2 ---
ty += 30; 
tx = 120;
gui_t = 0;
loop(TOTAL_TABS,
    my_row = mem[tab_ui_row_base + gui_t];
    (my_row == 2) ? (
        tw = mem[tab_w_base + gui_t]; 
        is_ed = (gui_t == mem[ui_edit_tab]);
        t_r = mem[tab_col_r + gui_t];
        t_g = mem[tab_col_g + gui_t];
        t_b = mem[tab_col_b + gui_t];
        is_ed ? (
             rect(tx, ty, tw-5, 26, 1, 1, 1, 1); 
             rect(tx+1, ty+1, tw-7, 24, t_r, t_g, t_b, 1);
        ) : (
             rect(tx, ty, tw-5, 26, t_r*0.4, t_g*0.4, t_b*0.4, 1);
        );
        get_t_name(gui_t, #tn); 
        gfx_setfont(1, "Arial", 16, 'b');
        is_ed ? ( draw_text(tx+5, ty+5, #tn, 0, 0, 0); ) : ( draw_text(tx+5, ty+4, #tn, 1, 1, 1); );
        gfx_setfont(0);    
        
        (mb && p_mb == 0 && mx>=tx && mx<tx+tw-24 && my>=ty && my<ty+26) ? ( 
            (time_precise() - last_tab_clk < 0.3 && last_tab_idx == gui_t) ? (
                mem[ui_locked_tab] = gui_t; 
                mem[ui_edit_tab] = gui_t;   
                gmem[GM_BASE+1] = mem[ui_locked_tab]; 
                last_tab_clk = 0; 
            ) : (
                mem[ui_locked_tab] != -1 ? (
                    mem[ui_edit_tab] = gui_t; 
                    mem[ui_play_offset] = 0; 
                    playback_shift = 0; 
                );
                mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
                last_tab_clk = time_precise(); 
                last_tab_idx = gui_t;
            );
        );

        gfx_set(0.0, 0.0, 0.0, 1); 
        gfx_circle(tx+tw-17, ly=ty+8, 6, 0); 
        gfx_circle(tx+tw-17, ly=ty+8, 5, 0); 
        gfx_circle(tx+tw-17, ly=ty+8, 4, 0); 
        
        lx=tx+tw-25; ly=ty+9; lw=17; lh=14;   
        rect(lx,ly,lw,lh, 0.1,0.1,0.1,1); 
        (mb && p_mb == 0 && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_locked_tab]=(mem[ui_locked_tab]==gui_t?-1:gui_t); 
            gmem[GM_BASE+1]=mem[ui_locked_tab]; 
            mem[ui_play_offset] = 0; 
            playback_shift = 0;  
        );
        (rmb && !p_rmb && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_edit_tab] = gui_t; 
            mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
        );
        mem[ui_locked_tab] == gui_t ? rect(lx+1,ly+2,lw-2,lh-3, 0.3,.9,.7,1);   
        (mem[ui_play_prog_tab] == gui_t) ? (gfx_set(1,.5 ,0,1); gfx_circle(tx+tw-17, ty+16, 4, 1););  
        mem[LOC_TAB_POPULATED + gui_t] ? (
            gfx_set(1, 1, 1, 1);
            gfx_rect(tx-1, ty-1, 4, 24);
            gfx_rect(tx-1, ty-2, 41, 4);
            gfx_rect(tx-1, ty+23, 21, 4);
        );
        tx+=tw;
    );
    gui_t+=1;
);

// --- TAB ROW 3 ---
ty += 30; 
tx = 120;
gui_t = 0;
loop(TOTAL_TABS,
    my_row = mem[tab_ui_row_base + gui_t];
    (my_row == 3) ? (
        tw = mem[tab_w_base + gui_t]; 
        is_ed = (gui_t == mem[ui_edit_tab]);
        t_r = mem[tab_col_r + gui_t];
        t_g = mem[tab_col_g + gui_t];
        t_b = mem[tab_col_b + gui_t];
        is_ed ? (
             rect(tx, ty, tw-5, 26, 1, 1, 1, 1); 
             rect(tx+1, ty+1, tw-7, 24, t_r, t_g, t_b, 1);
        ) : (
             rect(tx, ty, tw-5, 26, t_r*0.4, t_g*0.4, t_b*0.4, 1);
        );
        get_t_name(gui_t, #tn); 
        gfx_setfont(1, "Arial", 16, 'b');
        is_ed ? ( draw_text(tx+5, ty+5, #tn, 0, 0, 0); ) : ( draw_text(tx+5, ty+4, #tn, 1, 1, 1); );
        gfx_setfont(0);    
        
        (mb && p_mb == 0 && mx>=tx && mx<tx+tw-24 && my>=ty && my<ty+26) ? ( 
            (time_precise() - last_tab_clk < 0.3 && last_tab_idx == gui_t) ? (
                mem[ui_locked_tab] = gui_t; 
                mem[ui_edit_tab] = gui_t;   
                gmem[GM_BASE+1] = mem[ui_locked_tab]; 
                last_tab_clk = 0; 
            ) : (
                mem[ui_locked_tab] != -1 ? (
                    mem[ui_edit_tab] = gui_t; 
                    mem[ui_play_offset] = 0; 
                    playback_shift = 0; 
                );
                mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
                last_tab_clk = time_precise(); 
                last_tab_idx = gui_t;
            );
        );

        gfx_set(0.0, 0.0, 0.0, 1); 
        gfx_circle(tx+tw-17, ly=ty+8, 6, 0); 
        gfx_circle(tx+tw-17, ly=ty+8, 5, 0); 
        gfx_circle(tx+tw-17, ly=ty+8, 4, 0); 
        
        lx=tx+tw-25; ly=ty+9; lw=17; lh=14;   
        rect(lx,ly,lw,lh, 0.1,0.1,0.1,1); 
        (mb && p_mb == 0 && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_locked_tab]=(mem[ui_locked_tab]==gui_t?-1:gui_t); 
            gmem[GM_BASE+1]=mem[ui_locked_tab]; 
            mem[ui_play_offset] = 0; 
            playback_shift = 0;  
        );
        (rmb && !p_rmb && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_edit_tab] = gui_t; 
            mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
        );
        mem[ui_locked_tab] == gui_t ? rect(lx+1,ly+2,lw-2,lh-3, 0.3,.9,.7,1);   
        (mem[ui_play_prog_tab] == gui_t) ? (gfx_set(1,.5 ,0,1); gfx_circle(tx+tw-17, ty+16, 4, 1););  
        mem[LOC_TAB_POPULATED + gui_t] ? (
            gfx_set(1, 1, 1, 1);
            gfx_rect(tx-1, ty-1, 4, 24);
            gfx_rect(tx-1, ty-2, 41, 4);
            gfx_rect(tx-1, ty+23, 21, 4);
        );
        tx+=tw;
    );
    gui_t+=1;
);

// =========================================================
// PATTERN SETTINGS NOW DRAW BELOW TABS
// =========================================================

row2_y = ty + 30; // Update Y for Pattern Settings to be below the Tabs

t_e = mem[ui_edit_tab];
(t_e == 0) ? (
    gfx_set(1, 0.2, 0.2, 1);
    gfx_setfont(1, "Arial", 48, 'b');
    gfx_x = (gfx_w/2) - 150; 
    gfx_y = (gfx_h/2) + 52; 
    gfx_drawstr("PATTERN OFF");
    gfx_setfont(1, "Arial", 18, 'b');
) : (
    // Unified pointers for edit tab
    curr_pat_v_ptr = vel_base + t_e*vel_stride_tab; 
    curr_pat_g_ptr = grid_base + t_e*vel_stride_tab; 
    curr_pat_l_ptr = step_len_base + t_e*vel_stride_tab; 

    bx = BTN_X0;
    extrascoot = 205;
    gfx_setfont(1, "Arial", 16, 'b');
    btn(bx-15+extrascoot, row2_y, BTN_W_COPY+21, "  COPY PATTERN") ? ( 
        memcpy(copy_tab_v_buf, curr_pat_v_ptr, vel_stride_tab); 
        memcpy(copy_tab_g_buf, curr_pat_g_ptr, vel_stride_tab); 
        memcpy(copy_tab_l_buf, curr_pat_l_ptr, vel_stride_tab);
        cp_valid = 1;
        cp_bars = eff_bars(mem[ui_edit_tab]);
        cp_sub = eff_sub(mem[ui_edit_tab]);
        cp_hum = eff_hum(mem[ui_edit_tab]);
        cp_sw = eff_swing(mem[ui_edit_tab]);
        cp_half = eff_half(mem[ui_edit_tab]);
    ); 
    bx += BTN_W_COPY + BTN_GAP;
    btn(bx+1+extrascoot, row2_y, BTN_W_PASTE+16, " PASTE PATTERN") ? ( 
        memcpy(curr_pat_v_ptr, copy_tab_v_buf, vel_stride_tab); 
        memcpy(curr_pat_g_ptr, copy_tab_g_buf, vel_stride_tab); 
        memcpy(curr_pat_l_ptr, copy_tab_l_buf, vel_stride_tab); 
        cp_valid ? (
            act_t = mem[ui_edit_tab];
            mem[bars_ov_base+act_t] = cp_bars;
            mem[subdiv_ov_base+act_t] = (cp_sub==8?0:cp_sub==12?1:cp_sub==16?2:cp_sub==24?3:4);
            mem[hum_ov_base+act_t] = cp_hum;
            mem[swing_ov_base+act_t] = cp_sw;
            mem[half_speed_ov_base+act_t] = cp_half;
            scan_active_tab();    
        );
    ); 
    bx += BTN_W_PASTE + BTN_GAP;
    btn(bx+12+extrascoot, row2_y, BTN_W_CLEAR+16, " CLEAR PATTERN") ? ( 
        memset(curr_pat_g_ptr, 0, vel_stride_tab); 
        memset(curr_pat_v_ptr, 0, vel_stride_tab); 
        memset(curr_pat_l_ptr, 0, vel_stride_tab);
        scan_active_tab();
    ); 
    bx += BTN_W_CLEAR + BTN_GAP;
    pat_lbl_x = bx; 
    gfx_set(0.8,0.8,0.8,1); 
    gfx_x = pat_lbl_x -482; 
    gfx_y = row2_y + 1; 
    gfx_drawstr("PATTERN SETTINGS:"); 
    pat_x = pat_lbl_x + PAT_LBL_W;
    pat_y = row2_y - 0; 
    box_w = PAT_BOX_W; 
    box_h = PAT_BOX_H; 
    gap_w = PAT_BOX_GAP;
    bars_x = pat_x; 
    active_tab = mem[ui_edit_tab]; 
    
    // Unified Override Access
    bars_addr = -1; 
    (active_tab > 0) ? ( bars_addr = bars_ov_base + active_tab; );
    
    curr_bars = eff_bars(active_tab); 
    rect(bars_x+37, pat_y, box_w+11, box_h, 0.2,0.2,0.2,1); 
    draw_text(bars_x+52, pat_y+2, "BARS:", 0.7,0.7,0.7); 
    sprintf(#s, "%d", curr_bars); 
    draw_text(bars_x+box_w+12, pat_y+2, #s, 1,1,1);
    bars_hit_l = bars_x + 71; 
    bars_hit_r = bars_x + box_w + 92; 
    (mx>=bars_hit_l && mx<bars_hit_r && my>=pat_y && my<pat_y+box_h && mb && p_mb==0) ? ( capture_id = 12; drag_accum = 0; );
    (mb && capture_id == 12) ? ( 
        drag_accum += (mx - p_mx); 
        abs(drag_accum) > 8 ? ( 
            step_dir = drag_accum > 0 ? 1 : -1; 
            drag_accum = 0; 
            target_addr = bars_addr; 
            (active_tab > 0 && target_addr >= 0) ? ( 
                mem[target_addr] <= 0 ? mem[target_addr] = slider4; 
                mem[target_addr] = clamp(mem[target_addr] + step_dir, 1, 4); 
            ); 
        ); 
    );
    sub_x = bars_x + box_w + gap_w; 
    ov_s = eff_sub(active_tab); 
    curr_s = (ov_s==8?0:ov_s==12?1:ov_s==16?2:ov_s==24?3:4);
    rect(sub_x-17, pat_y, box_w+11, box_h, 0.2,0.2,0.2,1); 
    rect(sub_x-17, pat_y, box_w+8, box_h, 0.2,0.2,0.2,1); 
    draw_text(sub_x-3, pat_y+2, "SUBDIV:", 0.7,0.7,0.7); 
    v=curr_s; v==0?strcpy(#s,"8"):v==1?strcpy(#s,"12"):v==2?strcpy(#s,"16"):v==3?strcpy(#s,"24"):strcpy(#s,"32"); 
    draw_text(sub_x+box_w-43, pat_y+2, #s, 1,1,1);
    sub_hit_l = sub_x -17 ; 
    sub_hit_r = sub_x + box_w; 
    (mx>=sub_hit_l && mx<sub_hit_r && my>=pat_y && my<pat_y+box_h && mb && p_mb==0) ? ( capture_id = 13; drag_accum = 0; );
    (mb && capture_id == 13) ? ( 
        drag_accum += (mx - p_mx); 
        abs(drag_accum) > 8 ? ( 
            step_dir = drag_accum > 0 ? 1 : -1; 
            drag_accum = 0; 
            target_addr = subdiv_ov_base + active_tab; 
            mem[target_addr] < 0 ? mem[target_addr] = slider3; 
            mem[target_addr] = clamp(mem[target_addr] + step_dir, 0, 4); 
        ); 
    );
    sw_x = sub_x + box_w + gap_w -47; 
    rect(sw_x-25, pat_y, box_w+55, box_h, 0.2,0.2,0.2,1); 
    draw_text(sw_x-12, pat_y+2, "SWING:", 0.7,0.7,0.7);
    sw_addr = -1; 
    (active_tab > 0) ? ( sw_addr = swing_ov_base + active_tab; );
    curr_sw = eff_swing(active_tab); 
    sprintf(#s, "%d%%", curr_sw); 
    is_sw_local = (sw_addr >= 0 && mem[sw_addr] >= 0);
    pl_x = sw_x + 55;
    rect(pl_x, pat_y, 15, 16, 0.2,0.2,0.2,1);
    is_sw_local ? draw_text(pl_x-4, pat_y+2, "M", 1,0.5,0) : draw_text(pl_x-4, pat_y+2, "P", 0,1,1);
    (mb && p_mb==0 && mx>=pl_x-12 && mx<pl_x+15 && my>=pat_y-1 && my<pat_y-1+box_h) ? (
        is_sw_local ? ( mem[sw_addr] = -1; ) : ( mem[sw_addr] = clamp(eff_swing(active_tab), 0, 100); )
    );
    draw_text(sw_x+box_w-20, pat_y+2, #s, 1,1,1);
    sw_hit_l = pl_x + 15; 
    sw_hit_r = sw_x + box_w +15;
    (mb && p_mb==0 && mx>=sw_hit_l && mx<sw_hit_r && my>=pat_y && my<pat_y+box_h) ? (
        (is_sw_local) ? (
            capture_id = 12012;
            capture_min = 0;
            capture_max = 100;
            capture_is_signed = 0;
            sw_addr >= 0 ? (
                mem[sw_addr] < 0 ? mem[sw_addr] = clamp(eff_swing(active_tab), 0, 100);
                capture_ptr = sw_addr;
                capture_slider_idx = 0;
            );
        );
    );
    (mb && capture_id == 12012) ? ( 
        d_delta = (mx - p_mx); 
        mv = mem[capture_ptr]; 
        nv = clamp(mv + d_delta, 0, 100); 
        mem[capture_ptr] = nv; 
    ); 
    hum_x = sw_x + box_w + gap_w; 
    dr_glob(11, hum_x-36, pat_y, box_w+11, "HUMANIZE:", slider2, 0, 25, 0, 0, hum_ov_base, 1, 2);
    curr_sub_val = eff_sub(mem[ui_edit_tab]);
    st_v = eff_bars(mem[ui_edit_tab]) * curr_sub_val; // Re-calc stride for later use
    st_x = hum_x + box_w + gap_w; 
    (curr_sub_val == 24 || curr_sub_val == 32) ? (
        hf_x = st_x-30; 
        st_x = hf_x + 14 + gap_w; 
        hf_act = eff_half(mem[ui_edit_tab]);
        (mb && p_mb == 0 && mx>=hf_x-60 && mx<hf_x+20 && my>=pat_y && my<pat_y+box_h) ? (
            t_addr = half_speed_ov_base + mem[ui_edit_tab];
            mem[t_addr] = !mem[t_addr];
        );
        rect(hf_x-61, pat_y, 86, box_h, 0.2, 0.2, 0.2, 1);
        !hf_act ? ( gfx_set(0.6, 0.6, 0.6, 1); gfx_rect(hf_x-61, pat_y, 43, box_h); ); 
        hf_act  ? ( gfx_set(0.6, 0.6, 0.6, 1); gfx_rect(hf_x-16, pat_y, 43, box_h); ); 
        !hf_act ? gfx_set(0,0,0,1) : gfx_set(0.5,0.5,0.5,1);
        draw_text(hf_x-48, pat_y+2, "1x", 0,0,0); 
        hf_act ? gfx_set(0,0,0,1) : gfx_set(0.5,0.5,0.5,1);
        draw_text(hf_x-7, pat_y+2, "1/2", 0,0,0);
        gfx_set(0,0,0,1); 
        gfx_line(hf_x-18, pat_y, hf_x-18, pat_y+box_h);
    );
    btn(st_x-54, pat_y+1, 86, "  STRETCH") ? ( 
        gfx_x = st_x; 
        gfx_y = pat_y + 20;
        sel_stretch = gfx_showmenu("Stretch Pattern 2x (Short)|Stretch Pattern 2x (Long)|Stretch Pattern 4x (Short)|Stretch Pattern 4x (Long)||Stretch Selected Row 2x (Short)|Stretch Selected Row 2x (Long)|Stretch Selected Row 4x (Short)|Stretch Selected Row 4x (Long)");
        sel_stretch > 0 ? (
            (sel_stretch <= 4) ? ( is_pattern = 1; base_s = sel_stretch; ) : ( is_pattern = 0; base_s = sel_stretch - 4; );
            factor = (base_s <= 2) ? 2 : 4;
            is_long = (base_s == 2 || base_s == 4);
            st_cnt = eff_bars(mem[ui_edit_tab]) * curr_sub_val;
            r_start = is_pattern ? 0 : mem[ui_selected_row];
            r_end = is_pattern ? MAX_ROWS : mem[ui_selected_row] + 1;
            basev = vel_base + mem[ui_edit_tab]*vel_stride_tab;
            baseg = grid_base + mem[ui_edit_tab]*vel_stride_tab;
            basel = step_len_base + mem[ui_edit_tab]*vel_stride_tab;
            r_iter = r_start;
            loop(r_end - r_start,
                row_offset = r_iter * vel_stride_row;
                memcpy(copy_row_v_buf, basev + row_offset, st_cnt);
                memcpy(copy_row_g_buf, baseg + row_offset, st_cnt);
                memcpy(copy_row_l_buf, basel + row_offset, st_cnt);
                memset(basev + row_offset, 0, st_cnt);
                memset(baseg + row_offset, 0, st_cnt);
                memset(basel + row_offset, 0, st_cnt);
                s_idx = 0; 
                loop_limit = ceil(st_cnt / factor);
                loop(loop_limit,
                    target_idx = s_idx * factor;
                    (target_idx < st_cnt) ? (
                        mem[basev + row_offset + target_idx] = mem[copy_row_v_buf + s_idx];
                        mem[baseg + row_offset + target_idx] = mem[copy_row_g_buf + s_idx];
                        raw_len = mem[copy_row_l_buf + s_idx];
                        new_len = raw_len;
                        is_long ? ( new_len = (raw_len < 1 ? 1 : raw_len) * factor; );
                        mem[basel + row_offset + target_idx] = new_len;
                    );
                    s_idx += 1;
                );
                r_iter += 1;
            );
        );
    );

    // Set ty for the Grid to continue below settings
    ty = row2_y;
);

(t_e != 0) ? (
    t_e = mem[ui_edit_tab]; 
    sel_r = mem[ui_selected_row]; 
    sel_r >= MAX_ROWS ? (sel_r = MAX_ROWS - 1; mem[ui_selected_row] = sel_r;);
    ty+=25; 
    pk_w = (gfx_w-20)/128; 
    rect(10, ty, gfx_w-20, 32, 0.02, 0.02, 0.02, 1);
    i_p=0; 
    loop(128,
        px=10+i_p*pk_w; 
        m=i_p%12; 
        is_blk=(m==1||m==3||m==6||m==8||m==10); 
        is_sel = (mem[row_note_base+sel_r] == i_p);
        is_blk ? ( 
            is_sel ? rect(px, ty, pk_w-1, 30, 0.22, 0.52, 0.64, 1) : rect(px, ty, pk_w-1, 30, 0.2, 0.2, 0.2, 1);
        ) : ( 
            is_sel ? rect(px, ty, pk_w-1, 30, 0.46, 0.78, 0.88, 1) : rect(px, ty, pk_w-1, 30, 0.8, 0.8, 0.8, 1);
        );
        is_hover = (mx>=px && mx<px+pk_w && my>=ty && my<ty+32);
        (mb && is_hover && (p_mb == 0 || last_preview_note != i_p)) ? ( 
            mem[row_note_base+sel_r]=i_p; 
            preview_note = i_p; 
            preview_chan = mem[row_chan_base+sel_r]; 
            preview_vel = 100; 
            preview_trig = 1; 
            last_preview_note = i_p; 
        );
        i_p+=1;
    );
    mb == 0 ? last_preview_note = -1;
    ty+=38; 
    upser = 5;
    gfx_setfont(1, "Arial", 16, 'b');
    draw_text(10, ty-upser, "DRUM:", 0.7,0.7,0.7); 
    strlen(row_name_str_base + sel_r * str_size) > 0 ? (
        strcpy(#dn_cur, row_name_str_base + sel_r * str_size);
    ) : (
        get_d_name(mem[row_name_idx+sel_r], #dn_cur); 
    );
    set_ui_color(mem[row_color_base+sel_r]); 
    gfx_x=65; 
    gfx_y=ty-upser; 
    gfx_drawstr(#dn_cur);
    (rmb && mx>=65 && mx<160 && my>=ty && my<ty+20) ? ( 
        sel = gfx_showmenu(#name_menu); 
        sel > 0 ? ( 
            mem[row_name_idx+sel_r] = sel-1; 
            strcpy(row_name_str_base + sel_r, ""); 
        ) 
    );
    dr_p(270, ty-upser, "NOTE:", row_note_base+sel_r, 0, 127, 85);
    dr_p(440, ty-upser, "CHAN:", row_chan_base+sel_r, 1, 16, 75); 
    dr_p(610, ty-upser, "LENG:", row_len_base+sel_r, 0, 127, 75); 
    dr_p(780, ty-upser, "LEVEL:",row_level_base+sel_r, 0, 100, 85);
    dr_p(980, ty-upser, "HUM:", row_human_base+sel_r, -1, 100, 75);
    dr_p(1180, ty-upser, "PUSH/PULL:", row_offs_base+sel_r, -50, 60, 125); 
    
    gr_max = mem[LOCAL_GROOVE_DB + 32];
    gr_x = 1242; 
    gr_y = ty-118;
    gfx_set(0.7, 0.7, 0.7, 1);
    gfx_x = gr_x + -20; 
    gfx_y = gr_y - 62; 
    gfx_drawstr("GRV:");
    gr_max == 0 ? gfx_set(0.7 ,0.7 ,0.7, 1) : (gr_max > 1.0 ? gfx_set(1, 0, 0, 1) : gfx_set(0, 1, 0, 1));
    gfx_circle(gr_x+21, gr_y-54, 4, 1);

    ty+=12; 
    s_v=eff_sub(t_e); 
    st_v=eff_bars(t_e)*s_v;
    playing_tab = (mem[ui_locked_tab] <= 0) ? mem[ui_play_prog_tab] : mem[ui_locked_tab];
    (play_state & 1 && playing_tab == t_e) ? ( 
        vis_beat = calc_vis_beat(t_e); 
        play_step_idx = floor(vis_beat * (s_v/4)); 
    ) : play_step_idx = -1;

    btn(10, ty+2, 95, "  Copy Row") ? ( 
        memcpy(copy_row_v_buf, curr_pat_v_ptr + sel_r*vel_stride_row, MAX_STEPS); 
        memcpy(copy_row_g_buf, curr_pat_g_ptr + sel_r*vel_stride_row, MAX_STEPS); 
        memcpy(copy_row_l_buf, curr_pat_l_ptr + sel_r*vel_stride_row, MAX_STEPS); 
    );
    btn(10, ty+26, 95, "  Paste Row") ? ( 
        memcpy(curr_pat_v_ptr + sel_r*vel_stride_row, copy_row_v_buf, MAX_STEPS); 
        memcpy(curr_pat_g_ptr + sel_r*vel_stride_row, copy_row_g_buf, MAX_STEPS); 
        memcpy(curr_pat_l_ptr + sel_r*vel_stride_row, copy_row_l_buf, MAX_STEPS);
        scan_active_tab();
    );
    btn(130, ty+28, 35, "ALL") ? ( mem[ui_vel_edit_all] = !mem[ui_vel_edit_all]; );
    mem[ui_vel_edit_all] ? ( 
        gfx_set(1, 0.8, 0.2, 1); 
        gfx_rect(130, ty+28, 35, 18); 
        gfx_set(0,0,0,1); 
        gfx_x=135;
        gfx_y=ty+30; 
        gfx_drawstr("ALL"); 
    );
    btn(10, ty+50, 95, "  Clear Row") ? ( 
        memset(curr_pat_g_ptr + sel_r*vel_stride_row, 0, MAX_STEPS); 
        memset(curr_pat_v_ptr + sel_r*vel_stride_row, 0, MAX_STEPS); 
        memset(curr_pat_l_ptr + sel_r*vel_stride_row, 0, MAX_STEPS);
        scan_active_tab();
    );

    gx_s=220; 
    sb_w = 20; 
    gx_w = gfx_w - gx_s - sb_w - 5; 
    cw_v=gx_w/st_v;
    
    def_w = 28; 
    def_x = gx_s - def_w - 4; 
    def_h = 70;
    rect(def_x, ty, def_w, def_h, 0.2, 0.2, 0.2, 1);
    gfx_set(0.08, 0.4, 0.4, 1);
    val_h = floor((slider1 / 127) * (def_h - 2));
    val_h < 2 ? val_h = 2;
    gfx_rect(def_x + 1, ty + def_h - val_h - 1, def_w - 2, val_h);
    gfx_set(1, 1, 1, 0.8);
    gfx_x = def_x + 3; 
    gfx_y = ty ; 
    gfx_drawstr("DEF");
    sprintf(#dv, "%d", slider1);
    gfx_x = def_x + 3; 
    gfx_y = ty + def_h - 15; 
    gfx_drawstr(#dv);
    (mb && mx >= def_x && mx < def_x + def_w && my >= ty && my < ty + def_h && capture_id == 0) ? ( capture_id = 11111; );
    (capture_id == 11111) ? (
        new_val = 127 - floor( ( (my - ty) / def_h ) * 127 );
        new_val = clamp(new_val, 1, 127);
        slider1 = new_val;
        slider_automate(slider1);
        i_rst = 0;
        loop(MAX_ROWS * MAX_STEPS,
             mem[curr_pat_g_ptr + i_rst] == 0 ? mem[curr_pat_v_ptr + i_rst] = 0;
             i_rst += 1;
        );
    );

    rect(gx_s, ty, gx_w, 70, 0.2, 0.2, 0.2, 1);
    !mb ? vel_drag_mods = 0;

    (rmb && capture_id == 88888) ? (
         abs_cell = len_drag_cell_idx;
         row_idx = floor(abs_cell / vel_stride_row);
         row_base = row_idx * vel_stride_row;
         step_idx = abs_cell % vel_stride_row; 
         head_x = gx_s + (step_idx * cw_v);
         dist_pixels = mx - head_x;
         raw_l = ceil(dist_pixels / cw_v);
         raw_l < 1 ? raw_l = 1;
         drag_mods = 0; 
         ctrl_dn ? drag_mods |= 1; 
         shift_dn ? drag_mods |= 2;
         beat_steps = s_v / 4; 
         total_bars = st_v / s_v; 
         step_in_bar = step_idx % s_v;
         step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
         bar_idx = floor(step_idx / s_v);
         drag_mods == 0 ? (
             local_max = st_v - step_idx;
             final = raw_l > local_max ? local_max : raw_l;
             mem[curr_pat_l_ptr + row_base + step_idx] = final;
         ) : (drag_mods == 1) ? ( 
             bb=0; loop(total_bars, 
                 tgt = bb*s_v + step_in_bar; 
                 tgt < st_v ? (
                    local_max = st_v - tgt;
                    final = raw_l > local_max ? local_max : raw_l;
                    mem[curr_pat_l_ptr + row_base + tgt] = final;
                    mem[curr_pat_g_ptr + row_base + tgt] = 1; 
                 );
                 bb+=1; 
             );
         ) : (drag_mods == 2) ? ( 
             bt=0; loop(4, 
                 tgt = bar_idx*s_v + bt*beat_steps + step_in_beat;
                 (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? (
                    local_max = st_v - tgt;
                    final = raw_l > local_max ? local_max : raw_l;
                    mem[curr_pat_l_ptr + row_base + tgt] = final;
                    mem[curr_pat_g_ptr + row_base + tgt] = 1;
                 );
                 bt+=1;
             );
         ) : ( 
             bb=0; loop(total_bars,
                 bt=0; loop(4,
                     tgt = bb*s_v + bt*beat_steps + step_in_beat;
                     tgt < st_v ? (
                        local_max = st_v - tgt;
                        final = raw_l > local_max ? local_max : raw_l;
                        mem[curr_pat_l_ptr + row_base + tgt] = final;
                        mem[curr_pat_g_ptr + row_base + tgt] = 1;
                     );
                     bt+=1;
                 );
                 bb+=1;
             );
         );
    );

    all_mode = mem[ui_vel_edit_all];
    all_preview_v = clamp(floor((1-(my-ty)/70)*127), 1, 127);
    skip_vel_draw = 0;
    active_note_idx = -1; 

    s_i=0; 
    loop(st_v,
        idx_v = sel_r*vel_stride_row + s_i;
        all_mode ? (
            vx_L = gx_s + s_i*cw_v;
            is_col_hover = (mx >= vx_L && mx < vx_L + cw_v);
            is_in_vel_box = (my >= ty && my < ty+70);
            v_store = mem[curr_pat_v_ptr + idx_v];
            def_v = (v_store > 0) ? v_store : slider1;
            v_disp = (mb && capture_id == 77777 && is_col_hover && is_in_vel_box) ? all_preview_v : def_v;
            bar_h = floor((v_disp/127) * 68); 
            bar_h < 2 ? bar_h = 2;
            rect(vx_L, ty+70-bar_h, cw_v-1, bar_h, 0.3, 0.3, 0.3, 1);
        ) : (
            skip_vel_draw > 0 ? ( skip_vel_draw -= 1; ) : (
                g_on = mem[curr_pat_g_ptr+idx_v];
                step_len = mem[curr_pat_l_ptr+idx_v];
                draw_w = cw_v;
                step_len > 1 ? ( draw_w = cw_v * step_len; skip_vel_draw = step_len - 1; );
                v_store = mem[curr_pat_v_ptr+idx_v];
                v_disp = (v_store > 0) ? v_store : slider1;
                bar_h = floor((v_disp/127) * 68); 
                bar_h < 2 ? bar_h = 2;
                c_idx = mem[row_color_base+sel_r]; 
                get_palette_values(c_idx);
                g_on ? (
                    min_b = (c_idx == 0) ? 0.60 : 0.50; 
                    rng_b = 1.0 - min_b;
                    v_scale = min_b + (rng_b * (v_disp / 127));
                    (play_step_idx == s_i) ? (
                        gfx_set(1, 1, 1, 0.95);
                    ) : (
                        gfx_set(cr * v_scale, cg * v_scale, cb * v_scale, 1);
                    );
                    gfx_rect(gx_s+s_i*cw_v, ty+70-bar_h, draw_w-1, bar_h);
                ) : (
                    rect(gx_s+s_i*cw_v, ty+70-bar_h, cw_v-1, bar_h, 0.3, 0.3, 0.3, 1);
                );
            );
        );
        vx_L = gx_s+s_i*cw_v; 
        vx_R = vx_L+cw_v;
        is_col_hover = (mx >= vx_L && mx < vx_R);
        is_box_hover = (is_col_hover && my >= ty && my < ty+70);
        (mb && p_mb == 0 && is_box_hover && capture_id == 0) ? ( capture_id = 77777; );
        do_update = 0;
        (capture_id == 77777 && mb && is_col_hover) ? do_update = 1; 
        (capture_id == 0 && mb && is_box_hover) ? do_update = 1;     
        do_update ? (
            p_mb == 0 ? ( 
                vel_drag_mods = 0; 
                ctrl_dn ? vel_drag_mods |= 1; 
                shift_dn ? vel_drag_mods |= 2; 
            );
            new_v = floor((1-(my-ty)/70)*127); 
            new_v < 1 ? new_v = 1 : new_v > 127 ? new_v = 127;
            beat_steps = s_v/4; 
            total_bars = st_v / s_v; 
            step_idx = s_i; 
            step_in_bar = step_idx % s_v; 
            step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
            bar_idx = floor(step_idx / s_v);
            vel_drag_mods == 0 ? ( 
                mem[ui_vel_edit_all] ? (
                    r_it = 0; 
                    loop(MAX_ROWS,
                        mem[curr_pat_v_ptr + r_it*vel_stride_row + s_i] = new_v;
                        r_it+=1;
                    );
                ) : (
                    mem[curr_pat_v_ptr + idx_v] = new_v; 
                );
            ) : (vel_drag_mods == 1) ? ( 
                bb=0; 
                loop(total_bars, 
                    tgt = bb*s_v + step_in_bar; 
                    tgt < st_v ? ( 
                        i2 = sel_r*vel_stride_row + tgt; 
                        mem[curr_pat_v_ptr + i2] = new_v; 
                    ); 
                    bb+=1; 
                ); 
            ) : (vel_drag_mods == 2) ? ( 
                bt=0; 
                loop(4, 
                    tgt = bar_idx*s_v + bt*beat_steps + step_in_beat; 
                    (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? ( 
                        ii = sel_r*vel_stride_row + tgt; 
                        mem[curr_pat_v_ptr+ii] = new_v; 
                    ); 
                    bt+=1; 
                ); 
            ) : ( 
                bb=0; 
                loop(total_bars, 
                    bt=0; 
                    loop(4, 
                        tgt = bb*s_v + bt*beat_steps + step_in_beat; 
                        tgt < st_v ? ( 
                            ii = sel_r*vel_stride_row + tgt; 
                            mem[curr_pat_v_ptr+ii] = new_v; 
                        ); 
                        bt+=1; 
                    ); 
                    bb+=1; 
                ); 
            ); 
        ); 
        s_i+=1;
    );

    ruler_h = 15; 
    gap_h = 2;
    ruler_y = ty + 72;
    grid_y = ruler_y + ruler_h + gap_h;
    row_h = grid_height;
    is_half = eff_half(t_e);
    raw_steps_per_bar = st_v / eff_bars(t_e);
    vis_steps_per_bar = is_half ? (raw_steps_per_bar / 2) : raw_steps_per_bar;
    vis_bar_w = cw_v * vis_steps_per_bar;
    bar_count = eff_bars(t_e) * (is_half ? 2 : 1);
    b_idx = 0;
    loop(bar_count,
        bx = gx_s + b_idx * vis_bar_w;
        rect(bx, ruler_y, vis_bar_w-1, ruler_h, 0.5, 0.5, 0.5, 1);
        sprintf(#bnum, "%d", b_idx + 1);
        draw_text(bx + 1, ruler_y + 2, #bnum, 1.0, 1.0, 1.0);
        (mb && p_mb == 0 && mx >= bx && mx < bx + vis_bar_w && my >= ruler_y && my < ruler_y + ruler_h) ? (
            gfx_x = mx; 
            gfx_y = my;
            sel_menu = gfx_showmenu("Copy Bar|Paste Bar|Clear Bar");
            op_len = vis_steps_per_bar;
            op_start = b_idx * op_len;
            sel_menu == 1 ? ( 
                r_it = 0; 
                loop(MAX_ROWS,
                    src_offset = r_it * vel_stride_row + op_start;
                    dst_offset = r_it * 96;
                    memcpy(bar_copy_base + dst_offset, curr_pat_v_ptr + src_offset, op_len);
                    memcpy(bar_copy_base + dst_offset + 32, curr_pat_g_ptr + src_offset, op_len);
                    memcpy(bar_copy_base + dst_offset + 64, curr_pat_l_ptr + src_offset, op_len);
                    r_it += 1;
                );
            );
            sel_menu == 2 ? ( 
                r_it = 0; 
                loop(MAX_ROWS,
                    src_offset = r_it * 96;
                    dst_offset = r_it * vel_stride_row + op_start;
                    memcpy(curr_pat_v_ptr + dst_offset, bar_copy_base + src_offset, op_len);
                    memcpy(curr_pat_g_ptr + dst_offset, bar_copy_base + src_offset + 32, op_len);
                    memcpy(curr_pat_l_ptr + dst_offset, bar_copy_base + src_offset + 64, op_len);
                    r_it += 1;
                );
            );
            sel_menu == 3 ? ( 
                r_it = 0; 
                loop(MAX_ROWS,
                    dst_offset = r_it * vel_stride_row + op_start;
                    memset(curr_pat_v_ptr + dst_offset, 0, op_len);
                    memset(curr_pat_g_ptr + dst_offset, 0, op_len);
                    memset(curr_pat_l_ptr + dst_offset, 0, op_len);
                    r_it += 1;
                );
            );
        );
        b_idx += 1;
    );

    !mb ? (
        last_drag_idx = -1;
        drag_mods = 0;
        vel_drag_mods = 0;
        drag_mode = 0;
        capture_id = 0;
        drag_lock_row = -1;
        len_drag_active = 0;
        row_drag_active = 0;
        row_drag_last_y = 0;
        row_drag_anchor = -1;
    );

    rows_that_fit = floor((gfx_h - grid_y) / row_h);
    visible_rows = min(slider7, rows_that_fit);
    visible_rows < 1 ? visible_rows = 1; 
    scroll_val = slider8; 
    max_scroll = MAX_ROWS - visible_rows; 
    max_scroll < 0 ? max_scroll = 0;
    scroll_val > max_scroll ? (scroll_val = max_scroll; slider8 = max_scroll;);
    sb_w = 20; 
    sb_x = gfx_w - sb_w - 2; 
    sb_y = grid_y; 
    sb_h = visible_rows * row_h;
    handle_h_pct = visible_rows / MAX_ROWS; 
    handle_h = sb_h * handle_h_pct; 
    handle_h < 15 ? handle_h = 15;
    available_track = sb_h - handle_h; 
    available_track < 1 ? available_track = 1; 
    scroll_pct = (max_scroll > 0) ? (scroll_val / max_scroll) : 0; 
    handle_y = sb_y + (scroll_pct * available_track);
    is_sb_hover = (mx >= sb_x && mx < sb_x + sb_w && my >= sb_y && my < sb_y + sb_h); 
    is_sb_drag = (capture_id == 9999);
    (mb && p_mb == 0 && is_sb_hover) ? ( 
        capture_id = 9999; 
        scrollbar_drag_y_offset = my - handle_y; 
    );
    (mb && capture_id == 9999) ? ( 
        target_y = my - scrollbar_drag_y_offset; 
        rel_y = target_y - sb_y; 
        new_pct = rel_y / available_track; 
        new_val = floor(new_pct * max_scroll + 0.5); 
        new_val = clamp(new_val, 0, max_scroll); 
        slider8 = new_val; 
    );
    scroll_offset = slider8;
    row_drag_active = row_drag_active; 
    row_drag_last_y = row_drag_last_y; 
    row_drag_anchor = row_drag_anchor;
    row_drag_x0 = 60; 
    row_drag_x1 = gx_s - 5;      

    gfx_set(0,0,0,1); 
    gfx_rect(0, grid_y, gfx_w, gfx_h - grid_y);
    r_v = 0; 
    gfx_setfont(0);
    loop(visible_rows,
        r_g = r_v + scroll_offset; 
        ry = grid_y + r_v*row_h;
        r_g==sel_r ? 
            rect(10, ry, gx_w+gx_s-10, row_h-1, 0.12, 0.12, 0.12, 1) : 
            rect(10, ry, gx_w+gx_s-10, row_h-1, 0, 0, 0, 1);
        mem[row_mute_base+r_g]?
            draw_text(15,ry+3,"M",1,0,0):
            draw_text(15,ry+3,"M",0.4,0.4,0.4);
        mem[row_solo_base+r_g]?
            draw_text(32,ry+3,"S",0,1,1):
            draw_text(32,ry+3,"S",0.4,0.4,0.4);
        STRING_SLOT_ID = row_name_str_base + r_g; 
        strlen(STRING_SLOT_ID) > 0 ? ( strcpy(#gn_row, STRING_SLOT_ID); ) : ( get_d_name(mem[row_name_idx+r_g], #gn_row); );
        set_ui_color(mem[row_color_base+r_g]); 
        gfx_x=53; 
        gfx_y=ry+6; 
        gfx_circle(gfx_x, gfx_y, 4, 1); 
        gfx_x=65; 
        gfx_y=ry+3; 
        gfx_drawstr(#gn_row);
        (mb && p_mb==0 && mx>=65 && mx<165 && my>=ry+3 && my<ry+18) ? ( 
            preview_note = mem[row_note_base+r_g]; 
            preview_chan = mem[row_chan_base+r_g]; 
            preview_vel = 100; 
            preview_trig = 1; 
            mem[ui_selected_row] = r_g; 
            mem[ui_vel_edit_all] = 0; 
        ); 
        (mb && p_mb==0 && mx>=48 && mx<58 && my>=ry+1 && my<ry+11) ? ( 
            color_popup_active = 1; 
            color_popup_x = mx; 
            color_popup_y = my; 
            color_popup_row = r_g; 
        );
        (rmb && mx>=60 && mx<gx_s && my>=ry && my<ry+row_h) ? ( 
            c_sel = gfx_showmenu(#name_menu); 
            c_sel > 0 ? ( 
                mem[row_name_idx+r_g] = c_sel-1; 
                strcpy(STRING_SLOT_ID, ""); 
            ); 
        );
        (mb && p_mb == 0 && capture_id == 0 && !color_popup_active && mx<gx_s && my>=ry && my<ry+row_h && !rmb && !(mx>=48 && mx<58) && !(mx>=65 && mx<165)) ? ( 
            mx<28 ? mem[row_mute_base+r_g] = !mem[row_mute_base+r_g] : 
            mx<45 ? mem[row_solo_base+r_g] = !mem[row_solo_base+r_g] : 
            ( 
                mem[ui_selected_row] = r_g; 
                mem[ui_vel_edit_all] = 0;
            ); 
        );
        (mb && p_mb==0 && !ui_lock && mx>=row_drag_x0 && mx<row_drag_x1 && my>=ry && my<ry+row_h && !rmb && (mouse_cap & 16)) ? ( 
            row_drag_active = 1; 
            row_drag_last_y = my; 
            row_drag_anchor = r_g; 
            capture_id = 42424; 
        );
        (mb && capture_id == 42424 && row_drag_active) ? ( 
            dy = my - row_drag_last_y; 
            abs(dy) >= (row_h*0.5) ? ( 
                dir = dy > 0 ? 1 : -1; 
                tgt = row_drag_anchor + dir; 
                (tgt >= 0 && tgt < MAX_ROWS) ? ( 
                    swap_rows(row_drag_anchor, tgt); 
                    row_drag_anchor = tgt; 
                    row_drag_last_y = my; 
                ) : ( 
                    row_drag_last_y = my; 
                ); 
            ); 
        );
        get_palette_values(mem[row_color_base+r_g]); 
        memset(ownership_map, -1, MAX_STEPS); 
        s_i = 0; 
        loop(st_v, 
            idx_v = r_g*vel_stride_row + s_i; 
            mem[curr_pat_g_ptr+idx_v] ? ( 
                l = mem[curr_pat_l_ptr+idx_v]; 
                l < 1 ? l = 1; 
                k = 0; 
                loop(l, 
                    (s_i + k < st_v) ? ( mem[ownership_map + s_i + k] = idx_v; ); 
                    k+=1; 
                ); 
            ); 
            s_i+=1; 
        );
        s_i=0; 
        loop(st_v,
            idx_v = r_g*vel_stride_row + s_i; 
            cx_g = gx_s + s_i*cw_v; 
            owner_idx = mem[ownership_map + s_i];
            is_head = (owner_idx == idx_v); 
            is_tail = (owner_idx != -1 && owner_idx != idx_v); 
            is_empty = (owner_idx == -1); 
            is_head ? (
                step_len = mem[curr_pat_l_ptr+idx_v]; 
                draw_w = cw_v;
                step_len > 1 ? ( draw_w = cw_v * step_len; );
                v_store = mem[curr_pat_v_ptr+idx_v]; 
                v_disp = (v_store>0?v_store:slider1);
                c_idx = mem[row_color_base+r_g];
                get_palette_values(c_idx); 
                min_b = (c_idx == 0) ? 0.60 : 0.50;
                rng_b = 1.0 - min_b;
                v_scale = min_b + (rng_b * (v_disp / 127)); 
                (play_step_idx == s_i) ? (
                    gfx_set(1, 1, 1, 0.95); 
                ) : (
                    gfx_set(cr*v_scale, cg*v_scale, cb*v_scale, 1); 
                );
                gfx_rect(cx_g, ry+1, draw_w-1, row_h-3);
            ) : is_empty ? (
                q_div = s_v/4; 
                e_div = s_v/8;
                one_brite = .5;
                (s_i % s_v == 0) ? rect(cx_g, ry+1, cw_v-1, row_h-3, 0.20*one_brite, 1*one_brite, 1*one_brite, .8)
                : (s_i % q_div == 0) ? rect(cx_g, ry+1, cw_v-1, row_h-3, 0.30, 0.30, 0.30, 1) 
                : (s_v == 32 && (s_i % e_div == 0)) ? rect(cx_g, ry+1, cw_v-1, row_h-3, .08, .08, .08, 1) 
                : rect(cx_g, ry+1, cw_v-1, row_h-3, 0.15, 0.15, 0.15, 1);
            );
            (mb && mx>=cx_g && mx<cx_g+cw_v && my>=ry && my<ry+row_h && capture_id == 0) ? (
                drag_lock_row == -1 ? drag_lock_row = r_g;
                (r_g == drag_lock_row && !is_tail) ? (
                    cell_id = r_g*1000 + s_i;
                    p_mb == 0 ? ( 
                        drag_mode = mem[curr_pat_g_ptr+idx_v] ? 2 : 1; 
                        drag_mods = 0; 
                        ctrl_dn ? drag_mods |= 1; 
                        shift_dn ? drag_mods |= 2; 
                    );
                    (cell_id != last_drag_idx) ? (
                        beat_steps = s_v/4; 
                        total_bars = st_v / s_v; 
                        step_idx = s_i; 
                        step_in_bar = step_idx % s_v; 
                        step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
                        bar_idx = floor(step_idx / s_v);
                        drag_mods == 0 ? ( 
                            drag_mode == 1 ? ( 
                                mem[curr_pat_g_ptr+idx_v] = 1; 
                                mem[curr_pat_l_ptr+idx_v] = 0;
                                mem[curr_pat_v_ptr+idx_v] <= 0 ? mem[curr_pat_v_ptr+idx_v] = slider1; 
                            ) : ( 
                                mem[curr_pat_g_ptr+idx_v] = 0; 
                                mem[curr_pat_v_ptr+idx_v] = 0; 
                                mem[curr_pat_l_ptr+idx_v] = 0; 
                            ); 
                        ) : (drag_mods == 1) ? ( 
                            bb=0; 
                            loop(total_bars, 
                                tgt = bb*s_v + step_in_bar; 
                                tgt < st_v ? ( 
                                    ii = r_g*vel_stride_row + tgt; 
                                    drag_mode == 1 ? ( 
                                        mem[curr_pat_g_ptr+ii] = 1; 
                                        mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; 
                                    ) : ( 
                                        mem[curr_pat_g_ptr+ii] = 0; 
                                        mem[curr_pat_v_ptr+ii] = 0; 
                                        mem[curr_pat_l_ptr+ii] = 0; 
                                    ); 
                                ); 
                                bb+=1; 
                            ); 
                        ) : (drag_mods == 2) ? ( 
                            bt=0; 
                            loop(4, 
                                tgt = bar_idx*s_v + bt*beat_steps + step_in_beat; 
                                (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? ( 
                                    ii = r_g*vel_stride_row + tgt; 
                                    drag_mode == 1 ? ( 
                                        mem[curr_pat_g_ptr+ii] = 1; 
                                        mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; 
                                    ) : ( 
                                        mem[curr_pat_g_ptr+ii] = 0; 
                                        mem[curr_pat_v_ptr+ii] = 0; 
                                        mem[curr_pat_l_ptr+ii] = 0; 
                                    ); 
                                ); 
                                bt+=1; 
                            ); 
                        ) : ( 
                            bb=0; 
                            loop(total_bars, 
                                bt=0; 
                                loop(4, 
                                    tgt = bb*s_v + bt*beat_steps + step_in_beat; 
                                    tgt < st_v ? ( 
                                        ii = r_g*vel_stride_row + tgt; 
                                        drag_mode == 1 ? ( 
                                            mem[curr_pat_g_ptr+ii] = 1; 
                                            mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; 
                                        ) : ( 
                                            mem[curr_pat_g_ptr+ii] = 0; 
                                            mem[curr_pat_v_ptr+ii] = 0; 
                                            mem[curr_pat_l_ptr+ii] = 0; 
                                        ); 
                                    ); 
                                    bt+=1; 
                                ); 
                                bb+=1; 
                            ); 
                        );
                        mem[ui_selected_row] = r_g; 
                        last_drag_idx = cell_id;
                    );
                );
            );
            (rmb && mx>=cx_g && mx<cx_g+cw_v && my>=ry && my<ry+row_h && capture_id == 0) ? (
                target_head = -1; 
                owner_idx != -1 ? ( 
                    target_head = owner_idx; 
                    is_clicked_head = (mem[curr_pat_g_ptr + idx_v] != 0); 
                    is_clicked_head && !ctrl_dn ? ( 
                        under = find_covering_head(r_g, s_i, st_v); 
                        under != -1 ? target_head = under; 
                    ); 
                ) : ( 
                    target_head = idx_v; 
                    mem[curr_pat_g_ptr + target_head] = 1; 
                    mem[curr_pat_v_ptr + target_head] <= 0 ? mem[curr_pat_v_ptr + target_head] = slider1; 
                    mem[curr_pat_l_ptr + target_head] = 1; 
                );
                capture_id = 88888; 
                len_drag_active = 1; 
                len_drag_cell_idx = target_head; 
                head_pos = target_head % st_v; 
                len_drag_max = st_v - head_pos;
            );
            s_i+=1;
        );
        r_v+=1;
    );
    
    gfx_set(0.15, 0.15, 0.15, 1);
    gfx_rect(sb_x, sb_y, sb_w, sb_h);
    is_sb_drag || is_sb_hover ? gfx_set(0.6, 0.6, 0.6, 1) : gfx_set(0.35, 0.35, 0.35, 1);
    draw_h = handle_h; 
    draw_y = handle_y;
    draw_y < sb_y ? draw_y = sb_y; 
    draw_y + draw_h > sb_y + sb_h ? draw_y = sb_y + sb_h - draw_h;
    gfx_rect(sb_x + 2, draw_y, sb_w - 4, draw_h);
    
    playing ? (
        t_n = mem[ui_locked_tab] == 0 ? mem[ui_play_prog_tab] : (mem[ui_locked_tab] > 0 ? mem[ui_locked_tab] : mem[ui_play_prog_tab]);
        t_n == t_e ? (
            vis_beat = calc_vis_beat(t_n);
            p_l = eff_bars(t_n) * 4;
            phx = gx_s + (vis_beat/p_l)*gx_w;
            rect(phx-1, grid_y, 3, slider7*row_h, 0, 1, 0, 0.4);
        );
    );

    color_popup_active && color_popup_row >= 0 ? draw_color_popup(color_popup_x, color_popup_y);
    is_over_grid = (my > grid_y);
    mouse_wheel != 0 && is_over_grid && !shift_dn && !ctrl_dn && !alt_dn && capture_id != 88888 ? (
        scroll_amt = (mouse_wheel > 0) ? -1 : 1;
        new_scroll = slider8 + scroll_amt;
        max_scroll = MAX_ROWS - slider7; 
        max_scroll < 0 ? max_scroll = 0;
        new_scroll = clamp(new_scroll, 0, max_scroll);
        slider8 = new_scroll;
        mouse_wheel = 0;
    );
); 

help_active ? (
    gfx_set(0,0,0,0.85); gfx_rect(0,0,gfx_w,gfx_h);
    hw = 550; hh = 570; hx = (gfx_w-hw)/2; hy = (gfx_h-hh)/2;
    rect(hx, hy, hw, hh, 0.2, 0.2, 0.2, 1);
    gfx_set(0.2*bri,  1.0*bri,  1.0*bri,1);
    gfx_x = hx+430; gfx_y = hy+20; gfx_drawstr(version_display);
    gfx_set(1,1,1,1);
    gfx_x = hx+20; gfx_y = hy+20; gfx_drawstr("SCOPE OF SETTINGS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - GLOBAL SETTINGS: Affect all Patterns (Tabs)");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - PATTERN SETTINGS: Affect only the viewed Pattern");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - ROW SETTINGS: Affect only the selected Row");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("TAB & VIEW FUNCTIONS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - Select Tab: Views the Tab's Pattern");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Tab's Lock Box: Green - Playback is locked to the Tab");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Tab's Lock Box: Black - Playback is not locked to the Tab");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Double-Click Tab: View Pattern AND Lock tab to playback");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Follow [x]:: View and playback follow incoming MIDI commands");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("GRID EDITING:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - Click+Drag: Paint steps and velocity bars");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - CTRL+Drag: Edit all pattern Bars simultaneously");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - SHIFT+Drag: Edit all pattern Beats simultaneously");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Right-Click Drag: Set Note Durations (create long notes)");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("ROW OPERATIONS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - ALT+Drag Name: Move/Swap Rows");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Click Color Dot: Change Row Color");
    gfx_y += 25; 
    gfx_x = hx+20;
    gfx_drawstr("SETTINGS:");
    gfx_x = hx+20; 
    gfx_y += 20;
    gfx_drawstr(" - HUM: -1 follows Global Slider");
    gfx_x = hx+20; 
    gfx_y += 16;
    gfx_drawstr(" - Swing P: Uses Project Swing (Numbers2Notes)");
    gfx_x = hx+20; 
    gfx_y += 16;
    gfx_drawstr(" - [1x | 1/2]: Playback speed for 24/32 SubDivs");
    gfx_x = hx+20; 
    gfx_y += 16;
    gfx_drawstr(" - PUSH/PULL: Adjust timing per row (+ = Lag, - = Push)");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("FILE OPERATIONS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - <- : Import Single Pattern (.n2drumpat) to current Tab");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - <= : Import Pattern Bank (.n2drumpats)");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - -> : Export Single Pattern (.n2drumpat)");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - => : Export Pattern Bank (.n2drumpats)");
    ok_w = 60; ok_h = 25; ok_x = hx + hw - ok_w - 20; ok_y = hy + hh - ok_h - 20;
    rect(ok_x, ok_y, ok_w, ok_h, 0.4, 0.4, 0.4, 1);
    gfx_set(1,1,1,1); gfx_x = ok_x + 18; gfx_y = ok_y + 5; gfx_drawstr("OK");
    mb ? (
        (mx>=ok_x && mx<ok_x+ok_w && my>=ok_y && my<ok_y+ok_h) ? (
            help_active = 0;
            capture_id = 90000; 
        ) : (
            capture_id = 90000; 
        );
    );
);
