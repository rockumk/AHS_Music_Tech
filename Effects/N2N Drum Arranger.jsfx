desc:N2N Drum Arranger
version: 5.5.7
author: Rock Kennedy
about:
  # N2N Drum Arranger v5.5.7
  - Fixed GMEM cue system with proper hierarchy and anti-loop protection
  - 64th-note lookahead, 8th-note clear window
  - MIDI Note > GMEM Global > GMEM Type > GMEM Inst > MIDI PC priority
  - Many, many small new features.
  - Updated provides
provides:
  [data] ../Data/DrumArranger/*.txt > AHS_Music_Tech/DrumArranger/

options:gmem=N2N_Ecosystem_RSKennedy

// --- KIT SELECTOR SLIDER (READ ONLY) ---
slider10:/AHS_Music_Tech/DrumArranger:none:File Selection - Drumkits and Pattern(s)

slider1:100<1,127,1>-Default Row Velocity
slider2:0<0,25,1>-Global Humanize
slider3:2<0,4,1{8,12,16,24,32}>-Global Subdiv
slider4:4<1,4,1>-Global Bars
slider5:1<1,512,1>-Instance ID
slider6:0<0,100,1>-Global Swing
slider7:20<1,128,1>-Visible Rows
slider8:0<0,128,1>-View Scroll
slider9:0<0,1,1{P, M}>-Swing Source (Default=P)
slider11:14<10,30,1>-Grid Row Height

@init

// =========================================================
// REGISTRATION & GROOVE MEMORY
// =========================================================
reg_base = 8000000;
parse_scratch = 500000; 
LOCAL_GROOVE_DB = 550000; 
GMEM_GROOVE_OFFSET = 5000000;

// --- CUE STATE MACHINE VARIABLES (NEW) ---
cue_armed = 0;           
cue_target_tab = -1;     
cue_source_type = -1;    // 0=MIDI Note, 1=GMEM Global, 2=GMEM Type, 3=GMEM Inst, 4=MIDI PC
cue_source_addr = -1;    // Which GMEM address to clear (-1 if not GMEM)
cue_clear_mode = 0;      // Waiting for 8th note window
cue_clear_addr = -1;     // MISSING: Address waiting to be cleared after execution
cue_clear_pending = 0;     // NEW: Flag to ensure GMEM clears once after trigger
midi_note_cue_pending = 0;  
midi_note_cue_val = 0;      
pc_cue_pending = 0;         
pc_cue_val = 0;
last_bar_checked = -1;   // MUST start at -1

// --- Bar-Line Cue Queue Variables (Legacy cleanup) ---
gmem_queued_tab = -1;      
gmem_cue_armed = 0;        
pos_in_bar = 0;
beats_to_bar = 0;

// --- PATTERN INVENTORY REPORTING ---
GMEM_INV_BASE = 7500000;
LOC_TAB_POPULATED = 60000;

// --- CUE SYSTEM CONSTANTS ---
GMEM_MODE_BASE = 7100000;
GMEM_GLOBAL_ADDR = 7100200;
GMEM_TYPE_BASE = 7100300;
GMEM_INST_BASE = 7100500;
GMEM_TYPE_REPORT = 8100000;
MY_TYPE_ID = 1;
gmem_cue_active = 0; 
last_beat_chk = 0; 
my_key == 0 ? (
    seed = floor(time_precise() * 100000) + floor(rand(100000));
    loop(seed % 10, rand(100)); 
    my_key = floor(rand(9000000)) + 1; 
);

reg_done = 0;
curr_id = slider5;

while (reg_done == 0 && curr_id <= 512) (
    slot_val = gmem[reg_base + curr_id];
    (slot_val == 0 || slot_val == my_key) ? (
        gmem[reg_base + curr_id] = my_key;
        slider5 = curr_id;
        reg_done = 1;
    ) : (
        curr_id += 1;
    );
);
slider5 > 512 ? slider5 = 512;

// =========================================================
// MEMORY MANAGEMENT & STRING MAPPING
// =========================================================
row_name_str_base = 0;   
// tab_name_str_base eliminated â€” names hardcoded

STR_BUF_LINE = 650; 
STR_BUF_NAME = 651; 
STR_BUF_COLOR = 652; 
STR_BUF_SWAP = 653; 
STR_BUF_MENU = 654;


// N2N File I/O String Buffers (Must be 0-1023)
N2N_DIR_BUF       = 705;  // Holds directory path
N2N_FILENAME      = 706;  // Holds full export filename
N2N_TEMP_LINE     = 707;  // Temp buffer for file writing
N2N_NAME_BUF      = 708;  // Temp buffer for parsing names
N2N_GRID_HEX      = 709;  // Hex buffer for Grid
N2N_VEL_HEX       = 710;  // Hex buffer for Velocity
N2N_LEN_HEX       = 711;  // Hex buffer for Note Lengths





str_size = 5;

last_load_handle = 0; last_load_lines = 0; last_load_rows = 0;


ext_noinit = 1.0; grid_height = slider11; 
swing_sync = 1;
last_kit_idx = slider10;
last_maint_time = 0;

save_msg_timer = 0; drag_accum_gen = 0; help_active = 0;    

cp_valid = 0; 
cp_bars = 0; cp_sub = 0; cp_hum = 0; cp_sw = 0; cp_half = 0;

MAX_TABS = 22; TOTAL_TABS = 64; MAX_ROWS = 128; MAX_STEPS = 128;
NEW_MAGIC_VER = 27022;
ver_chk = 700;
mem_pos = 701;

ui_base = mem_pos; mem_pos += 32;
ui_edit_tab = ui_base+0; ui_selected_row = ui_base+1; ui_locked_tab = ui_base+2; ui_play_prog_tab = ui_base+3; ui_play_offset = ui_base+4; ui_anchor_valid = ui_base+5; ui_last_step = ui_base+6;

tab_w_base = mem_pos; mem_pos += TOTAL_TABS;
tab_ui_row_base = mem_pos; mem_pos += TOTAL_TABS; 
tab_col_r = mem_pos; mem_pos += TOTAL_TABS;
tab_col_g = mem_pos; mem_pos += TOTAL_TABS;
tab_col_b = mem_pos; mem_pos += TOTAL_TABS;

row_mute_base = mem_pos; mem_pos += MAX_ROWS;
row_solo_base = mem_pos; mem_pos += MAX_ROWS;
row_note_base = mem_pos; mem_pos += MAX_ROWS;
row_chan_base = mem_pos; mem_pos += MAX_ROWS;
row_level_base = mem_pos; mem_pos += MAX_ROWS;
row_human_base = mem_pos; mem_pos += MAX_ROWS;
row_len_base = mem_pos; mem_pos += MAX_ROWS;
row_name_idx = mem_pos; mem_pos += MAX_ROWS;
row_offs_base = mem_pos; mem_pos += MAX_ROWS;
row_color_base = mem_pos; mem_pos += MAX_ROWS;

bars_ov_base = mem_pos; mem_pos += MAX_TABS;
subdiv_ov_base = mem_pos; mem_pos += MAX_TABS;
hum_ov_base = mem_pos; mem_pos += MAX_TABS;
swing_ov_base = mem_pos; mem_pos += MAX_TABS;
half_speed_ov_base = mem_pos; mem_pos += MAX_TABS; 

requested_start_bar = 1; 

mem_pos = 2000000; 

vel_stride_tab = MAX_ROWS * MAX_STEPS; vel_stride_row = MAX_STEPS;
vel_base = mem_pos; mem_pos += TOTAL_TABS * MAX_ROWS * MAX_STEPS;
grid_base = mem_pos; mem_pos += TOTAL_TABS * MAX_ROWS * MAX_STEPS;
step_len_base = mem_pos; mem_pos += TOTAL_TABS * MAX_ROWS * MAX_STEPS;

copy_row_v_buf = mem_pos; mem_pos += MAX_STEPS; 
copy_row_g_buf = mem_pos; mem_pos += MAX_STEPS; 
copy_row_l_buf = mem_pos; mem_pos += MAX_STEPS;
copy_tab_v_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS; 
copy_tab_g_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS; 
copy_tab_l_buf = mem_pos; mem_pos += MAX_ROWS * MAX_STEPS;

mem_pos += 50000;
ownership_map = mem_pos; mem_pos += MAX_STEPS;
kill_note = mem_pos; mem_pos += 128; 
kill_chan = mem_pos; mem_pos += 128;

bar_copy_base = 1500000;

EXT_COUNT = TOTAL_TABS - MAX_TABS;
ext_tab_w_base = mem_pos; mem_pos += EXT_COUNT; 
ext_bars_ov_base = mem_pos; mem_pos += EXT_COUNT; 
ext_subdiv_ov_base = mem_pos; mem_pos += EXT_COUNT; 
ext_hum_ov_base = mem_pos; mem_pos += EXT_COUNT; 
ext_swing_ov_base = mem_pos; mem_pos += EXT_COUNT;
ext_half_speed_ov_base = mem_pos; mem_pos += EXT_COUNT;

ext_vel_base = vel_base + MAX_TABS * vel_stride_tab;
ext_grid_base = grid_base + MAX_TABS * vel_stride_tab;
ext_step_len_base = step_len_base + MAX_TABS * vel_stride_tab;

kit_tmp_base = mem_pos; mem_pos += MAX_ROWS * 7; 
state_len = mem_pos;
row_flash_base = mem_pos; mem_pos += MAX_ROWS;


last_play_state = 0; 
capture_id = 0;
capture_min = 0; 
capture_max = 0; 
capture_ptr = 0; 
capture_slider_idx = 0; 
capture_mode = 0; 
capture_is_signed = 0; 
last_reported_id = 0;
scrollbar_drag_y_offset = 0;

color_popup_active = 0; color_popup_x = 0; color_popup_y = 0; color_popup_row = -1;
drag_mode = 0; last_drag_idx = -1; drag_lock_row = -1; drag_accum = 0; last_preview_note = -1; drag_mods = 0; vel_drag_mods = 0;
len_drag_active = 0; len_drag_cell_idx = 0; len_drag_max = 0;
preview_trig = 0; preview_note = 0; preview_chan = 1; preview_vel = 100;
last_play_tab = -1; last_play_offset = -1; playback_shift = 0; pc_triggered = 0;
row_drag_active = 0; row_drag_anchor = -1; row_drag_last_y = 0;
l_mb = 0; l_mx = 0; l_my = 0; last_tab_clk = 0; last_tab_idx = -1;
l_rmb = 0;
p_rmb = 0;

// =========================================================
// TAB CONFIGURATION DASHBOARD
// =========================================================
function t(id, r_ui, name, w, cr, cg, cb) (
  mem[tab_ui_row_base + id] = r_ui;
  // Tab names now hardcoded in get_t_name(), string storage eliminated
  mem[tab_w_base + id] = w;
  mem[tab_col_r + id] = cr;
  mem[tab_col_g + id] = cg;
  mem[tab_col_b + id] = cb;
);

sectw = 90;
ttabw = 45;
hw = 58;

t(0,   1,   "Off",       55,    0.7,  0.7,  0.7);
t(1,   1,   "Intro",  sectw,    0.2,  1.0,  1.0);
t(2,   1,   "2",      ttabw,    0.2,  1.0,  1.0);
t(3,   1,   "3",      ttabw,    0.2,  1.0,  1.0);
t(4,   1,   "Verse",  sectw,    0.4,  0.6,  1.0);
t(5,   1,   "2",      ttabw,    0.4,  0.6,  1.0);
t(6,   1,   "3",      ttabw,    0.4,  0.6,  1.0);
t(7,   1,   "Pre",    sectw,    0.7,  0.4,  1.0);
t(8,   1,   "2",      ttabw,    0.7,  0.4,  1.0);
t(9,   1,   "3",      ttabw,    0.7,  0.4,  1.0);
t(10,  1,   "Chorus", sectw,    1.0,  0.4,  0.4);
t(11,  1,   "2",      ttabw,    1.0,  0.4,  0.4);
t(12,  1,   "3",      ttabw,    1.0,  0.4,  0.4);
t(13,  1,   "Bridge", sectw,    1.0,  0.9,  0.2);
t(14,  1,   "2",      ttabw,    1.0,  0.9,  0.2);
t(15,  1,   "3",      ttabw,    1.0,  0.9,  0.2);
t(16,  1,   "Outro",  sectw,    0.5,  0.8,  0.7);
t(17,  1,   "2",      ttabw,    0.5,  0.8,  0.7);
t(18,  1,   "3",      ttabw,    0.5,  0.8,  0.7);
t(19,  1,   "H 1",    hw,    0.8,  0.8,  0.8);
t(20,  1,   "H 2",    hw,    0.8,  0.8,  0.8);
t(21,  1,   "1<",  44,    0.7,  0.4,  1.0);
t(22,  1,   "1=",  44,    0.7,  0.4,  1.0);
t(23,  1,   "1>",  44,    0.7,  0.4,  1.0);
t(24,  1,   "1",   44,    0.8,  0.8,  0.8);
t(25,  1,   "2",   44,    0.8,  0.8,  0.8);
t(26,  1,   "3",   44,    0.8,  0.8,  0.8);
t(27,  1,   "4",   44,    0.8,  0.8,  0.8);
t(28,  1,   "5",   44,    0.8,  0.8,  0.8);
t(29,  2,   "Def",       55,    0.8,  0.8,  0.8);
t(30,  2,   "4",   ttabw,   0.2,  1.0,  1.0);
t(31,  2,   "5",   ttabw,   0.2,  1.0,  1.0);
t(32,  2,   "6",   ttabw,   0.2,  1.0,  1.0);
t(33,  2,   "7",   ttabw,   0.2,  1.0,  1.0);
t(34,  2,   "4",   ttabw,   0.4,  0.6,  1.0);
t(35,  2,   "5",   ttabw,   0.4,  0.6,  1.0);
t(36,  2,   "6",   ttabw,   0.4,  0.6,  1.0);
t(37,  2,   "7",   ttabw,   0.4,  0.6,  1.0);
t(38,  2,   "4",   ttabw,   0.7,  0.4,  1.0);
t(39,  2,   "5",   ttabw,   0.7,  0.4,  1.0);
t(40,  2,   "6",   ttabw,   0.7,  0.4,  1.0);
t(41,  2,   "7",   ttabw,   0.7,  0.4,  1.0);
t(42,  2,   "4",   ttabw,   1.0,  0.4,  0.4);
t(43,  2,   "5",   ttabw,   1.0,  0.4,  0.4);
t(44,  2,   "6",   ttabw,   1.0,  0.4,  0.4);
t(45,  2,   "7",   ttabw,   1.0,  0.4,  0.4);
t(46,  2,   "4",   ttabw,   1.0,  0.9,  0.2);
t(47,  2,   "5",   ttabw,   1.0,  0.9,  0.2);
t(48,  2,   "6",   ttabw,   1.0,  0.9,  0.2);
t(49,  2,   "7",   ttabw,   1.0,  0.9,  0.2);
t(50,  2,   "4",   ttabw,   0.5,  0.8,  0.7);
t(51,  2,   "5",   ttabw,   0.5,  0.8,  0.7);
t(52,  2,   "6",   ttabw,   0.5,  0.8,  0.7);
t(53,  2,   "7",   ttabw,   0.5,  0.8,  0.7);
t(54,  2,   "H 3",    hw,    0.8,  0.8,  0.8);
t(55,  2,   "H 4",    hw,    0.8,  0.8,  0.8);
t(56,  2,   "2<",   44,     0.8,  0.3,  0.9);
t(57,  2,   "2=",   44,     0.8,  0.3,  0.9);
t(58,  2,   "2>",   44,     0.8,  0.3,  0.9);
t(59,  2,   "6",   44,    0.8,  0.8,  0.8);
t(60,  2,   "7",   44,    0.8,  0.8,  0.8);
t(61,  2,   "8",   44,    0.8,  0.8,  0.8);
t(62,  2,   "9",   44,    0.8,  0.8,  0.8);
t(63,  2,   "10",  44,    0.8,  0.8,  0.8);

// =========================================================
// GENERAL HELPER FUNCTIONS
// =========================================================
#name_menu = "Bass Drum|Bass Drum 1|Bass Drum 2|China|Clap|Conga High|Conga Low|Cowbell|Crash|Crash Cymbal 1|Crash Cymbal 2|Cymbal|FX 1|FX 2|Hand Clap|Hat Cl|Hat Pd|Hat Op|Kick|High Floor Tom|Kick 1|Kick 2|Maraca|Perc 1|Perc 2|Perc 3|Ride|Ride Bell|Rimshot|Shaker|Side Stick|Snare|Snare 1|Snare 2|Splash|Tambourine|Tom Hi|Tom Mid|Tom Lo|Triangle Mute|Triangle Open|(Empty)";
#color_menu = "White|Red|Deep Orange|Orange|Amber|Yellow|Lime|Green|Mint|Cyan|Sky|Blue|Indigo|Purple|Violet|Magenta|Rose|Grey";

EMPTY_NAME_IDX = 41;

function clamp(x,a,b) ( x<a ? a : (x>b ? b : x); );
function fmod_pos(x, m) ( m<=0 ? 0 : x - floor(x/m)*m; );

function get_menu_item(list_str, idx, out_str)
local(str_len, char_idx, item_ctr, c)
(
    strcpy(out_str, "");
    str_len = strlen(list_str);
    char_idx = 0; item_ctr = 0;
    while (item_ctr < idx && char_idx < str_len) (
        str_getchar(list_str, char_idx) == '|' ? item_ctr += 1;
        char_idx += 1;
    );
    while (char_idx < str_len) (
        c = str_getchar(list_str, char_idx);
        c == '|' ? char_idx = str_len : ( str_setchar(out_str, strlen(out_str), c); );
        char_idx += 1;
    );
);

function auto_fit_rows(y_start, row_h)
local(avail_height, calc_rows)
(
    avail_height = gfx_h - y_start;
    (avail_height > 0 && row_h > 0) ? (
        calc_rows = floor(avail_height / row_h);
        calc_rows < 1 ? calc_rows = 1;
        calc_rows > 128 ? calc_rows = 128;
        slider7 != calc_rows ? (
            slider7 = calc_rows;
            slider_automate(slider7);
        );
    );
);

function flush_inventory_to_gmem()
local(inst_offset, i, m0, m1, m2, m3, target_pc, idx, rem)
(
    inst_offset = GMEM_INV_BASE + (floor(slider5) - 1) * 4;
    m0=0; m1=0; m2=0; m3=0;
    i=0; loop(TOTAL_TABS, 
        mem[LOC_TAB_POPULATED + i] ? (
            target_pc = mem[inv_map_base + i];
            target_pc >= 0 ? (
                idx = floor(target_pc / 32);
                rem = target_pc % 32;
                idx == 0 ? m0 |= (1 << rem);
                idx == 1 ? m1 |= (1 << rem);
                idx == 2 ? m2 |= (1 << rem);
                idx == 3 ? m3 |= (1 << rem);
            );
        );
        i += 1;
    );
    gmem[inst_offset+0] = m0;
    gmem[inst_offset+1] = m1;
    gmem[inst_offset+2] = m2;
    gmem[inst_offset+3] = m3;
);

function check_tab_population(t_idx)
local(ptr, k, has_d)
(
    has_d = 0;
    (t_idx < 22) ? ptr = grid_base + t_idx*vel_stride_tab
                 : ptr = ext_grid_base + (t_idx-22)*vel_stride_tab;
    k = 0; 
    while (k < vel_stride_tab && has_d == 0) (
        mem[ptr + k] > 0 ? has_d = 1;
        k += 1;
    );
    mem[LOC_TAB_POPULATED + t_idx] = has_d;
);

function scan_active_tab() (
    check_tab_population(mem[ui_edit_tab]);
    flush_inventory_to_gmem();
);

function scan_all_tabs() local(i) (
    i = 0; loop(TOTAL_TABS, check_tab_population(i); i+=1; );
    flush_inventory_to_gmem();
);





function import_n2n_data(bank_mode) (
    // TODO: Import implementation
    0;
);

function export_n2n_data(bank_mode) (
    // TODO: Export implementation  
    0;
);












function resolve_color_idx(str_in)
(
    matchi("*White*", str_in) ? 0 :
    matchi("*Deep*Orange*", str_in) ? 2 :
    matchi("*Orange*", str_in) ? 3 :
    matchi("*Amber*", str_in) ? 4 :
    matchi("*Yellow*", str_in) ? 5 :
    matchi("*Lime*", str_in) ? 6 :
    matchi("*Mint*", str_in) ? 8 :
    matchi("*Green*", str_in) ? 7 :
    matchi("*Cyan*", str_in) ? 9 :
    matchi("*Sky*", str_in) ? 10 :
    matchi("*Indigo*", str_in) ? 12 :
    matchi("*Blue*", str_in) ? 11 :
    matchi("*Purple*", str_in) ? 13 :
    matchi("*Violet*", str_in) ? 14 :
    matchi("*Magenta*", str_in) ? 15 :
    matchi("*Rose*", str_in) ? 16 :
    matchi("*Grey*", str_in) ? 17 :
    matchi("*Gray*", str_in) ? 17 :
    matchi("*Red*", str_in) ? 1 :
    matchi("*Pianoblack*", str_in) ? 100 :
    matchi("*Pianowhite*", str_in) ? 101 :
    -1; 
);

function get_d_name(idx, out) (
    get_menu_item(#name_menu, idx, out);
    strcmp(out, "(Empty)") == 0 ? strcpy(out, "");
    (strlen(out) == 0 && idx != 41) ? sprintf(out, "Drum %d", idx+1);
);

function get_t_name(idx, out) (
    idx == 0 ? strcpy(out, "Off") :
    idx == 1 ? strcpy(out, "Intro") :
    idx == 2 ? strcpy(out, "2") :
    idx == 3 ? strcpy(out, "3") :
    idx == 4 ? strcpy(out, "Verse") :
    idx == 5 ? strcpy(out, "2") :
    idx == 6 ? strcpy(out, "3") :
    idx == 7 ? strcpy(out, "Pre") :
    idx == 8 ? strcpy(out, "2") :
    idx == 9 ? strcpy(out, "3") :
    idx == 10 ? strcpy(out, "Chorus") :
    idx == 11 ? strcpy(out, "2") :
    idx == 12 ? strcpy(out, "3") :
    idx == 13 ? strcpy(out, "Bridge") :
    idx == 14 ? strcpy(out, "2") :
    idx == 15 ? strcpy(out, "3") :
    idx == 16 ? strcpy(out, "Outro") :
    idx == 17 ? strcpy(out, "2") :
    idx == 18 ? strcpy(out, "3") :
    idx == 19 ? strcpy(out, "H 1") :
    idx == 20 ? strcpy(out, "H 2") :
    idx == 21 ? strcpy(out, "1<") :
    idx == 22 ? strcpy(out, "1=") :
    idx == 23 ? strcpy(out, "1>") :
    idx == 24 ? strcpy(out, "1") :
    idx == 25 ? strcpy(out, "2") :
    idx == 26 ? strcpy(out, "3") :
    idx == 27 ? strcpy(out, "4") :
    idx == 28 ? strcpy(out, "5") :
    idx == 29 ? strcpy(out, "Def") :
    idx == 30 ? strcpy(out, "4") :
    idx == 31 ? strcpy(out, "5") :
    idx == 32 ? strcpy(out, "6") :
    idx == 33 ? strcpy(out, "7") :
    idx == 34 ? strcpy(out, "4") :
    idx == 35 ? strcpy(out, "5") :
    idx == 36 ? strcpy(out, "6") :
    idx == 37 ? strcpy(out, "7") :
    idx == 38 ? strcpy(out, "4") :
    idx == 39 ? strcpy(out, "5") :
    idx == 40 ? strcpy(out, "6") :
    idx == 41 ? strcpy(out, "7") :
    idx == 42 ? strcpy(out, "4") :
    idx == 43 ? strcpy(out, "5") :
    idx == 44 ? strcpy(out, "6") :
    idx == 45 ? strcpy(out, "7") :
    idx == 46 ? strcpy(out, "4") :
    idx == 47 ? strcpy(out, "5") :
    idx == 48 ? strcpy(out, "6") :
    idx == 49 ? strcpy(out, "7") :
    idx == 50 ? strcpy(out, "4") :
    idx == 51 ? strcpy(out, "5") :
    idx == 52 ? strcpy(out, "6") :
    idx == 53 ? strcpy(out, "7") :
    idx == 54 ? strcpy(out, "H 3") :
    idx == 55 ? strcpy(out, "H 4") :
    idx == 56 ? strcpy(out, "2<") :
    idx == 57 ? strcpy(out, "2=") :
    idx == 58 ? strcpy(out, "2>") :
    idx == 59 ? strcpy(out, "6") :
    idx == 60 ? strcpy(out, "7") :
    idx == 61 ? strcpy(out, "8") :
    idx == 62 ? strcpy(out, "9") :
    idx == 63 ? strcpy(out, "10") :
    sprintf(out, "%d", idx);
);

function get_palette_values(idx) (
    idx==0 ? (cr=1.0; cg=1.0; cb=1.0;) : 
    idx==1 ? (cr=1.0; cg=0.4; cb=0.4;) :
    idx==2 ? (cr=1.0; cg=0.55; cb=0.3;) :
    idx==3 ? (cr=1.0; cg=0.7; cb=0.2;) :
    idx==4 ? (cr=1.0; cg=0.85; cb=0.2;) :
    idx==5 ? (cr=1.0; cg=1.0; cb=0.2;) :
    idx==6 ? (cr=0.7; cg=1.0; cb=0.2;) :
    idx==7 ? (cr=0.4; cg=0.9; cb=0.4;) :
    idx==8 ? (cr=0.2; cg=1.0; cb=0.7;) :
    idx==9 ? (cr=0.2; cg=0.9; cb=0.9;) :
    idx==10 ? (cr=0.2; cg=0.7; cb=1.0;) :
    idx==11 ? (cr=0.4; cg=0.6; cb=1.0;) :
    idx==12 ? (cr=0.5; cg=0.4; cb=1.0;) :
    idx==13 ? (cr=0.7; cg=0.4; cb=1.0;) :
    idx==14 ? (cr=0.9; cg=0.4; cb=1.0;) :
    idx==15 ? (cr=1.0; cg=0.4; cb=1.0;) :
    idx==16 ? (cr=1.0; cg=0.4; cb=0.7;) :
    idx==17 ? (cr=0.5; cg=0.5; cb=0.5;) :
    (cr=0.9; cg=0.9; cb=0.9;);
);

function set_ui_color(idx) ( get_palette_values(idx); gfx_set(cr, cg, cb, 1); );

function eff_bars(t) (
    b = (t<22) ? mem[bars_ov_base+t] : mem[ext_bars_ov_base+(t-22)];
    (b<1 || b>4) ? slider4 : b;
);

function eff_sub(t) (
    ov = (t<22) ? mem[subdiv_ov_base+t] : mem[ext_subdiv_ov_base+(t-22)];
    (ov<0 || ov>4) ? (ov = slider3);
    ov==0?8:ov==1?12:ov==2?16:ov==3?24:32;
);

function eff_swing(t) (
    base_swing = (slider9 == 0) ? gmem[1] : slider6;
    s = (t<22) ? mem[swing_ov_base+t] : mem[ext_swing_ov_base+(t-22)];
    s < 0 ? base_swing : s;
);

function eff_hum(t) (
    h = (t<22) ? mem[hum_ov_base+t] : mem[ext_hum_ov_base+(t-22)];
    h<0 ? slider2 : h;
);

function eff_half(t) (
    (t<22) ? mem[half_speed_ov_base+t] : mem[ext_half_speed_ov_base+(t-22)];
);

function parse_kit_line(line_slot_in, name_slot_out, note_out, chan_out, color_idx_out)
local(line_len, i, k, note_val, chan_val, name_start_idx, name_end_idx, c_idx, found_channel, col_sep_idx, col_start)
(
    mem[note_out] = -1; 
    mem[chan_out] = -1; 
    mem[color_idx_out] = -1; 
    strcpy(name_slot_out, ""); 
    line_len = strlen(line_slot_in);
    c_idx = 0; found_channel = 0;
    while (c_idx < line_len - 1 && !found_channel) (
        (str_getchar(line_slot_in, c_idx) == '/' && str_getchar(line_slot_in, c_idx+1) == '/') ? (
            k = c_idx + 2;
            while (k < line_len && str_getchar(line_slot_in, k) <= 32) (k += 1;);
            (k < line_len && str_getchar(line_slot_in, k) >= '0' && str_getchar(line_slot_in, k) <= '9') ? (
                chan_val = 0;
                while (k < line_len && str_getchar(line_slot_in, k) >= '0' && str_getchar(line_slot_in, k) <= '9') (
                    chan_val = chan_val * 10 + (str_getchar(line_slot_in, k) - '0');
                    k += 1;
                );
                (chan_val >= 1 && chan_val <= 16) ? ( mem[chan_out] = chan_val; found_channel = 1; );
            );
        );
        c_idx += 1;
    );
    !found_channel ? (
        i = 0;
        while (i < line_len && (str_getchar(line_slot_in, i) < '0' || str_getchar(line_slot_in, i) > '9')) ( i += 1; );
        (i < line_len) ? (
            note_val = 0;
            while (i < line_len && str_getchar(line_slot_in, i) >= '0' && str_getchar(line_slot_in, i) <= '9') (
                note_val = note_val * 10 + (str_getchar(line_slot_in, i) - '0');
                i += 1;
            );
            (note_val >= 0 && note_val <= 127) ? (
                mem[note_out] = note_val;
                while (i < line_len && (str_getchar(line_slot_in, i) <= 32 || str_getchar(line_slot_in, i) == ':' || str_getchar(line_slot_in, i) == '-')) ( i += 1; );
                name_start_idx = i;
                name_end_idx = line_len - 1;
                col_sep_idx = -1;
                k = name_start_idx;
                while (k < line_len - 1) (
                    (str_getchar(line_slot_in, k) == '/' && str_getchar(line_slot_in, k+1) == '/') ? (
                        col_sep_idx = k; k = line_len; 
                    );
                    k += 1;
                );
                col_sep_idx != -1 ? (
                    name_end_idx = col_sep_idx - 1; 
                    col_start = col_sep_idx + 2;
                    strcpy_substr(#color_tmp, line_slot_in, col_start, line_len - col_start);
                    mem[color_idx_out] = resolve_color_idx(#color_tmp);
                );
                while (name_end_idx >= name_start_idx && str_getchar(line_slot_in, name_end_idx) <= 32) ( name_end_idx -= 1; );
name_end_idx >= name_start_idx ? (
                    name_len = name_end_idx - name_start_idx + 1;
                    name_len > 20 ? name_len = 20;
                    strcpy_substr(name_slot_out, line_slot_in, name_start_idx, name_len);
                );
                1; 
            );
        );
    ) : ( 1 );
);

function load_kit_from_slider()
local(handle, note_out, chan_out, color_idx_out, current_chan, cur_row_idx, parsed, i, SLOT_LINE, SLOT_NAME,
      sel_r, context_chan, context_color)
(
    note_out = 50000; chan_out = 50001; color_idx_out = 50002; 
    SLOT_LINE = STR_BUF_LINE; SLOT_NAME = STR_BUF_NAME;
    sel_r = mem[ui_selected_row];
    sel_r < 0 ? sel_r = 0; sel_r >= MAX_ROWS ? sel_r = MAX_ROWS - 1;
    context_chan = mem[row_chan_base + sel_r];
    context_color = mem[row_color_base + sel_r];
    context_chan < 1 ? context_chan = 1;
    handle = file_open(slider10);
    handle > 0 ? (
        i = 0; loop(MAX_ROWS,
            mem[row_note_base+i] = -1; mem[row_chan_base+i] = 1; mem[row_color_base+i] = 0; 
            mem[row_name_idx+i] = 41; 
            strcpy(row_name_str_base + i, ""); 
            i+=1;
        );
        current_chan = context_chan; 
        cur_row_idx = 0;
        while (file_string(handle, SLOT_LINE) > 0) (
            parsed = parse_kit_line(SLOT_LINE, SLOT_NAME, note_out, chan_out, color_idx_out);
            (parsed == 1) ? (
                (mem[note_out] != -1) ? ( 
                    (cur_row_idx < MAX_ROWS) ? (
                        mem[row_note_base+cur_row_idx]  = mem[note_out];
                        mem[row_chan_base+cur_row_idx]  = current_chan; 
                        strlen(SLOT_NAME) > 0 ? ( strcpy(row_name_str_base + cur_row_idx, SLOT_NAME); ) 
                        : ( sprintf(row_name_str_base + cur_row_idx, "Drum %d", mem[note_out]); );
                        mem[row_name_idx+cur_row_idx] = 41; 
                        mem[row_color_base+cur_row_idx] = (mem[color_idx_out] != -1) ? mem[color_idx_out] : context_color;
                        cur_row_idx += 1;
                    );
                ) : ( (mem[chan_out] != -1) ? ( current_chan = mem[chan_out]; ); );
            );
            strcpy(SLOT_LINE, ""); 
        );
        file_close(handle);
    );
);

function add_kit_from_slider()
local(handle, note_out, chan_out, color_idx_out, current_chan, 
      tmp_kit_note, tmp_kit_chan, tmp_kit_color, kit_buf_idx, 
      parsed, j, insert_idx, incoming_note, incoming_chan, incoming_color, i, SLOT_LINE, SLOT_NAME, TEMP_STR_OFFSET,
      sel_r, context_chan, context_color)
(
    note_out = 50000; chan_out = 50001; color_idx_out = 50002; 
    SLOT_LINE = STR_BUF_LINE; SLOT_NAME = STR_BUF_NAME;
    tmp_kit_note = kit_tmp_base; tmp_kit_chan = kit_tmp_base + 128; tmp_kit_color = kit_tmp_base + 256; 
    TEMP_STR_OFFSET = 3000; 
    sel_r = mem[ui_selected_row];
    sel_r < 0 ? sel_r = 0; sel_r >= MAX_ROWS ? sel_r = MAX_ROWS - 1;
    context_chan = mem[row_chan_base + sel_r];
    context_color = mem[row_color_base + sel_r];
    context_chan < 1 ? context_chan = 1;
    insert_idx = sel_r;
    handle = file_open(slider10);
    handle > 0 ? (
        kit_buf_idx = 0;
        i = 0; loop(MAX_ROWS, mem[tmp_kit_note+i]=-1; i+=1;); 
        current_chan = context_chan; 
        while (file_string(handle, SLOT_LINE) > 0) (
            parsed = parse_kit_line(SLOT_LINE, SLOT_NAME, note_out, chan_out, color_idx_out);
            (parsed == 1) ? (
                (mem[note_out] != -1) ? (
                    (kit_buf_idx < MAX_ROWS) ? (
                        mem[tmp_kit_note + kit_buf_idx] = mem[note_out];
                        mem[tmp_kit_chan + kit_buf_idx] = current_chan;
                        mem[tmp_kit_color + kit_buf_idx] = mem[color_idx_out];
                        strcpy(TEMP_STR_OFFSET + kit_buf_idx, SLOT_NAME);
                        kit_buf_idx += 1;
                    );
                ) : ( (mem[chan_out] != -1) ? ( current_chan = mem[chan_out]; ); );
            );
            strcpy(SLOT_LINE, ""); 
        );
        file_close(handle);
        i = 0; loop(kit_buf_idx,
            incoming_note = mem[tmp_kit_note + i]; incoming_chan = mem[tmp_kit_chan + i]; incoming_color = mem[tmp_kit_color + i];
            while (insert_idx < MAX_ROWS && (mem[row_note_base+insert_idx] != -1 || strlen(row_name_str_base+insert_idx) > 0)) ( insert_idx += 1; );
            (insert_idx < MAX_ROWS) ? (
                mem[row_note_base+insert_idx]  = incoming_note;
                mem[row_chan_base+insert_idx]  = incoming_chan;
                strcpy(row_name_str_base + insert_idx, TEMP_STR_OFFSET + i);
                mem[row_color_base+insert_idx] = (incoming_color != -1) ? incoming_color : context_color;
                mem[row_mute_base+insert_idx] = 0; mem[row_solo_base+insert_idx] = 0; mem[row_name_idx+insert_idx] = 41; 
                insert_idx += 1; 
            );
            i+=1;
        );
    );
);

(mem[ver_chk] != NEW_MAGIC_VER) ? (
    mem[ui_edit_tab] = 29;
    mem[ui_play_prog_tab] = 29;
    mem[ui_locked_tab] = -1;
    mem[ui_play_offset] = 0;
    i_d=0; loop(MAX_ROWS,
        n_val = 36 + i_d;
        while(n_val > 127) ( n_val -= 128; );
        mem[row_note_base+i_d] = n_val;
        mem[row_chan_base+i_d]=1;
        mem[row_level_base+i_d]=80; 
        mem[row_human_base+i_d]=-1;
        mem[row_name_idx+i_d] = i_d;
        mem[row_color_base+i_d]=0;
        mem[row_len_base+i_d] = 20;
        mem[row_mute_base+i_d]=0;
        mem[row_solo_base+i_d]=0;
        mem[row_offs_base+i_d]=0;
        strcpy(row_name_str_base + i_d, "");
        i_d+=1;
    );
    memset(vel_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    memset(grid_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    memset(step_len_base, 0, TOTAL_TABS * MAX_ROWS * MAX_STEPS);
    t_d=0; loop(MAX_TABS,
        mem[bars_ov_base+t_d] = 0;
        mem[subdiv_ov_base+t_d] = -1; 
        mem[hum_ov_base+t_d] = -1;
        mem[swing_ov_base+t_d] = -1;
        mem[half_speed_ov_base+t_d] = 0;
        t_d+=1;
    );
    t_d=0; loop(EXT_COUNT,
        mem[ext_bars_ov_base+t_d] = 0;
        mem[ext_subdiv_ov_base+t_d] = -1; 
        mem[ext_hum_ov_base+t_d] = -1;
        mem[ext_swing_ov_base+t_d] = -1;
        mem[ext_half_speed_ov_base+t_d] = 0;
        t_d+=1;
    );
    mem[ver_chk] = NEW_MAGIC_VER;
);

function swap_rows(a, b)
local(tmp, t, basev, baseg, basel, i, offa, offb, va, vb, ga, gb, la, lb, slot_a, slot_b)
(
    a == b ? 0 :
    (
        tmp = mem[row_mute_base+a];  mem[row_mute_base+a]=mem[row_mute_base+b];  mem[row_mute_base+b]=tmp;
        tmp = mem[row_solo_base+a];  mem[row_solo_base+a]=mem[row_solo_base+b];  mem[row_solo_base+b]=tmp;
        tmp = mem[row_note_base+a];  mem[row_note_base+a]=mem[row_note_base+b];  mem[row_note_base+b]=tmp;
        tmp = mem[row_chan_base+a];  mem[row_chan_base+a]=mem[row_chan_base+b];  mem[row_chan_base+b]=tmp;
        tmp = mem[row_level_base+a]; mem[row_level_base+a]=mem[row_level_base+b]; mem[row_level_base+b]=tmp;
        tmp = mem[row_human_base+a]; mem[row_human_base+a]=mem[row_human_base+b]; mem[row_human_base+b]=tmp;
        tmp = mem[row_len_base+a];   mem[row_len_base+a]=mem[row_len_base+b];   mem[row_len_base+b]=tmp;
        tmp = mem[row_name_idx+a];   mem[row_name_idx+a]=mem[row_name_idx+b];   mem[row_name_idx+b]=tmp;
        tmp = mem[row_offs_base+a];  mem[row_offs_base+a]=mem[row_offs_base+b]; mem[row_offs_base+b]=tmp;
        tmp = mem[row_color_base+a]; mem[row_color_base+a]=mem[row_color_base+b]; mem[row_color_base+b]=tmp;
        slot_a = row_name_str_base + a;
        slot_b = row_name_str_base + b;
        strcpy(STR_BUF_SWAP, slot_a);
        strcpy(slot_a, slot_b);
        strcpy(slot_b, STR_BUF_SWAP);
        t=0; loop(TOTAL_TABS,
            (t < 22) ? (
                basev = vel_base + t*vel_stride_tab;
                baseg = grid_base + t*vel_stride_tab;
                basel = step_len_base + t*vel_stride_tab;
            ) : (
                basev = ext_vel_base + (t-22)*vel_stride_tab;
                baseg = ext_grid_base + (t-22)*vel_stride_tab;
                basel = ext_step_len_base + (t-22)*vel_stride_tab;
            );
            offa = a*vel_stride_row;
            offb = b*vel_stride_row;
            i=0; loop(MAX_STEPS,
                va = mem[basev + offa + i]; vb = mem[basev + offb + i];
                mem[basev + offa + i] = vb; mem[basev + offb + i] = va;
                ga = mem[baseg + offa + i]; gb = mem[baseg + offb + i];
                mem[baseg + offa + i] = gb; mem[baseg + offb + i] = ga;
                la = mem[basel + offa + i]; lb = mem[basel + offb + i];
                mem[basel + offa + i] = lb; mem[basel + offb + i] = la;
                i+=1;
            );
            t+=1;
        );
        sel = mem[ui_selected_row];
        sel == a ? mem[ui_selected_row]=b : sel == b ? mem[ui_selected_row]=a : 0;
    );
);

inv_map_base = 6000000;
i = 0; loop(128, mem[inv_map_base+i] = -1; i+=1; );
mem[inv_map_base + 0] = 0;
mem[inv_map_base + 29] = 101;
i=0; loop(3, mem[inv_map_base + 1+i] = 11+i; i+=1; );
i=0; loop(3, mem[inv_map_base + 4+i] = 21+i; i+=1; );
i=0; loop(3, mem[inv_map_base + 7+i] = 31+i; i+=1; );
i=0; loop(3, mem[inv_map_base + 10+i] = 41+i; i+=1; );
i=0; loop(3, mem[inv_map_base + 13+i] = 51+i; i+=1; );
i=0; loop(3, mem[inv_map_base + 16+i] = 61+i; i+=1; );
i=0; loop(2, mem[inv_map_base + 19+i] = 71+i; i+=1; );
i=0; loop(3, mem[inv_map_base + 21+i] = 81+i; i+=1; );
i=0; loop(5, mem[inv_map_base + 24+i] = 91+i; i+=1; );
i=0; loop(4, mem[inv_map_base + 30+i] = 14+i; i+=1; );
i=0; loop(4, mem[inv_map_base + 34+i] = 24+i; i+=1; );
i=0; loop(4, mem[inv_map_base + 38+i] = 34+i; i+=1; );
i=0; loop(4, mem[inv_map_base + 42+i] = 44+i; i+=1; );
i=0; loop(4, mem[inv_map_base + 46+i] = 54+i; i+=1; );
i=0; loop(4, mem[inv_map_base + 50+i] = 64+i; i+=1; );
i=0; loop(2, mem[inv_map_base + 54+i] = 73+i; i+=1; );
i=0; loop(3, mem[inv_map_base + 56+i] = 84+i; i+=1; );
i=0; loop(5, mem[inv_map_base + 59+i] = 96+i; i+=1; );

scan_all_tabs();

@serialize
file_avail(0) > 0 ? (
    // LOADING - file exists and has data
    file_var(0, loaded_ver);
    loaded_ver == NEW_MAGIC_VER ? (
        file_mem(0, 0, state_len);
        i=0; loop(MAX_ROWS, file_string(0, row_name_str_base + i * str_size); i+=1;);
        file_avail(0) >= 0 ? ( scan_all_tabs(); );
    ) : (
        // Wrong version or corrupt - skip
        0;
    );
) : (
    // SAVING - write current state
    file_var(0, NEW_MAGIC_VER);
    file_mem(0, 0, state_len);
    i=0; loop(MAX_ROWS, file_string(0, row_name_str_base + i * str_size); i+=1;);
);

@block
(slider9 == 0) ? ( slider6 = gmem[1]; );
(slider10 != last_kit_idx) ? (
    load_kit_from_slider();
    last_kit_idx = slider10;
);

// Minimal scan on ID change only (removed 5-second heartbeat)
(slider5 != last_reported_id) ? (
    scan_all_tabs();
    last_reported_id = slider5;
);

// TRACK IDENTITY
GMEM_INFO_BASE = 8200000;
my_info_idx = GMEM_INFO_BASE + ((slider5 - 1) * 4);
track_num = gmem[my_info_idx];
track_r = gmem[my_info_idx + 1];
track_g = gmem[my_info_idx + 2];
track_b = gmem[my_info_idx + 3];

GM_BASE = 7000000 + (slider5-1)*16;
gmem[GM_BASE] != 0x44504531 ? ( gmem[GM_BASE] = 0x44504531; gmem[GM_BASE+1] = -1; gmem[GM_BASE+2] = 29; );
mem[ui_locked_tab] = gmem[GM_BASE+1];
mem[ui_play_prog_tab] = gmem[GM_BASE+2];

// SYNC GROOVE MEMORY
i_gr = 0; max_gr = 0;
loop(32, 
    val = gmem[GMEM_GROOVE_OFFSET + i_gr];
    mem[LOCAL_GROOVE_DB + i_gr] = val; 
    abs(val) > max_gr ? max_gr = abs(val);
    i_gr+=1; 
);
mem[LOCAL_GROOVE_DB + 32] = max_gr;










// =========================================================
// CUE SYSTEM LOGIC (REVERTED TO v4.9.9 "ALWAYS WATCHING" LOGIC)
// =========================================================

// 1. REPORT TYPE (I am Drums)
(slider5 > 0) ? ( gmem[GMEM_TYPE_REPORT + slider5 - 1] = MY_TYPE_ID; );

// --- A. MIDI INPUT & IMMEDIATE MAPPING ---
// We map MIDI Note/PC to Internal Tab IDs the moment they arrive.
// We DO NOT wait for a window. We buffer them immediately.

while (midirecv(off, m1, m23)) (
    status = m1 & 0xF0;
    ch = (m1 & 0x0F) + 1;
    d1 = m23 & 0x7F; 
    d2 = (m23 >> 8) & 0x7F; 
    
    // Pass through by default
    midisend(off, m1, m23);

    (ch == 16) ? (
        // Start Bar Offset (CC 0)
        (status == 0xB0 && d1 == 0) ? (
             requested_start_bar = d2; 
             requested_start_bar < 1 ? requested_start_bar = 1;
        ) 
        // PC Recv -> MAP IMMEDIATELY
        : (status == 0xC0) ? (
            pc = d1;
            trig_t = -2;
            
            pc == 0 ? ( trig_t = 0; ) : // OFF
            pc == 101 ? ( trig_t = 29; ) : // DEF
            (pc >= 11 && pc <= 13) ? ( trig_t = 1 + (pc - 11); ) : 
            (pc >= 14 && pc <= 17) ? ( trig_t = 30 + (pc - 14); ) : 
            (pc >= 21 && pc <= 23) ? ( trig_t = 4 + (pc - 21); ) : 
            (pc >= 24 && pc <= 27) ? ( trig_t = 34 + (pc - 24); ) : 
            (pc >= 31 && pc <= 33) ? ( trig_t = 7 + (pc - 31); ) : 
            (pc >= 34 && pc <= 37) ? ( trig_t = 38 + (pc - 34); ) : 
            (pc >= 41 && pc <= 43) ? ( trig_t = 10 + (pc - 41); ) : 
            (pc >= 44 && pc <= 47) ? ( trig_t = 42 + (pc - 44); ) : 
            (pc >= 51 && pc <= 53) ? ( trig_t = 13 + (pc - 51); ) : 
            (pc >= 54 && pc <= 57) ? ( trig_t = 46 + (pc - 54); ) : 
            (pc >= 61 && pc <= 63) ? ( trig_t = 16 + (pc - 61); ) : 
            (pc >= 64 && pc <= 67) ? ( trig_t = 50 + (pc - 64); ) : 
            (pc >= 71 && pc <= 72) ? ( trig_t = 19 + (pc - 71); ) : 
            (pc >= 73 && pc <= 74) ? ( trig_t = 54 + (pc - 73); ) : 
            (pc >= 81 && pc <= 83) ? ( trig_t = 21 + (pc - 81); ) : 
            (pc >= 84 && pc <= 86) ? ( trig_t = 56 + (pc - 84); ) : 
            (pc >= 91 && pc <= 95) ? ( trig_t = 24 + (pc - 91); ) : 
            (pc >= 96 && pc <= 100) ? ( trig_t = 59 + (pc - 96); ); 
            
            (trig_t != -2) ? (
                // Buffer the request immediately
                midi_cue_tab = trig_t;
                midi_cue_source = 2; // 2=PC
            );
        ) 
        // Note Recv -> MAP IMMEDIATELY
        : (status == 0x90 && d2 > 0) ? (
            nn = d1;
            trig_t = -2;
            (nn >= 36 && nn <= 83) ? (
                rel_note = nn - 36;
                oct = floor(rel_note / 12); 
                pitch = rel_note % 12;      
                pitch == 0 ? ( trig_t = 1; ) : 
                pitch == 2 ? ( trig_t = 4; ) : 
                pitch == 4 ? ( trig_t = 7; ) : 
                pitch == 5 ? ( trig_t = 10; ) : 
                pitch == 7 ? ( trig_t = 13; ) : 
                pitch == 9 ? ( trig_t = 16; ) : 
                pitch == 11 ? ( trig_t = 29; ) : 
                (oct < 2) ? (
                    pitch == 1 ? ( trig_t = 19 + (oct*35); ) : 
                    pitch == 3 ? ( trig_t = 20 + (oct*35); ) : 
                    pitch == 6 ? ( trig_t = 21 + (oct*35); ) : 
                    pitch == 8 ? ( trig_t = 22 + (oct*35); ) : 
                    pitch == 10 ? ( trig_t = 23 + (oct*35); ) : 0; 
                ) : (
                    u_base = (oct==2) ? 24 : 59;
                    pitch == 1 ? ( trig_t = u_base + 0; ) : 
                    pitch == 3 ? ( trig_t = u_base + 1; ) : 
                    pitch == 6 ? ( trig_t = u_base + 2; ) : 
                    pitch == 8 ? ( trig_t = u_base + 3; ) : 
                    pitch == 10 ? ( trig_t = u_base + 4; ) : 0; 
                );
            ) : ( nn == 24 ? trig_t = -1; ); 
            
            (trig_t != -2) ? (
                // Buffer the request immediately
                midi_cue_tab = trig_t;
                midi_cue_source = 0; // 0=Note
            );
        );
    );
);

// --- B. GATHER GMEM INPUT (Continuous Monitor) ---
gmem_cue_tab = -1;
gmem_source_addr = -1;

c_inst = gmem[GMEM_INST_BASE + slider5 - 1];
c_type = gmem[GMEM_TYPE_BASE + MY_TYPE_ID];
c_glob = gmem[GMEM_GLOBAL_ADDR];

// Priority within GMEM: Inst > Type > Global
(c_inst > 0) ? ( raw_val = c_inst; gmem_source_addr = GMEM_INST_BASE + slider5 - 1; ) :
(c_type > 0) ? ( raw_val = c_type; gmem_source_addr = GMEM_TYPE_BASE + MY_TYPE_ID; ) :
(c_glob > 0) ? ( raw_val = c_glob; gmem_source_addr = GMEM_GLOBAL_ADDR; ) : ( raw_val = 0; );

(raw_val > 0) ? (
    // Map Logic (PC + 1) -> Tab
    pc = raw_val - 1;
    t_cue = -2;
    pc == 101 ? ( t_cue = 29; ) :
    (pc >= 11 && pc <= 13) ? ( t_cue = 1 + (pc - 11); ) : 
    (pc >= 14 && pc <= 17) ? ( t_cue = 30 + (pc - 14); ) : 
    (pc >= 21 && pc <= 23) ? ( t_cue = 4 + (pc - 21); ) : 
    (pc >= 24 && pc <= 27) ? ( t_cue = 34 + (pc - 24); ) : 
    (pc >= 31 && pc <= 33) ? ( t_cue = 7 + (pc - 31); ) : 
    (pc >= 34 && pc <= 37) ? ( t_cue = 38 + (pc - 34); ) : 
    (pc >= 41 && pc <= 43) ? ( t_cue = 10 + (pc - 41); ) : 
    (pc >= 44 && pc <= 47) ? ( t_cue = 42 + (pc - 44); ) : 
    (pc >= 51 && pc <= 53) ? ( t_cue = 13 + (pc - 51); ) : 
    (pc >= 54 && pc <= 57) ? ( t_cue = 46 + (pc - 54); ) : 
    (pc >= 61 && pc <= 63) ? ( t_cue = 16 + (pc - 61); ) : 
    (pc >= 64 && pc <= 67) ? ( t_cue = 50 + (pc - 64); ) : 
    (pc >= 71 && pc <= 72) ? ( t_cue = 19 + (pc - 71); ) : 
    (pc >= 73 && pc <= 74) ? ( t_cue = 54 + (pc - 73); ) : 
    (pc >= 81 && pc <= 83) ? ( t_cue = 21 + (pc - 81); ) : 
    (pc >= 84 && pc <= 86) ? ( t_cue = 56 + (pc - 84); ) : 
    (pc >= 91 && pc <= 95) ? ( t_cue = 24 + (pc - 91); ) : 
    (pc >= 96 && pc <= 100) ? ( t_cue = 59 + (pc - 96); ); 
    
    (t_cue != -2) ? (
        gmem_cue_tab = t_cue;
    );
);


// --- C. DECISION LOGIC (Who Wins?) ---
// We check the buffers. If a buffer is populated, we ARM the cue system.

final_target_tab = -1;
final_source_type = -1; // 0=Note, 1=GMEM, 2=PC

// 1. MIDI Note (Highest)
(midi_cue_source == 0 && midi_cue_tab > -1) ? (
    final_target_tab = midi_cue_tab;
    final_source_type = 0;
) :
// 2. GMEM
(gmem_cue_tab > -1 && gmem_source_addr != cue_clear_addr) ? (
    final_target_tab = gmem_cue_tab;
    final_source_type = 1;
) :
// 3. MIDI PC
(midi_cue_source == 2 && midi_cue_tab > -1) ? (
    final_target_tab = midi_cue_tab;
    final_source_type = 2;
);

// If we have a target, ARM the system immediately
(final_target_tab > -1) ? (
    cue_armed = 1;
    cue_target_tab = final_target_tab;

    // AUTO-FOLLOW: Unlock GUI if the cue is NEW
    // This allows you to see the change happening.
    (cue_target_tab != mem[ui_play_prog_tab]) ? (
         mem[ui_locked_tab] = -1; 
         gmem[GM_BASE+1] = -1; 
    );
    
    // Remember address to clear later (only for GMEM)
    (final_source_type == 1) ? ( cue_clear_addr = gmem_source_addr; ) : ( cue_clear_addr = -1; );
);


// --- D. EXECUTION (The Bar Line) ---
samps_per_beat = (srate * 60) / tempo;
block_dur_beats = samplesblock / samps_per_beat;
check_pos = beat_position + block_dur_beats;
current_bar_num = floor(check_pos / 4);

// IMMEDIATE EXECUTION if stopped (fixes "only works when stopped" bug)
(play_state == 0 && cue_armed) ? ( current_bar_num = -999; last_bar_checked = -998; );

(current_bar_num != last_bar_checked) ? (
    last_bar_checked = current_bar_num;
    
    (cue_armed) ? (
        mem[ui_play_prog_tab] = cue_target_tab;
        mem[ui_play_offset] = 0;
        playback_shift = 0;
        gmem[GM_BASE+2] = cue_target_tab;
        pc_triggered = 1;
        
        // Reset buffers
        cue_armed = 0;
        cue_clear_pending = 1;  // Arm the cleanup phase
        midi_cue_tab = -1; // Clear MIDI One-Shots
        midi_cue_source = -1;
    );
);


// --- E. CLEANUP (Beat 1.1) ---
// Clear GMEM shortly AFTER the bar line (0.1 - 0.2 beats)
pos_in_bar = beat_position % 4.0; 
(cue_clear_addr >= 0 && cue_clear_pending && pos_in_bar >= 0.1) ? (
    gmem[cue_clear_addr] = 0;
    cue_clear_addr = -1;
    cue_clear_pending = 0;
);


// --- F. RESTORED AUDIO PREVIEW LOGIC ---
preview_trig ? (
    preview_chan < 1 ? preview_chan = 1 : preview_chan > 16 ? preview_chan = 16;
    mem[kill_note + preview_note] > 0 ? ( k_ch = mem[kill_chan + preview_note]; midisend(0, 0x80 | (k_ch-1), preview_note); );
    midisend(0, 0x90 | (preview_chan-1), preview_note | (preview_vel<<8));
    l_val = mem[row_len_base+mem[ui_selected_row]];
    l_ms = (l_val < 64) ? (10 + l_val * 3.75) : (250 + (l_val-64)*11.9);
    mem[kill_note + preview_note] = srate * l_ms * 0.001;
    mem[kill_chan + preview_note] = preview_chan;
    preview_trig = 0;
);
// ------------------------------------

// --- FORCE INVENTORY REFRESH (Heartbeat) ---
(time_precise() - last_maint_time > 3.0) ? (
    scan_all_tabs();
    last_maint_time = time_precise();
);











// =========================================================

(play_state == 0 && last_play_state != 0) ? (
    i_k=0; loop(128,
        mem[kill_note+i_k] > 0 ? (
            k_ch = mem[kill_chan+i_k]; k_ch < 1 ? k_ch = 1;
            midisend(0, 0x80 | (k_ch-1), i_k);
            mem[kill_note+i_k]=0;
        );
        i_k+=1;
    );
    mem[ui_last_step] = -1;
);
last_play_state = play_state;

playing = (play_state & 1);
t_pl = mem[ui_locked_tab] == -1 ? mem[ui_play_prog_tab] : mem[ui_locked_tab];

playing && t_pl != 0 && t_pl != -1 ? (
    sub_v = eff_sub(t_pl); bar_v = eff_bars(t_pl); swing_v = eff_swing(t_pl);
    is_half = eff_half(t_pl);
    spd_m = is_half ? 0.5 : 1.0; 
    st_v = bar_v * sub_v; 
    p_l = (bar_v * 4) / spd_m;
    curr_tab = mem[ui_play_prog_tab]; 
    curr_off = mem[ui_play_offset];
    (pc_triggered || curr_tab != last_play_tab || curr_off != last_play_offset) ? (
        curr_off >= bar_v ? curr_off = 0;
        target_beat = (curr_off * 4) / spd_m; 
        snap_grid = 4.0;
        next_grid = floor((beat_position + (snap_grid*0.5))/snap_grid) * snap_grid;
        natural_pos = next_grid % p_l; 
        playback_shift = target_beat - natural_pos;
        last_play_tab = curr_tab; 
        last_play_offset = curr_off; 
        pc_triggered = 0;
    );
    samps_per_beat = (srate * 60) / tempo;
    block_dur_beats = samplesblock / samps_per_beat;
    start_b = beat_position + playback_shift;
    end_b = start_b + block_dur_beats;
    scan_rate = is_half ? 0.5 : 1.0;
    steps_per_beat_grid = sub_v / 4;
    look_margin = steps_per_beat_grid * 1.5; 
    start_step_idx = floor(start_b * scan_rate * steps_per_beat_grid) - look_margin;
    end_step_idx = ceil(end_b * scan_rate * steps_per_beat_grid) + look_margin;
    h_solo = 0; 
    s_solo_chk=0; 
    loop(MAX_ROWS, mem[row_solo_base+s_solo_chk]?h_solo=1; s_solo_chk+=1;);
    (t_pl < 22) ? (
        cur_vel_ptr = vel_base + t_pl*vel_stride_tab;
        cur_grid_ptr = grid_base + t_pl*vel_stride_tab;
        cur_len_ptr = step_len_base + t_pl*vel_stride_tab;
    ) : (
        cur_vel_ptr = ext_vel_base + (t_pl-22)*vel_stride_tab;
        cur_grid_ptr = ext_grid_base + (t_pl-22)*vel_stride_tab;
        cur_len_ptr = ext_step_len_base + (t_pl-22)*vel_stride_tab;
    );
    s_idx_iter = start_step_idx;
    loop((end_step_idx - start_step_idx) + 1,
        step_grid_time = s_idx_iter / steps_per_beat_grid;
        step_beat_time = step_grid_time / scan_rate;
        grid_lookup_idx = s_idx_iter; 
        lookup_mod = st_v;
        p_step = grid_lookup_idx % lookup_mod;
        while(p_step < 0) ( p_step += lookup_mod; );
        sw_amt = (swing_v / 100) * 0.33; 
        step_in_beat = (grid_lookup_idx % steps_per_beat_grid) / steps_per_beat_grid; 
        swing_offset_beats = 0;
        (step_in_beat >= 0.5 && step_in_beat < 1.0) ? ( swing_offset_beats = sw_amt; );
        cycle_beat = step_beat_time % 4.0; 
        groove_slot = floor(cycle_beat * 8); 
        groove_slot = clamp(groove_slot, 0, 31);
        groove_val = mem[LOCAL_GROOVE_DB + groove_slot]; 
        groove_offset_beats = (groove_val * 0.125) * scan_rate;
        r_p = 0;
        loop(MAX_ROWS,
            p_me = h_solo ? mem[row_solo_base+r_p] : (mem[row_mute_base+r_p] == 0);
            p_me ? (
               row_data_idx = r_p*vel_stride_row + p_step;
               mem[cur_grid_ptr + row_data_idx] ? (
                   row_offs_pct = mem[row_offs_base + r_p];
                   row_offset_beats = row_offs_pct / 100.0; 
                   final_offset = (swing_offset_beats + groove_offset_beats + row_offset_beats) / scan_rate;
                   total_time_beats = step_beat_time + final_offset;
                   diff_beats = total_time_beats - start_b;
                   diff_samples = floor(diff_beats * samps_per_beat);
                   (diff_samples >= 0 && diff_samples < samplesblock) ? (
                        v_p = mem[cur_vel_ptr+row_data_idx]; 
                        v_p <= 0 ? v_p = slider1;
                        eff_h = eff_hum(t_pl); 
                        h_p = (mem[row_human_base+r_p]>=0 ? mem[row_human_base+r_p] : eff_h);
                        v_p = clamp(v_p + (rand(h_p*2)-h_p), 1, 127);
                        note_to_play = mem[row_note_base+r_p]; 
                        chan_to_play = mem[row_chan_base+r_p];
                        final_vel = floor(v_p * (mem[row_level_base+r_p]/100));
                        final_vel < 1 ? final_vel = 1 : final_vel > 127 ? final_vel = 127;
                        chan_to_play < 1 ? chan_to_play = 1 : chan_to_play > 16 ? chan_to_play = 16;
                        mem[kill_note + note_to_play] > 0 ? ( 
                            k_ch = mem[kill_chan + note_to_play]; 
                            midisend(0, 0x80|(k_ch-1), note_to_play); 
                        );
                        midisend(diff_samples, 0x90|(chan_to_play-1), note_to_play|(final_vel<<8));
                        step_len_val = mem[cur_len_ptr+row_data_idx]; 
                        ms_per_step_x = (60000 / tempo) * (4 / sub_v);
                        is_half ? ms_per_step_x *= 2;
                        l_ms = (step_len_val == 0) ? (mem[row_len_base+r_p]*10) : (step_len_val * ms_per_step_x * 0.98);
                        mem[kill_note + note_to_play] = (srate * (l_ms + (diff_samples / srate) * 1000) * 0.001);
                        mem[kill_chan + note_to_play] = chan_to_play;
                   );
               );
            );
            r_p += 1;
        );
        s_idx_iter += 1;
    );
 );   
i_k=0; 
loop(128,
    mem[kill_note+i_k]>0 ? (
        mem[kill_note+i_k]-=samplesblock;
        mem[kill_note+i_k]<=0 ? (
            k_ch = mem[kill_chan+i_k]; 
            k_ch < 1 ? k_ch = 1;
            midisend(0, 0x80 | (k_ch-1), i_k);
            mem[kill_note+i_k]=0;
        );
    );
    i_k+=1;
);


// --- FORCE INVENTORY REFRESH (Heartbeat) ---
// This ensures Lua scripts always know which tabs have patterns
(time_precise() - last_maint_time > 3.0) ? (
    scan_all_tabs();
    last_maint_time = time_precise();
);


@gfx 1618 740
grid_height = slider11; 
ext_noinit = 1.0;
ext_noundo = 1; 

// Add missing UI base offset if not in Part 1
ui_vel_edit_all = ui_base + 7;

shift_dn = (mouse_cap & 8);
ctrl_dn  = (mouse_cap & 4);
alt_dn   = (mouse_cap & 16);

function draw_text(x,y,s,r,g,b) ( gfx_set(r,g,b,1); gfx_x=x; gfx_y=y; gfx_drawstr(s); );
function rect(x,y,w,h,r,g,b,a) ( gfx_set(r,g,b,a); gfx_rect(x,y,w,h); );

function find_covering_head(row_idx, step_idx, st_v)
local(lb, s0, ii, l)
(
    lb = 1;
    loop(step_idx,
        s0 = step_idx - lb;
        ii = row_idx*vel_stride_row + s0;
        mem[curr_pat_g_ptr + ii] ? (
            l = mem[curr_pat_l_ptr + ii];
            l < 1 ? l = 1;
            l > lb ? ( lb = 1000000; ii; ) : 0;
        ) : 0;
        lb += 1;
    );
    lb > 999999 ? ii : -1;
);

function draw_color_popup(px, py) local(i, row_hh, bw, bh, rx, ry, hover, c_name) (
    bw = 180; row_hh = 18; bh = row_hh * 18 + 6;
    px + bw > gfx_w ? px = gfx_w - bw - 2;
    py + bh > gfx_h ? py = gfx_h - bh - 2;
    px < 2 ? px = 2; py < 2 ? py = 2;
    rect(px, py, bw, bh, 0.08, 0.08, 0.08, 1);
    rect(px+1, py+1, bw-2, bh-2, 0.15, 0.15, 0.15, 1);
    i=0; loop(18,
        rx = px + 4; ry = py + 3 + i*row_hh;
        hover = (mx>=rx && mx<px+bw-4 && my>=ry && my<ry+row_hh);
        hover ? rect(rx, ry, bw-8, row_hh, 0.25,0.25,0.25,1) : 0;
        get_menu_item(#color_menu, i, #cn); 
        get_palette_values(i); 
        gfx_set(cr, cg, cb, 1);
        gfx_x = rx + 10; gfx_y = ry + 4; gfx_drawstr(#cn);
        (!mb && p_mb==1 && hover) ? ( 
            mem[row_color_base + color_popup_row] = i; 
            color_popup_active = 0; 
            mem[ui_selected_row] = color_popup_row;
        );
        i+=1;
    );
    (mb && p_mb==0 && !(mx>=px && mx<px+bw && my>=py && my<py+bh)) ? color_popup_active = 0;
);

function dr_p(x,y,lab,v_p,min_v,max_v,w) (
    draw_text(x, y, lab, 0.7,0.7,0.7);
    max_v == 100 ? sprintf(#vs, "%d%%", mem[v_p]) : sprintf(#vs, "%d", mem[v_p]);
    draw_text(x+w-25, y, #vs, 1,1,1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+20) ? (
        capture_id = v_p; capture_ptr = v_p; capture_slider_idx = 0;
        capture_min = min_v; capture_max = max_v; capture_is_signed = (min_v < 0);
        (v_p >= row_offs_base && v_p < row_offs_base + MAX_ROWS) ? capture_mode = 2 : capture_mode = 0;
    );
);

function dr_glob(id_num, x, y, w, lab, val_in, min_v, max_v, is_subdiv, is_swing, ov_addr, is_signed, slider_idx)
  local(v, is_ov, curr_val, active_tab, target_addr)
(
    active_tab = mem[ui_edit_tab]; is_ov = 0; curr_val = val_in; target_addr = -1;
    (active_tab > 0 && ov_addr >= 0) ? (
        (active_tab < 22) ? target_addr = ov_addr + active_tab
        : (active_tab < TOTAL_TABS) ? (
            ov_addr == bars_ov_base ? target_addr = ext_bars_ov_base + (active_tab-22) :
            ov_addr == subdiv_ov_base ? target_addr = ext_subdiv_ov_base + (active_tab-22) :
            ov_addr == hum_ov_base ? target_addr = ext_hum_ov_base + (active_tab-22) :
            ov_addr == swing_ov_base ? target_addr = ext_swing_ov_base + (active_tab-22) : 0;
        );
        target_addr >= 0 ? (
            ov_val = mem[target_addr];
            (is_signed && ov_val >= 0) || (!is_signed && ov_val > 0) ? ( is_ov = 1; curr_val = ov_val; );
        );
    );
    rect(x, y, w, 20, 0.2, 0.2, 0.2, 1);
    draw_text(x+5, y+5, lab, 0.7,0.7,0.7);
    is_subdiv ? (
        v = curr_val;
        v==0?strcpy(#s,"8"):v==1?strcpy(#s,"12"):v==2?strcpy(#s,"16"):v==3?strcpy(#s,"24"):strcpy(#s,"32");
    )
    : is_swing ? ( sprintf(#s, "%d%%", curr_val); )
    : ( sprintf(#s, "%d", curr_val); );
    draw_text(x+w-35, y+5, #s, 1, 1, 1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+20) ? (
        capture_id = id_num; capture_min = min_v; capture_max = max_v; capture_is_signed = is_signed; capture_mode = 0;
        (rmb && active_tab > 0 && target_addr >= 0) ? (
            capture_ptr = target_addr; capture_slider_idx = 0;
            mem[capture_ptr] < 0 ? mem[capture_ptr] = val_in;
            !is_signed && mem[capture_ptr] == 0 ? mem[capture_ptr] = val_in;
        ) : (mb) ? (
            is_ov ? ( capture_ptr = target_addr; capture_slider_idx = 0; ) : ( capture_slider_idx = slider_idx; );
        );
    );
);

gfx_clear = 0.05;
mx = mouse_x; my = mouse_y;
mb = mouse_cap & 1;
rmb = mouse_cap & 2;

p_mb  = l_mb;  
p_rmb = l_rmb; 
p_mx = l_mx; 
p_my = l_my; 

(p_mb == 1 && mb == 0 && !color_popup_active) ? ( scan_active_tab(); );

(!mb && !rmb) ? (
  capture_id = 0;          
  capture_slider_idx = 0;  
  len_drag_active = 0; 
  row_drag_active = 0; 
  drag_mode = 0; 
  last_drag_idx = -1; 
  drag_accum_gen = 0; 
  drag_lock_row = -1; 
);

l_mb = mb;
l_rmb = rmb;
l_mx = mx;
l_my = my;

gfx_getchar(); 

ui_lock = (capture_id == 9999);
help_active ? capture_id = 90000;

UI_TOP_X=5; UI_TOP_Y=10; UI_GAP_X=40; UI_ROW_H=20;
HDR_X=UI_TOP_X; HDR_Y=UI_TOP_Y; HDR_W=240; HDR_H=20;
GLOB_LBL_W=180; GLOB_LBL_YOFF=0;
GW_DEFVEL_W=150; GW_ROWS_W=180; GW_INST_W=130;

ROW2_Y_OFFSET=40; ROW2_Y=UI_TOP_Y + ROW2_Y_OFFSET;
FOLLOW_LBL_X=UI_TOP_X; FOLLOW_LBL_W=55;
FOLLOW_BOX_X=UI_TOP_X + 60; FOLLOW_BOX_W=20; FOLLOW_BOX_H=16;

BTN_H=18; BTN_Y=ROW2_Y; BTN_X0=UI_TOP_X + 120;
BTN_W_COPY=109; BTN_W_PASTE=114; BTN_W_CLEAR=114; BTN_GAP=10;

PAT_LBL_W=190; PAT_BOX_H=20; PAT_BOX_W=120; PAT_BOX_GAP=70;
HIT_PAD_L=2; HIT_PAD_R=2;

function calc_vis_beat(t_in) (
    sub_v = eff_sub(t_in); 
    bar_v = eff_bars(t_in); 
    is_half = eff_half(t_in);
    spd_m = is_half ? 0.5 : 1.0;
    p_l = (bar_v * 4) / spd_m;
    playing_tab = (mem[ui_locked_tab] <= 0) ? mem[ui_play_prog_tab] : mem[ui_locked_tab];
    offset_add = 0; 
    (play_state & 1 && t_in == playing_tab) ? ( offset_add = playback_shift; );
    buffer_beats = (samplesblock / srate) * (tempo / 60);
    visual_pos = beat_position - buffer_beats ;
    play_state & 1 ? fmod_pos(visual_pos + offset_add, p_l) * spd_m : 0;
);

function btn(x,y,w,txt) (
    rect(x,y,w,BTN_H, 0.3,0.3,0.3,1);
    draw_text(x+5,y+5,txt,1,1,1);
    (mb && p_mb == 0 && mx>=x && mx<x+w && my>=y && my<y+BTN_H);
);

(mb && capture_id != 0 && capture_id != 9999 && capture_id != 12 && capture_id != 13 && capture_id != 12012 && capture_id != 42424 && capture_id != 88888 && capture_id != 77777 && capture_id != 11111) ? (
    drag_sens = (capture_max - capture_min) > 60 ? 1.0 : 5.0;
    capture_mode == 2 ? drag_sens = 5.0;
    drag_accum_gen += (mx - p_mx);
    abs(drag_accum_gen) >= drag_sens ? (
        inc = drag_accum_gen / drag_sens;
        inc = (inc > 0) ? floor(inc) : ceil(inc);
        drag_accum_gen -= (inc * drag_sens);
        capture_slider_idx > 0 ? (
            sv = slider(capture_slider_idx); 
            nv = clamp(sv + inc, capture_min, capture_max);
            slider(capture_slider_idx) = nv; 
            slider_automate(capture_slider_idx);
            capture_slider_idx == 1 ? (
                i_rst = 0;
                loop(MAX_ROWS * MAX_STEPS,
                    mem[curr_pat_g_ptr + i_rst] == 0 ? mem[curr_pat_v_ptr + i_rst] = 0;
                    i_rst += 1;
                );
            );
        ) : (
            mv = mem[capture_ptr]; 
            nv = clamp(mv + inc, capture_min, capture_max);
            capture_mode != 2 && capture_is_signed ? (
               nv <= 0 ? nv = -1; 
               mv == -1 && inc > 0 ? nv = 0;
            );
            mem[capture_ptr] = nv;
        );
    );
);

tx = UI_TOP_X; ty = UI_TOP_Y;
gfx_setfont(1, "Arial", 30, 'b');
bri = .9;
// HDR_Y-2 FIX APPLIED BELOW:
draw_text(HDR_X+5, HDR_Y-2 + 8, "N2N Drum Arranger", 0.2*bri,  1.0*bri,  1.0*bri);
gfx_setfont(0);
row1_y = UI_TOP_Y + 5; 
x1 = HDR_X + HDR_W + UI_GAP_X - 10;
gfx_set(0.8,0.8,0.8,1); 
gfx_x = x1 + 25; 
gfx_y = row1_y + 8 + GLOB_LBL_YOFF; 
gfx_drawstr("GLOBAL SETTINGS:");

GW_ROWS_W = 170; 
GW_HEIGHT_W = 100; 
xfix = 180;
x1 = x1 + xfix;

track_num > 0 ? (  // Background Box (Using Track Color)
rect(x1-12, row1_y-14, 1256, 44, track_r, track_g, track_b, 1);

// Determine Text Color (Black or White) based on brightness
lum = (track_r * 0.299) + (track_g * 0.587) + (track_b * 0.114);
lum > 0.5 ? gfx_set(0,0,0,1) : gfx_set(1,1,1,1);
// Draw Text
sprintf(#trk_str, "Track");
gfx_measurestr(#trk_str, tw, th);
gfx_x = x1+973 + (60-tw)/2;
gfx_y = row1_y-8 + (18-th)/2;
gfx_setfont(1, "Arial", 22, 'b');
gfx_drawstr(#trk_str);
gfx_setfont(0);

sprintf(#trk_str2, "%d", track_num);
gfx_measurestr(#trk_str2, tw, th);
gfx_x = x1+1019 + (60-tw)/2;
gfx_y = row1_y-20 + (18-th)/2;
gfx_setfont(1, "Arial", 48, 'b');
gfx_drawstr(#trk_str2);
gfx_setfont(0);
);

dr_glob(16, x1-6, row1_y+3, GW_ROWS_W+26, "MAX ROWS TO SHOW:", slider7, 1, 128,  0, 0, -1, 0, 7);  
x1 += GW_ROWS_W + 33;
dr_glob(17, x1+35, row1_y+3, GW_HEIGHT_W+31, "HEIGHT:", slider11, 10, 30, 0, 0, -1, 0, 11); 
x1 += GW_HEIGHT_W + UI_GAP_X;
dr_glob(15, x1+ 75, row1_y+3, GW_INST_W+1, "INST ID:", slider5, 1, 512,  0, 0, -1, 0, 5); 
x1 += GW_INST_W + UI_GAP_X;

btn(x1+87, row1_y+4, 85, " LOAD KIT") ? ( load_kit_from_slider(); ); 
btn(x1+177, row1_y+4, 85, " ADD KIT") ? ( add_kit_from_slider(); );
btn(x1+610, row1_y+4, 18, "?") ? ( help_active = !help_active; );



// --- N2N IO BUTTONS ---
io_x = x1 + 293; gap = 33;
btn(io_x, row1_y+4, 27, "<-") ? ( gfx_set(1,0,0,1); import_n2n_data(0); ); // Import Single
btn(io_x+gap, row1_y+4, 27, "<=") ? ( gfx_set(1,0,0,1); import_n2n_data(1); ); // Import Bank
btn(io_x+gap*2, row1_y+4, 27, "=>") ? ( gfx_set(1,0,0,1); export_n2n_data(1); ); // Export Bank
btn(io_x+gap*3, row1_y+4, 27, "->") ? ( gfx_set(1,0,0,1); export_n2n_data(0); ); // Export Single


x1 = x1 - xfix;
rect(0, 45, gfx_w, 1, 0.25, 0.25, 0.25, 1);
row2_y = ROW2_Y; 

mem[ui_locked_tab] == -1 ? mem[ui_edit_tab] = mem[ui_play_prog_tab]; 
is_follow = (mem[ui_locked_tab] == -1);
draw_text(FOLLOW_LBL_X+5, row2_y+5, "FOLLOW:", 0.8,0.8,0.8); 
rect(FOLLOW_BOX_X+5, row2_y, FOLLOW_BOX_W, FOLLOW_BOX_H, 0.2, 0.2, 0.2, 1); 
is_follow ? draw_text(FOLLOW_BOX_X+10, row2_y+5, "X", 0,1,0);
(mb && p_mb == 0 && mx>=FOLLOW_BOX_X && mx<FOLLOW_BOX_X+FOLLOW_BOX_W && my>=row2_y && my<row2_y+FOLLOW_BOX_H) ? ( 
    mem[ui_locked_tab] == -1 ? mem[ui_locked_tab] = 29 : mem[ui_locked_tab] = -1; 
    gmem[GM_BASE+1] = mem[ui_locked_tab]; 
);

t_e = mem[ui_edit_tab];
(t_e == 0) ? (
    gfx_set(1, 0.2, 0.2, 1);
    gfx_setfont(1, "Arial", 48, 'b');
    gfx_x = (gfx_w/2) - 150; 
    gfx_y = (gfx_h/2) + 50; 
    gfx_drawstr("PATTERN OFF");
    gfx_setfont(1, "Arial", 18, 'b');
) : (
    (t_e < 22) ? ( 
        curr_pat_v_ptr = vel_base + t_e*vel_stride_tab; 
        curr_pat_g_ptr = grid_base + t_e*vel_stride_tab; 
        curr_pat_l_ptr = step_len_base + t_e*vel_stride_tab; 
    ) : ( 
        curr_pat_v_ptr = ext_vel_base + (t_e-22)*vel_stride_tab; 
        curr_pat_g_ptr = ext_grid_base + (t_e-22)*vel_stride_tab; 
        curr_pat_l_ptr = ext_step_len_base + (t_e-22)*vel_stride_tab; 
    );
    bx = BTN_X0;
    btn(bx-15, row2_y, BTN_W_COPY+21, "  Copy Pattern") ? ( 
        memcpy(copy_tab_v_buf, curr_pat_v_ptr, vel_stride_tab); 
        memcpy(copy_tab_g_buf, curr_pat_g_ptr, vel_stride_tab); 
        memcpy(copy_tab_l_buf, curr_pat_l_ptr, vel_stride_tab);
        cp_valid = 1;
        cp_bars = eff_bars(mem[ui_edit_tab]);
        cp_sub = eff_sub(mem[ui_edit_tab]);
        cp_hum = eff_hum(mem[ui_edit_tab]);
        cp_sw = eff_swing(mem[ui_edit_tab]);
        cp_half = eff_half(mem[ui_edit_tab]);
    ); 
    bx += BTN_W_COPY + BTN_GAP;
    btn(bx+1, row2_y, BTN_W_PASTE+16, " Paste Pattern") ? ( 
        memcpy(curr_pat_v_ptr, copy_tab_v_buf, vel_stride_tab); 
        memcpy(curr_pat_g_ptr, copy_tab_g_buf, vel_stride_tab); 
        memcpy(curr_pat_l_ptr, copy_tab_l_buf, vel_stride_tab); 
        cp_valid ? (
            act_t = mem[ui_edit_tab];
            (act_t < 22) ? (
                mem[bars_ov_base+act_t] = cp_bars;
                mem[subdiv_ov_base+act_t] = (cp_sub==8?0:cp_sub==12?1:cp_sub==16?2:cp_sub==24?3:4);
                mem[hum_ov_base+act_t] = cp_hum;
                mem[swing_ov_base+act_t] = cp_sw;
                mem[half_speed_ov_base+act_t] = cp_half;
            ) : (
                mem[ext_bars_ov_base+(act_t-22)] = cp_bars;
                mem[ext_subdiv_ov_base+(act_t-22)] = (cp_sub==8?0:cp_sub==12?1:cp_sub==16?2:cp_sub==24?3:4);
                mem[ext_hum_ov_base+(act_t-22)] = cp_hum;
                mem[ext_swing_ov_base+(act_t-22)] = cp_sw;
                mem[ext_half_speed_ov_base+(act_t-22)] = cp_half;
            );
            scan_active_tab();    
        );
    ); 
    bx += BTN_W_PASTE + BTN_GAP;
    btn(bx+12, row2_y, BTN_W_CLEAR+16, " Clear Pattern") ? ( 
        memset(curr_pat_g_ptr, 0, vel_stride_tab); 
        memset(curr_pat_v_ptr, 0, vel_stride_tab); 
        memset(curr_pat_l_ptr, 0, vel_stride_tab);
        scan_active_tab();
    ); 
    bx += BTN_W_CLEAR + BTN_GAP;
    pat_lbl_x = bx; 
    gfx_set(0.8,0.8,0.8,1); 
    gfx_x = pat_lbl_x; 
    gfx_y = row2_y + 5; 
    gfx_drawstr("    PATTERN SETTINGS:"); 
    pat_x = pat_lbl_x + PAT_LBL_W;
    pat_y = row2_y - 0; 
    box_w = PAT_BOX_W; 
    box_h = PAT_BOX_H; 
    gap_w = PAT_BOX_GAP;
    bars_x = pat_x; 
    active_tab = mem[ui_edit_tab]; 
    bars_addr = -1; 
    (active_tab > 0) ? ( bars_addr = (active_tab < 22) ? (bars_ov_base + active_tab) : (ext_bars_ov_base + (active_tab-22)); );
    curr_bars = eff_bars(active_tab); 
    rect(bars_x+11, pat_y, box_w+11, box_h, 0.2,0.2,0.2,1); 
    draw_text(bars_x+15, pat_y+5, "BARS:", 0.7,0.7,0.7); 
    sprintf(#s, "%d", curr_bars); 
    draw_text(bars_x+box_w-11, pat_y+5, #s, 1,1,1);
    bars_hit_l = bars_x + 11; 
    bars_hit_r = bars_x + box_w + 22; 
    (mx>=bars_hit_l && mx<bars_hit_r && my>=pat_y && my<pat_y+box_h && mb && p_mb==0) ? ( capture_id = 12; drag_accum = 0; );
    (mb && capture_id == 12) ? ( 
        drag_accum += (mx - p_mx); 
        abs(drag_accum) > 8 ? ( 
            step_dir = drag_accum > 0 ? 1 : -1; 
            drag_accum = 0; 
            target_addr = bars_addr; 
            (active_tab > 0 && target_addr >= 0) ? ( 
                mem[target_addr] <= 0 ? mem[target_addr] = slider4; 
                mem[target_addr] = clamp(mem[target_addr] + step_dir, 1, 4); 
            ); 
        ); 
    );
    sub_x = bars_x + box_w + gap_w; 
    ov_s = eff_sub(active_tab); 
    curr_s = (ov_s==8?0:ov_s==12?1:ov_s==16?2:ov_s==24?3:4);
    rect(sub_x+1, pat_y, box_w+11, box_h, 0.2,0.2,0.2,1); 
    draw_text(sub_x+6, pat_y+5, "SUBDIV:", 0.7,0.7,0.7); 
    v=curr_s; v==0?strcpy(#s,"8"):v==1?strcpy(#s,"12"):v==2?strcpy(#s,"16"):v==3?strcpy(#s,"24"):strcpy(#s,"32"); 
    draw_text(sub_x+box_w-23, pat_y+5, #s, 1,1,1);
    sub_hit_l = sub_x + 1; 
    sub_hit_r = sub_x + box_w + 12; 
    (mx>=sub_hit_l && mx<sub_hit_r && my>=pat_y && my<pat_y+box_h && mb && p_mb==0) ? ( capture_id = 13; drag_accum = 0; );
    (mb && capture_id == 13) ? ( 
        drag_accum += (mx - p_mx); 
        abs(drag_accum) > 8 ? ( 
            step_dir = drag_accum > 0 ? 1 : -1; 
            drag_accum = 0; 
            target_addr = (active_tab < 22) ? (subdiv_ov_base+active_tab) : (ext_subdiv_ov_base+(active_tab-22)); 
            mem[target_addr] < 0 ? mem[target_addr] = slider3; 
            mem[target_addr] = clamp(mem[target_addr] + step_dir, 0, 4); 
        ); 
    );
    sw_x = sub_x + box_w + gap_w; 
    rect(sw_x-8, pat_y, box_w+24, box_h, 0.2,0.2,0.2,1); 
    draw_text(sw_x+5, pat_y+5, "SWING:", 0.7,0.7,0.7);
    sw_addr = -1; 
    (active_tab > 0) ? ( sw_addr = (active_tab < 22) ? (swing_ov_base + active_tab) : (ext_swing_ov_base + (active_tab-22)); );
    curr_sw = eff_swing(active_tab); 
    sprintf(#s, "%d%%", curr_sw); 
    is_sw_local = (sw_addr >= 0 && mem[sw_addr] >= 0);
    pl_x = sw_x + 55;
    rect(pl_x, pat_y, 15, 16, 0.2,0.2,0.2,1);
    is_sw_local ? draw_text(pl_x+3, pat_y+5, "M", 1,0.5,0) : draw_text(pl_x+3, pat_y+5, "P", 0,1,1);
    (mb && p_mb==0 && mx>=pl_x && mx<pl_x+15 && my>=pat_y-1 && my<pat_y-1+box_h) ? (
        is_sw_local ? ( mem[sw_addr] = -1; ) : ( mem[sw_addr] = clamp(eff_swing(active_tab), 0, 100); )
    );
    draw_text(sw_x+box_w-35, pat_y+5, #s, 1,1,1);
    sw_hit_l = pl_x + 20; 
    sw_hit_r = sw_x + box_w + 16;
    (mb && p_mb==0 && mx>=sw_hit_l && mx<sw_hit_r && my>=pat_y && my<pat_y+box_h) ? (
        (is_sw_local) ? (
            capture_id = 12012;
            capture_min = 0;
            capture_max = 100;
            capture_is_signed = 0;
            sw_addr >= 0 ? (
                mem[sw_addr] < 0 ? mem[sw_addr] = clamp(eff_swing(active_tab), 0, 100);
                capture_ptr = sw_addr;
                capture_slider_idx = 0;
            );
        );
    );
    (mb && capture_id == 12012) ? ( 
        d_delta = (mx - p_mx); 
        mv = mem[capture_ptr]; 
        nv = clamp(mv + d_delta, 0, 100); 
        mem[capture_ptr] = nv; 
    );
    hum_x = sw_x + box_w + gap_w; 
    dr_glob(11, hum_x+9, pat_y, box_w+7, "HUMANIZE:", slider2, 0, 25, 0, 0, hum_ov_base, 1, 2);
    curr_sub_val = eff_sub(mem[ui_edit_tab]);
    st_x = hum_x + box_w + gap_w; 
    (curr_sub_val == 24 || curr_sub_val == 32) ? (
        hf_x = st_x-30; 
        st_x = hf_x + 14 + gap_w; 
        hf_act = eff_half(mem[ui_edit_tab]);
        (mb && p_mb == 0 && mx>=hf_x && mx<hf_x+80 && my>=pat_y && my<pat_y+box_h) ? (
            t_addr = (mem[ui_edit_tab] < 22) ? half_speed_ov_base + mem[ui_edit_tab] : ext_half_speed_ov_base + (mem[ui_edit_tab]-22);
            mem[t_addr] = !mem[t_addr];
        );
        rect(hf_x, pat_y, 80, box_h, 0.2, 0.2, 0.2, 1);
        !hf_act ? ( gfx_set(0.6, 0.6, 0.6, 1); gfx_rect(hf_x, pat_y, 40, box_h); ); 
        hf_act  ? ( gfx_set(0.6, 0.6, 0.6, 1); gfx_rect(hf_x+40, pat_y, 40, box_h); ); 
        !hf_act ? gfx_set(0,0,0,1) : gfx_set(0.5,0.5,0.5,1);
        draw_text(hf_x+10, pat_y+5, "1x", 0,0,0); 
        hf_act ? gfx_set(0,0,0,1) : gfx_set(0.5,0.5,0.5,1);
        draw_text(hf_x+47, pat_y+5, "1/2", 0,0,0);
        gfx_set(0,0,0,1); 
        gfx_line(hf_x+40, pat_y, hf_x+40, pat_y+box_h);
    );
    btn(st_x, pat_y+1, 84, " STRETCH") ? ( 
        gfx_x = st_x; 
        gfx_y = pat_y + 20;
        sel_stretch = gfx_showmenu("Stretch Pattern 2x (Short)|Stretch Pattern 2x (Long)|Stretch Pattern 4x (Short)|Stretch Pattern 4x (Long)||Stretch Selected Row 2x (Short)|Stretch Selected Row 2x (Long)|Stretch Selected Row 4x (Short)|Stretch Selected Row 4x (Long)");
        sel_stretch > 0 ? (
            (sel_stretch <= 4) ? ( is_pattern = 1; base_s = sel_stretch; ) : ( is_pattern = 0; base_s = sel_stretch - 4; );
            factor = (base_s <= 2) ? 2 : 4;
            is_long = (base_s == 2 || base_s == 4);
            st_cnt = eff_bars(mem[ui_edit_tab]) * curr_sub_val;
            r_start = is_pattern ? 0 : mem[ui_selected_row];
            r_end = is_pattern ? MAX_ROWS : mem[ui_selected_row] + 1;
            (mem[ui_edit_tab] < 22) ? (
                basev = vel_base + mem[ui_edit_tab]*vel_stride_tab;
                baseg = grid_base + mem[ui_edit_tab]*vel_stride_tab;
                basel = step_len_base + mem[ui_edit_tab]*vel_stride_tab;
            ) : (
                basev = ext_vel_base + (mem[ui_edit_tab]-22)*vel_stride_tab;
                baseg = ext_grid_base + (mem[ui_edit_tab]-22)*vel_stride_tab;
                basel = ext_step_len_base + (mem[ui_edit_tab]-22)*vel_stride_tab;
            );
            r_iter = r_start;
            loop(r_end - r_start,
                row_offset = r_iter * vel_stride_row;
                memcpy(copy_row_v_buf, basev + row_offset, st_cnt);
                memcpy(copy_row_g_buf, baseg + row_offset, st_cnt);
                memcpy(copy_row_l_buf, basel + row_offset, st_cnt);
                memset(basev + row_offset, 0, st_cnt);
                memset(baseg + row_offset, 0, st_cnt);
                memset(basel + row_offset, 0, st_cnt);
                s_idx = 0; 
                loop_limit = ceil(st_cnt / factor);
                loop(loop_limit,
                    target_idx = s_idx * factor;
                    (target_idx < st_cnt) ? (
                        mem[basev + row_offset + target_idx] = mem[copy_row_v_buf + s_idx];
                        mem[baseg + row_offset + target_idx] = mem[copy_row_g_buf + s_idx];
                        raw_len = mem[copy_row_l_buf + s_idx];
                        new_len = raw_len;
                        is_long ? ( new_len = (raw_len < 1 ? 1 : raw_len) * factor; );
                        mem[basel + row_offset + target_idx] = new_len;
                    );
                    s_idx += 1;
                );
                r_iter += 1;
            );
        );
    );
    rect(0, 74, gfx_w, 1, 0.25, 0.25, 0.25, 1);
);

// --- DEBUG DISPLAY (Remove after fixing) ---
gfx_set(1,1,1,1);
gfx_x = 10; gfx_y = gfx_h - 80;
sprintf(#debug1, "ARMED:%d TARGET:%d beats_to_bar:%.4f", cue_armed, cue_target_tab, beats_to_bar);
gfx_drawstr(#debug1);
gfx_y = gfx_h - 60;
sprintf(#debug2, "G:%d T:%d I:%d", gmem[GMEM_GLOBAL_ADDR], gmem[GMEM_TYPE_BASE+1], gmem[GMEM_INST_BASE+slider5-1]);
gfx_drawstr(#debug2);
gfx_y = gfx_h - 40;
sprintf(#debug3, "pos:%.2f clear_mode:%d", pos_in_bar, cue_clear_mode);
gfx_drawstr(#debug3);

ty = row2_y + 30; 
tx = 10;
gui_t = 0;
loop(TOTAL_TABS,
    my_row = mem[tab_ui_row_base + gui_t];
    (my_row == 1) ? (
        tw = mem[tab_w_base + gui_t]; 
        is_ed = (gui_t == mem[ui_edit_tab]);
        t_r = mem[tab_col_r + gui_t];
        t_g = mem[tab_col_g + gui_t];
        t_b = mem[tab_col_b + gui_t];
        is_ed ? (
             rect(tx, ty, tw-5, 26, 1, 1, 1, 1); 
             rect(tx+1, ty+1, tw-7, 24, t_r, t_g, t_b, 1);
        ) : (
             rect(tx, ty, tw-5, 26, t_r*0.4, t_g*0.4, t_b*0.4, 1);
        );
        get_t_name(gui_t, #tn); 
        is_ed ? ( draw_text(tx+5, ty+9, #tn, 0, 0, 0); ) : ( draw_text(tx+5, ty+9, #tn, 1, 1, 1); );
        (mb && p_mb == 0 && mx>=tx && mx<tx+tw-24 && my>=ty && my<ty+26) ? ( 
            (time_precise() - last_tab_clk < 0.3 && last_tab_idx == gui_t) ? (
                mem[ui_locked_tab] = gui_t; 
                mem[ui_edit_tab] = gui_t;   
                gmem[GM_BASE+1] = mem[ui_locked_tab]; 
                last_tab_clk = 0; 
            ) : (
                mem[ui_locked_tab] != -1 ? (
                    mem[ui_edit_tab] = gui_t; 
                    mem[ui_play_offset] = 0; 
                    playback_shift = 0; 
                );
                mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
                last_tab_clk = time_precise(); 
                last_tab_idx = gui_t;
            );
        );
        lx=tx+tw-24; ly=ty+5; lw=14; lh=16; 
        rect(lx,ly,lw,lh, 0.1,0.1,0.1,1); 
        (mb && p_mb == 0 && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_locked_tab]=(mem[ui_locked_tab]==gui_t?-1:gui_t); 
            gmem[GM_BASE+1]=mem[ui_locked_tab]; 
            mem[ui_play_offset] = 0; 
            playback_shift = 0; 
        );
        (rmb && !p_rmb && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_edit_tab] = gui_t; 
            mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
        );
        mem[ui_locked_tab] == gui_t ? rect(lx+2,ly+2,lw-4,lh-4, 0.3,.6,.7,1); 
        (mem[ui_play_prog_tab] == gui_t) ? (gfx_set(1,1,0,1); gfx_circle(tx+tw-17, ty+13, 2, 1););
        mem[LOC_TAB_POPULATED + gui_t] ? (
            gfx_set(1, 1, 1, 1);
            gfx_rect(tx+1, ty+1, 2, 23);
            gfx_rect(tx+1, ty+1, 14, 2);
            gfx_rect(tx+1, ty+23, 14, 2);
        );
        tx+=tw;
    );
    gui_t+=1;
);

ty += 30; 
tx = 10;
gui_t = 0;
loop(TOTAL_TABS,
    my_row = mem[tab_ui_row_base + gui_t];
    (my_row == 2) ? (
        tw = mem[tab_w_base + gui_t]; 
        is_ed = (gui_t == mem[ui_edit_tab]);
        t_r = mem[tab_col_r + gui_t];
        t_g = mem[tab_col_g + gui_t];
        t_b = mem[tab_col_b + gui_t];
        is_ed ? (
             rect(tx, ty, tw-5, 26, 1, 1, 1, 1); 
             rect(tx+1, ty+1, tw-7, 24, t_r, t_g, t_b, 1);
        ) : (
             rect(tx, ty, tw-5, 26, t_r*0.4, t_g*0.4, t_b*0.4, 1);
        );
        get_t_name(gui_t, #tn); 
        is_ed ? ( draw_text(tx+5, ty+9, #tn, 0, 0, 0); ) : ( draw_text(tx+5, ty+9, #tn, 1, 1, 1); );
        (mb && p_mb == 0 && mx>=tx && mx<tx+tw-24 && my>=ty && my<ty+26) ? ( 
            (time_precise() - last_tab_clk < 0.3 && last_tab_idx == gui_t) ? (
                mem[ui_locked_tab] = gui_t; 
                mem[ui_edit_tab] = gui_t;   
                gmem[GM_BASE+1] = mem[ui_locked_tab]; 
                last_tab_clk = 0; 
            ) : (
                mem[ui_locked_tab] != -1 ? (
                    mem[ui_edit_tab] = gui_t; 
                    mem[ui_play_offset] = 0; 
                    playback_shift = 0; 
                );
                mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
                last_tab_clk = time_precise(); 
                last_tab_idx = gui_t;
            );
        );
        lx=tx+tw-24; ly=ty+5; lw=14; lh=16; 
        rect(lx,ly,lw,lh, 0.1,0.1,0.1,1); 
        (mb && p_mb == 0 && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_locked_tab]=(mem[ui_locked_tab]==gui_t?-1:gui_t); 
            gmem[GM_BASE+1]=mem[ui_locked_tab]; 
            mem[ui_play_offset] = 0; 
            playback_shift = 0; 
        );
        (rmb && !p_rmb && mx>=lx && mx<lx+lw && my>=ly && my<ly+lh) ? ( 
            mem[ui_edit_tab] = gui_t; 
            mem[ui_locked_tab] == 0 ? mem[ui_locked_tab] = -1; 
        );
        mem[ui_locked_tab] == gui_t ? rect(lx+2,ly+2,lw-4,lh-4, 0.3,.6,.7,1); 
        (mem[ui_play_prog_tab] == gui_t) ? (gfx_set(1,1,0,1); gfx_circle(tx+tw-17, ty+13, 2, 1););
        mem[LOC_TAB_POPULATED + gui_t] ? (
            gfx_set(1, 1, 1, 1);
            gfx_rect(tx+1, ty+1, 2, 23);
            gfx_rect(tx+1, ty+1, 14, 2);
            gfx_rect(tx+1, ty+23, 14, 2);
        );
        tx+=tw;
    );
    gui_t+=1;
);

(t_e != 0) ? (
    t_e = mem[ui_edit_tab]; 
    sel_r = mem[ui_selected_row]; 
    sel_r >= MAX_ROWS ? (sel_r = MAX_ROWS - 1; mem[ui_selected_row] = sel_r;);
    ty+=30; 
    pk_w = (gfx_w-20)/128; 
    rect(10, ty, gfx_w-20, 32, 0.02, 0.02, 0.02, 1);
    i_p=0; 
    loop(128,
        px=10+i_p*pk_w; 
        m=i_p%12; 
        is_blk=(m==1||m==3||m==6||m==8||m==10); 
        is_sel = (mem[row_note_base+sel_r] == i_p);
        is_blk ? ( 
            is_sel ? rect(px, ty, pk_w-1, 30, 0.22, 0.52, 0.64, 1) : rect(px, ty, pk_w-1, 30, 0.2, 0.2, 0.2, 1);
        ) : ( 
            is_sel ? rect(px, ty, pk_w-1, 30, 0.46, 0.78, 0.88, 1) : rect(px, ty, pk_w-1, 30, 0.8, 0.8, 0.8, 1);
        );
        is_hover = (mx>=px && mx<px+pk_w && my>=ty && my<ty+32);
        (mb && is_hover && (p_mb == 0 || last_preview_note != i_p)) ? ( 
            mem[row_note_base+sel_r]=i_p; 
            preview_note = i_p; 
            preview_chan = mem[row_chan_base+sel_r]; 
            preview_vel = 100; 
            preview_trig = 1; 
            last_preview_note = i_p; 
        );
        i_p+=1;
    );
    mb == 0 ? last_preview_note = -1;
    ty+=38; 
    draw_text(10, ty, "DRUM:", 0.7,0.7,0.7); 
    strlen(row_name_str_base + sel_r * str_size) > 0 ? (
        strcpy(#dn_cur, row_name_str_base + sel_r * str_size);
    ) : (
        get_d_name(mem[row_name_idx+sel_r], #dn_cur); 
    );
    set_ui_color(mem[row_color_base+sel_r]); 
    gfx_x=65; 
    gfx_y=ty; 
    gfx_drawstr(#dn_cur);
    (rmb && mx>=65 && mx<160 && my>=ty && my<ty+20) ? ( 
        sel = gfx_showmenu(#name_menu); 
        sel > 0 ? ( 
            mem[row_name_idx+sel_r] = sel-1; 
            strcpy(row_name_str_base + sel_r, ""); 
        ) 
    );
    dr_p(270, ty, "NOTE:", row_note_base+sel_r, 0, 127, 85);
    dr_p(440, ty, "CHAN:", row_chan_base+sel_r, 1, 16, 75); 
    dr_p(610, ty, "LENG:", row_len_base+sel_r, 0, 127, 75); 
    dr_p(780, ty, "LEVEL:",row_level_base+sel_r, 0, 100, 85);
    dr_p(980, ty, "HUM:", row_human_base+sel_r, -1, 100, 75);
    dr_p(1180, ty, "PUSH/PULL:", row_offs_base+sel_r, -50, 60, 125); 
    
    gr_max = mem[LOCAL_GROOVE_DB + 32];
    gr_x = 1242; 
    gr_y = ty-118;
    gfx_set(0.6, 0.6, 0.6, 1);
    gfx_x = gr_x - 30; 
    gfx_y = gr_y - 4; 
    gfx_drawstr("GRV:");
    gr_max == 0 ? gfx_set(0.3, 0.3, 0.3, 1) : (gr_max > 1.0 ? gfx_set(1, 0, 0, 1) : gfx_set(0, 1, 0, 1));
    gfx_circle(gr_x, gr_y-1, 4, 1);

    ty+=12; 
    s_v=eff_sub(t_e); 
    st_v=eff_bars(t_e)*s_v;
    playing_tab = (mem[ui_locked_tab] <= 0) ? mem[ui_play_prog_tab] : mem[ui_locked_tab];
    (play_state & 1 && playing_tab == t_e) ? ( 
        vis_beat = calc_vis_beat(t_e); 
        play_step_idx = floor(vis_beat * (s_v/4)); 
    ) : play_step_idx = -1;

    btn(10, ty+8, 95, " Copy Row") ? ( 
        memcpy(copy_row_v_buf, curr_pat_v_ptr + sel_r*vel_stride_row, MAX_STEPS); 
        memcpy(copy_row_g_buf, curr_pat_g_ptr + sel_r*vel_stride_row, MAX_STEPS); 
        memcpy(copy_row_l_buf, curr_pat_l_ptr + sel_r*vel_stride_row, MAX_STEPS); 
    );
    btn(10, ty+28, 95, " Paste Row") ? ( 
        memcpy(curr_pat_v_ptr + sel_r*vel_stride_row, copy_row_v_buf, MAX_STEPS); 
        memcpy(curr_pat_g_ptr + sel_r*vel_stride_row, copy_row_g_buf, MAX_STEPS); 
        memcpy(curr_pat_l_ptr + sel_r*vel_stride_row, copy_row_l_buf, MAX_STEPS);
        scan_active_tab();
    );
    btn(115, ty+28, 35, "ALL") ? ( mem[ui_vel_edit_all] = !mem[ui_vel_edit_all]; );
    mem[ui_vel_edit_all] ? ( 
        gfx_set(1, 0.8, 0.2, 1); 
        gfx_rect(115, ty+28, 35, 18); 
        gfx_set(0,0,0,1); 
        gfx_x=120;
        gfx_y=ty+33; 
        gfx_drawstr("ALL"); 
    );
    btn(10, ty+48, 95, " Clear Row") ? ( 
        memset(curr_pat_g_ptr + sel_r*vel_stride_row, 0, MAX_STEPS); 
        memset(curr_pat_v_ptr + sel_r*vel_stride_row, 0, MAX_STEPS); 
        memset(curr_pat_l_ptr + sel_r*vel_stride_row, 0, MAX_STEPS);
        scan_active_tab();
    );

    gx_s=220; 
    sb_w = 20; 
    gx_w = gfx_w - gx_s - sb_w - 5; 
    cw_v=gx_w/st_v;
    
    def_w = 28; 
    def_x = gx_s - def_w - 4; 
    def_h = 70;
    rect(def_x, ty, def_w, def_h, 0.2, 0.2, 0.2, 1);
    gfx_set(0.08, 0.4, 0.4, 1);
    val_h = floor((slider1 / 127) * (def_h - 2));
    val_h < 2 ? val_h = 2;
    gfx_rect(def_x + 1, ty + def_h - val_h - 1, def_w - 2, val_h);
    gfx_set(1, 1, 1, 0.8);
    gfx_x = def_x + 3; 
    gfx_y = ty + 5; 
    gfx_drawstr("DEF");
    sprintf(#dv, "%d", slider1);
    gfx_x = def_x + 3; 
    gfx_y = ty + def_h - 15; 
    gfx_drawstr(#dv);
    (mb && mx >= def_x && mx < def_x + def_w && my >= ty && my < ty + def_h && capture_id == 0) ? ( capture_id = 11111; );
    (capture_id == 11111) ? (
        new_val = 127 - floor( ( (my - ty) / def_h ) * 127 );
        new_val = clamp(new_val, 1, 127);
        slider1 = new_val;
        slider_automate(slider1);
        i_rst = 0;
        loop(MAX_ROWS * MAX_STEPS,
             mem[curr_pat_g_ptr + i_rst] == 0 ? mem[curr_pat_v_ptr + i_rst] = 0;
             i_rst += 1;
        );
    );

    rect(gx_s, ty, gx_w, 70, 0.2, 0.2, 0.2, 1);
    !mb ? vel_drag_mods = 0;

    (rmb && capture_id == 88888) ? (
         abs_cell = len_drag_cell_idx;
         row_idx = floor(abs_cell / vel_stride_row);
         row_base = row_idx * vel_stride_row;
         step_idx = abs_cell % vel_stride_row; 
         head_x = gx_s + (step_idx * cw_v);
         dist_pixels = mx - head_x;
         raw_l = ceil(dist_pixels / cw_v);
         raw_l < 1 ? raw_l = 1;
         drag_mods = 0; 
         ctrl_dn ? drag_mods |= 1; 
         shift_dn ? drag_mods |= 2;
         beat_steps = s_v / 4; 
         total_bars = st_v / s_v; 
         step_in_bar = step_idx % s_v;
         step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
         bar_idx = floor(step_idx / s_v);
         drag_mods == 0 ? (
             local_max = st_v - step_idx;
             final = raw_l > local_max ? local_max : raw_l;
             mem[curr_pat_l_ptr + row_base + step_idx] = final;
         ) : (drag_mods == 1) ? ( 
             bb=0; loop(total_bars, 
                 tgt = bb*s_v + step_in_bar; 
                 tgt < st_v ? (
                    local_max = st_v - tgt;
                    final = raw_l > local_max ? local_max : raw_l;
                    mem[curr_pat_l_ptr + row_base + tgt] = final;
                    mem[curr_pat_g_ptr + row_base + tgt] = 1; 
                 );
                 bb+=1; 
             );
         ) : (drag_mods == 2) ? ( 
             bt=0; loop(4, 
                 tgt = bar_idx*s_v + bt*beat_steps + step_in_beat;
                 (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? (
                    local_max = st_v - tgt;
                    final = raw_l > local_max ? local_max : raw_l;
                    mem[curr_pat_l_ptr + row_base + tgt] = final;
                    mem[curr_pat_g_ptr + row_base + tgt] = 1;
                 );
                 bt+=1;
             );
         ) : ( 
             bb=0; loop(total_bars,
                 bt=0; loop(4,
                     tgt = bb*s_v + bt*beat_steps + step_in_beat;
                     tgt < st_v ? (
                        local_max = st_v - tgt;
                        final = raw_l > local_max ? local_max : raw_l;
                        mem[curr_pat_l_ptr + row_base + tgt] = final;
                        mem[curr_pat_g_ptr + row_base + tgt] = 1;
                     );
                     bt+=1;
                 );
                 bb+=1;
             );
         );
    );

    all_mode = mem[ui_vel_edit_all];
    all_preview_v = clamp(floor((1-(my-ty)/70)*127), 1, 127);
    skip_vel_draw = 0;
    active_note_idx = -1; 

    s_i=0; 
    loop(st_v,
        idx_v = sel_r*vel_stride_row + s_i;
        all_mode ? (
            vx_L = gx_s + s_i*cw_v;
            is_col_hover = (mx >= vx_L && mx < vx_L + cw_v);
            is_in_vel_box = (my >= ty && my < ty+70);
            v_store = mem[curr_pat_v_ptr + idx_v];
            def_v = (v_store > 0) ? v_store : slider1;
            v_disp = (mb && capture_id == 77777 && is_col_hover && is_in_vel_box) ? all_preview_v : def_v;
            bar_h = floor((v_disp/127) * 68); 
            bar_h < 2 ? bar_h = 2;
            rect(vx_L, ty+70-bar_h, cw_v-1, bar_h, 0.3, 0.3, 0.3, 1);
        ) : (
            skip_vel_draw > 0 ? ( skip_vel_draw -= 1; ) : (
                g_on = mem[curr_pat_g_ptr+idx_v];
                step_len = mem[curr_pat_l_ptr+idx_v];
                draw_w = cw_v;
                step_len > 1 ? ( draw_w = cw_v * step_len; skip_vel_draw = step_len - 1; );
                v_store = mem[curr_pat_v_ptr+idx_v];
                v_disp = (v_store > 0) ? v_store : slider1;
                bar_h = floor((v_disp/127) * 68); 
                bar_h < 2 ? bar_h = 2;
                c_idx = mem[row_color_base+sel_r]; 
                get_palette_values(c_idx);
                g_on ? (
                    min_b = (c_idx == 0) ? 0.60 : 0.50; 
                    rng_b = 1.0 - min_b;
                    v_scale = min_b + (rng_b * (v_disp / 127));
                    (play_step_idx == s_i) ? (
                        gfx_set(1, 1, 1, 0.95);
                    ) : (
                        gfx_set(cr * v_scale, cg * v_scale, cb * v_scale, 1);
                    );
                    gfx_rect(gx_s+s_i*cw_v, ty+70-bar_h, draw_w-1, bar_h);
                ) : (
                    rect(gx_s+s_i*cw_v, ty+70-bar_h, cw_v-1, bar_h, 0.3, 0.3, 0.3, 1);
                );
            );
        );
        vx_L = gx_s+s_i*cw_v; 
        vx_R = vx_L+cw_v;
        is_col_hover = (mx >= vx_L && mx < vx_R);
        is_box_hover = (is_col_hover && my >= ty && my < ty+70);
        (mb && p_mb == 0 && is_box_hover && capture_id == 0) ? ( capture_id = 77777; );
        do_update = 0;
        (capture_id == 77777 && mb && is_col_hover) ? do_update = 1; 
        (capture_id == 0 && mb && is_box_hover) ? do_update = 1;     
        do_update ? (
            p_mb == 0 ? ( 
                vel_drag_mods = 0; 
                ctrl_dn ? vel_drag_mods |= 1; 
                shift_dn ? vel_drag_mods |= 2; 
            );
            new_v = floor((1-(my-ty)/70)*127); 
            new_v < 1 ? new_v = 1 : new_v > 127 ? new_v = 127;
            beat_steps = s_v/4; 
            total_bars = st_v / s_v; 
            step_idx = s_i; 
            step_in_bar = step_idx % s_v; 
            step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
            bar_idx = floor(step_idx / s_v);
            vel_drag_mods == 0 ? ( 
                mem[ui_vel_edit_all] ? (
                    r_it = 0; 
                    loop(MAX_ROWS,
                        mem[curr_pat_v_ptr + r_it*vel_stride_row + s_i] = new_v;
                        r_it+=1;
                    );
                ) : (
                    mem[curr_pat_v_ptr + idx_v] = new_v; 
                );
            ) : (vel_drag_mods == 1) ? ( 
                bb=0; 
                loop(total_bars, 
                    tgt = bb*s_v + step_in_bar; 
                    tgt < st_v ? ( 
                        i2 = sel_r*vel_stride_row + tgt; 
                        mem[curr_pat_v_ptr + i2] = new_v; 
                    ); 
                    bb+=1; 
                ); 
            ) : (vel_drag_mods == 2) ? ( 
                bt=0; 
                loop(4, 
                    tgt = bar_idx*s_v + bt*beat_steps + step_in_beat; 
                    (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? ( 
                        ii = sel_r*vel_stride_row + tgt; 
                        mem[curr_pat_v_ptr+ii] = new_v; 
                    ); 
                    bt+=1; 
                ); 
            ) : ( 
                bb=0; 
                loop(total_bars, 
                    bt=0; 
                    loop(4, 
                        tgt = bb*s_v + bt*beat_steps + step_in_beat; 
                        tgt < st_v ? ( 
                            ii = sel_r*vel_stride_row + tgt; 
                            mem[curr_pat_v_ptr+ii] = new_v; 
                        ); 
                        bt+=1; 
                    ); 
                    bb+=1; 
                ); 
            ); 
        ); 
        s_i+=1;
    );

    ruler_h = 15; 
    gap_h = 2;
    ruler_y = ty + 72;
    grid_y = ruler_y + ruler_h + gap_h;
    row_h = grid_height;
    is_half = eff_half(t_e);
    raw_steps_per_bar = st_v / eff_bars(t_e);
    vis_steps_per_bar = is_half ? (raw_steps_per_bar / 2) : raw_steps_per_bar;
    vis_bar_w = cw_v * vis_steps_per_bar;
    bar_count = eff_bars(t_e) * (is_half ? 2 : 1);
    b_idx = 0;
    loop(bar_count,
        bx = gx_s + b_idx * vis_bar_w;
        rect(bx, ruler_y, vis_bar_w-1, ruler_h, 0.5, 0.5, 0.5, 1);
        sprintf(#bnum, "%d", b_idx + 1);
        draw_text(bx + 1, ruler_y + 2, #bnum, 1.0, 1.0, 1.0);
        (mb && p_mb == 0 && mx >= bx && mx < bx + vis_bar_w && my >= ruler_y && my < ruler_y + ruler_h) ? (
            gfx_x = mx; 
            gfx_y = my;
            sel_menu = gfx_showmenu("Copy Bar|Paste Bar|Clear Bar");
            op_len = vis_steps_per_bar;
            op_start = b_idx * op_len;
            sel_menu == 1 ? ( 
                r_it = 0; 
                loop(MAX_ROWS,
                    src_offset = r_it * vel_stride_row + op_start;
                    dst_offset = r_it * 96;
                    memcpy(bar_copy_base + dst_offset, curr_pat_v_ptr + src_offset, op_len);
                    memcpy(bar_copy_base + dst_offset + 32, curr_pat_g_ptr + src_offset, op_len);
                    memcpy(bar_copy_base + dst_offset + 64, curr_pat_l_ptr + src_offset, op_len);
                    r_it += 1;
                );
            );
            sel_menu == 2 ? ( 
                r_it = 0; 
                loop(MAX_ROWS,
                    src_offset = r_it * 96;
                    dst_offset = r_it * vel_stride_row + op_start;
                    memcpy(curr_pat_v_ptr + dst_offset, bar_copy_base + src_offset, op_len);
                    memcpy(curr_pat_g_ptr + dst_offset, bar_copy_base + src_offset + 32, op_len);
                    memcpy(curr_pat_l_ptr + dst_offset, bar_copy_base + src_offset + 64, op_len);
                    r_it += 1;
                );
            );
            sel_menu == 3 ? ( 
                r_it = 0; 
                loop(MAX_ROWS,
                    dst_offset = r_it * vel_stride_row + op_start;
                    memset(curr_pat_v_ptr + dst_offset, 0, op_len);
                    memset(curr_pat_g_ptr + dst_offset, 0, op_len);
                    memset(curr_pat_l_ptr + dst_offset, 0, op_len);
                    r_it += 1;
                );
            );
        );
        b_idx += 1;
    );

    !mb ? (
        last_drag_idx = -1;
        drag_mods = 0;
        vel_drag_mods = 0;
        drag_mode = 0;
        capture_id = 0;
        drag_lock_row = -1;
        len_drag_active = 0;
        row_drag_active = 0;
        row_drag_last_y = 0;
        row_drag_anchor = -1;
    );

    rows_that_fit = floor((gfx_h - grid_y) / row_h);
    visible_rows = min(slider7, rows_that_fit);
    visible_rows < 1 ? visible_rows = 1; 
    scroll_val = slider8; 
    max_scroll = MAX_ROWS - visible_rows; 
    max_scroll < 0 ? max_scroll = 0;
    scroll_val > max_scroll ? (scroll_val = max_scroll; slider8 = max_scroll;);
    sb_w = 20; 
    sb_x = gfx_w - sb_w - 2; 
    sb_y = grid_y; 
    sb_h = visible_rows * row_h;
    handle_h_pct = visible_rows / MAX_ROWS; 
    handle_h = sb_h * handle_h_pct; 
    handle_h < 15 ? handle_h = 15;
    available_track = sb_h - handle_h; 
    available_track < 1 ? available_track = 1; 
    scroll_pct = (max_scroll > 0) ? (scroll_val / max_scroll) : 0; 
    handle_y = sb_y + (scroll_pct * available_track);
    is_sb_hover = (mx >= sb_x && mx < sb_x + sb_w && my >= sb_y && my < sb_y + sb_h); 
    is_sb_drag = (capture_id == 9999);
    (mb && p_mb == 0 && is_sb_hover) ? ( 
        capture_id = 9999; 
        scrollbar_drag_y_offset = my - handle_y; 
    );
    (mb && capture_id == 9999) ? ( 
        target_y = my - scrollbar_drag_y_offset; 
        rel_y = target_y - sb_y; 
        new_pct = rel_y / available_track; 
        new_val = floor(new_pct * max_scroll + 0.5); 
        new_val = clamp(new_val, 0, max_scroll); 
        slider8 = new_val; 
    );
    scroll_offset = slider8;
    row_drag_active = row_drag_active; 
    row_drag_last_y = row_drag_last_y; 
    row_drag_anchor = row_drag_anchor;
    row_drag_x0 = 60; 
    row_drag_x1 = gx_s - 5;      

    gfx_set(0,0,0,1); 
    gfx_rect(0, grid_y, gfx_w, gfx_h - grid_y);
    r_v = 0; 
    loop(visible_rows,
        r_g = r_v + scroll_offset; 
        ry = grid_y + r_v*row_h;
        r_g==sel_r ? 
            rect(10, ry, gx_w+gx_s-10, row_h-1, 0.12, 0.12, 0.12, 1) : 
            rect(10, ry, gx_w+gx_s-10, row_h-1, 0, 0, 0, 1);
        mem[row_mute_base+r_g]?
            draw_text(15,ry+3,"M",1,0,0):
            draw_text(15,ry+3,"M",0.4,0.4,0.4);
        mem[row_solo_base+r_g]?
            draw_text(32,ry+3,"S",0,1,1):
            draw_text(32,ry+3,"S",0.4,0.4,0.4);
        STRING_SLOT_ID = row_name_str_base + r_g; 
        strlen(STRING_SLOT_ID) > 0 ? ( strcpy(#gn_row, STRING_SLOT_ID); ) : ( get_d_name(mem[row_name_idx+r_g], #gn_row); );
        set_ui_color(mem[row_color_base+r_g]); 
        gfx_x=53; 
        gfx_y=ry+6; 
        gfx_circle(gfx_x, gfx_y, 4, 1); 
        gfx_x=65; 
        gfx_y=ry+3; 
        gfx_drawstr(#gn_row);
        (mb && p_mb==0 && mx>=65 && mx<165 && my>=ry+3 && my<ry+18) ? ( 
            preview_note = mem[row_note_base+r_g]; 
            preview_chan = mem[row_chan_base+r_g]; 
            preview_vel = 100; 
            preview_trig = 1; 
            mem[ui_selected_row] = r_g; 
            mem[ui_vel_edit_all] = 0; 
        ); 
        (mb && p_mb==0 && mx>=48 && mx<58 && my>=ry+1 && my<ry+11) ? ( 
            color_popup_active = 1; 
            color_popup_x = mx; 
            color_popup_y = my; 
            color_popup_row = r_g; 
        );
        (rmb && mx>=60 && mx<gx_s && my>=ry && my<ry+row_h) ? ( 
            c_sel = gfx_showmenu(#name_menu); 
            c_sel > 0 ? ( 
                mem[row_name_idx+r_g] = c_sel-1; 
                strcpy(STRING_SLOT_ID, ""); 
            ); 
        );
        (mb && p_mb == 0 && capture_id == 0 && !color_popup_active && mx<gx_s && my>=ry && my<ry+row_h && !rmb && !(mx>=48 && mx<58) && !(mx>=65 && mx<165)) ? ( 
            mx<28 ? mem[row_mute_base+r_g] = !mem[row_mute_base+r_g] : 
            mx<45 ? mem[row_solo_base+r_g] = !mem[row_solo_base+r_g] : 
            ( 
                mem[ui_selected_row] = r_g; 
                mem[ui_vel_edit_all] = 0;
            ); 
        );
        (mb && p_mb==0 && !ui_lock && mx>=row_drag_x0 && mx<row_drag_x1 && my>=ry && my<ry+row_h && !rmb && (mouse_cap & 16)) ? ( 
            row_drag_active = 1; 
            row_drag_last_y = my; 
            row_drag_anchor = r_g; 
            capture_id = 42424; 
        );
        (mb && capture_id == 42424 && row_drag_active) ? ( 
            dy = my - row_drag_last_y; 
            abs(dy) >= (row_h*0.5) ? ( 
                dir = dy > 0 ? 1 : -1; 
                tgt = row_drag_anchor + dir; 
                (tgt >= 0 && tgt < MAX_ROWS) ? ( 
                    swap_rows(row_drag_anchor, tgt); 
                    row_drag_anchor = tgt; 
                    row_drag_last_y = my; 
                ) : ( 
                    row_drag_last_y = my; 
                ); 
            ); 
        );
        get_palette_values(mem[row_color_base+r_g]); 
        memset(ownership_map, -1, MAX_STEPS); 
        s_i = 0; 
        loop(st_v, 
            idx_v = r_g*vel_stride_row + s_i; 
            mem[curr_pat_g_ptr+idx_v] ? ( 
                l = mem[curr_pat_l_ptr+idx_v]; 
                l < 1 ? l = 1; 
                k = 0; 
                loop(l, 
                    (s_i + k < st_v) ? ( mem[ownership_map + s_i + k] = idx_v; ); 
                    k+=1; 
                ); 
            ); 
            s_i+=1; 
        );
        s_i=0; 
        loop(st_v,
            idx_v = r_g*vel_stride_row + s_i; 
            cx_g = gx_s + s_i*cw_v; 
            owner_idx = mem[ownership_map + s_i];
            is_head = (owner_idx == idx_v); 
            is_tail = (owner_idx != -1 && owner_idx != idx_v); 
            is_empty = (owner_idx == -1); 
            is_head ? (
                step_len = mem[curr_pat_l_ptr+idx_v]; 
                draw_w = cw_v;
                step_len > 1 ? ( draw_w = cw_v * step_len; );
                v_store = mem[curr_pat_v_ptr+idx_v]; 
                v_disp = (v_store>0?v_store:slider1);
                c_idx = mem[row_color_base+r_g];
                get_palette_values(c_idx); 
                min_b = (c_idx == 0) ? 0.60 : 0.50;
                rng_b = 1.0 - min_b;
                v_scale = min_b + (rng_b * (v_disp / 127)); 
                (play_step_idx == s_i) ? (
                    gfx_set(1, 1, 1, 0.95); 
                ) : (
                    gfx_set(cr*v_scale, cg*v_scale, cb*v_scale, 1); 
                );
                gfx_rect(cx_g, ry+1, draw_w-1, row_h-3);
            ) : is_empty ? (
                q_div = s_v/4; 
                e_div = s_v/8;
                one_brite = .5;
                (s_i % s_v == 0) ? rect(cx_g, ry+1, cw_v-1, row_h-3, 0.20*one_brite, 1*one_brite, 1*one_brite, .8)
                : (s_i % q_div == 0) ? rect(cx_g, ry+1, cw_v-1, row_h-3, 0.30, 0.30, 0.30, 1) 
                : (s_v == 32 && (s_i % e_div == 0)) ? rect(cx_g, ry+1, cw_v-1, row_h-3, .08, .08, .08, 1) 
                : rect(cx_g, ry+1, cw_v-1, row_h-3, 0.15, 0.15, 0.15, 1);
            );
            (mb && mx>=cx_g && mx<cx_g+cw_v && my>=ry && my<ry+row_h && capture_id == 0) ? (
                drag_lock_row == -1 ? drag_lock_row = r_g;
                (r_g == drag_lock_row && !is_tail) ? (
                    cell_id = r_g*1000 + s_i;
                    p_mb == 0 ? ( 
                        drag_mode = mem[curr_pat_g_ptr+idx_v] ? 2 : 1; 
                        drag_mods = 0; 
                        ctrl_dn ? drag_mods |= 1; 
                        shift_dn ? drag_mods |= 2; 
                    );
                    (cell_id != last_drag_idx) ? (
                        beat_steps = s_v/4; 
                        total_bars = st_v / s_v; 
                        step_idx = s_i; 
                        step_in_bar = step_idx % s_v; 
                        step_in_beat = (beat_steps > 0) ? (step_idx % beat_steps) : 0; 
                        bar_idx = floor(step_idx / s_v);
                        drag_mods == 0 ? ( 
                            drag_mode == 1 ? ( 
                                mem[curr_pat_g_ptr+idx_v] = 1; 
                                mem[curr_pat_l_ptr+idx_v] = 0;
                                mem[curr_pat_v_ptr+idx_v] <= 0 ? mem[curr_pat_v_ptr+idx_v] = slider1; 
                            ) : ( 
                                mem[curr_pat_g_ptr+idx_v] = 0; 
                                mem[curr_pat_v_ptr+idx_v] = 0; 
                                mem[curr_pat_l_ptr+idx_v] = 0; 
                            ); 
                        ) : (drag_mods == 1) ? ( 
                            bb=0; 
                            loop(total_bars, 
                                tgt = bb*s_v + step_in_bar; 
                                tgt < st_v ? ( 
                                    ii = r_g*vel_stride_row + tgt; 
                                    drag_mode == 1 ? ( 
                                        mem[curr_pat_g_ptr+ii] = 1; 
                                        mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; 
                                    ) : ( 
                                        mem[curr_pat_g_ptr+ii] = 0; 
                                        mem[curr_pat_v_ptr+ii] = 0; 
                                        mem[curr_pat_l_ptr+ii] = 0; 
                                    ); 
                                ); 
                                bb+=1; 
                            ); 
                        ) : (drag_mods == 2) ? ( 
                            bt=0; 
                            loop(4, 
                                tgt = bar_idx*s_v + bt*beat_steps + step_in_beat; 
                                (tgt >= bar_idx*s_v && tgt < (bar_idx+1)*s_v && tgt < st_v) ? ( 
                                    ii = r_g*vel_stride_row + tgt; 
                                    drag_mode == 1 ? ( 
                                        mem[curr_pat_g_ptr+ii] = 1; 
                                        mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; 
                                    ) : ( 
                                        mem[curr_pat_g_ptr+ii] = 0; 
                                        mem[curr_pat_v_ptr+ii] = 0; 
                                        mem[curr_pat_l_ptr+ii] = 0; 
                                    ); 
                                ); 
                                bt+=1; 
                            ); 
                        ) : ( 
                            bb=0; 
                            loop(total_bars, 
                                bt=0; 
                                loop(4, 
                                    tgt = bb*s_v + bt*beat_steps + step_in_beat; 
                                    tgt < st_v ? ( 
                                        ii = r_g*vel_stride_row + tgt; 
                                        drag_mode == 1 ? ( 
                                            mem[curr_pat_g_ptr+ii] = 1; 
                                            mem[curr_pat_v_ptr+ii] <= 0 ? mem[curr_pat_v_ptr+ii] = slider1; 
                                        ) : ( 
                                            mem[curr_pat_g_ptr+ii] = 0; 
                                            mem[curr_pat_v_ptr+ii] = 0; 
                                            mem[curr_pat_l_ptr+ii] = 0; 
                                        ); 
                                    ); 
                                    bt+=1; 
                                ); 
                                bb+=1; 
                            ); 
                        );
                        mem[ui_selected_row] = r_g; 
                        last_drag_idx = cell_id;
                    );
                );
            );
            (rmb && mx>=cx_g && mx<cx_g+cw_v && my>=ry && my<ry+row_h && capture_id == 0) ? (
                target_head = -1; 
                owner_idx != -1 ? ( 
                    target_head = owner_idx; 
                    is_clicked_head = (mem[curr_pat_g_ptr + idx_v] != 0); 
                    is_clicked_head && !ctrl_dn ? ( 
                        under = find_covering_head(r_g, s_i, st_v); 
                        under != -1 ? target_head = under; 
                    ); 
                ) : ( 
                    target_head = idx_v; 
                    mem[curr_pat_g_ptr + target_head] = 1; 
                    mem[curr_pat_v_ptr + target_head] <= 0 ? mem[curr_pat_v_ptr + target_head] = slider1; 
                    mem[curr_pat_l_ptr + target_head] = 1; 
                );
                capture_id = 88888; 
                len_drag_active = 1; 
                len_drag_cell_idx = target_head; 
                head_pos = target_head % st_v; 
                len_drag_max = st_v - head_pos;
            );
            s_i+=1;
        );
        r_v+=1;
    );
    
    gfx_set(0.15, 0.15, 0.15, 1);
    gfx_rect(sb_x, sb_y, sb_w, sb_h);
    is_sb_drag || is_sb_hover ? gfx_set(0.6, 0.6, 0.6, 1) : gfx_set(0.35, 0.35, 0.35, 1);
    draw_h = handle_h; 
    draw_y = handle_y;
    draw_y < sb_y ? draw_y = sb_y; 
    draw_y + draw_h > sb_y + sb_h ? draw_y = sb_y + sb_h - draw_h;
    gfx_rect(sb_x + 2, draw_y, sb_w - 4, draw_h);
    
    playing ? (
        t_n = mem[ui_locked_tab] == 0 ? mem[ui_play_prog_tab] : (mem[ui_locked_tab] > 0 ? mem[ui_locked_tab] : mem[ui_play_prog_tab]);
        t_n == t_e ? (
            vis_beat = calc_vis_beat(t_n);
            p_l = eff_bars(t_n) * 4;
            phx = gx_s + (vis_beat/p_l)*gx_w;
            rect(phx-1, grid_y, 3, slider7*row_h, 0, 1, 0, 0.4);
        );
    );

    color_popup_active && color_popup_row >= 0 ? draw_color_popup(color_popup_x, color_popup_y);
    is_over_grid = (my > grid_y);
    mouse_wheel != 0 && is_over_grid && !shift_dn && !ctrl_dn && !alt_dn && capture_id != 88888 ? (
        scroll_amt = (mouse_wheel > 0) ? -1 : 1;
        new_scroll = slider8 + scroll_amt;
        max_scroll = MAX_ROWS - slider7; 
        max_scroll < 0 ? max_scroll = 0;
        new_scroll = clamp(new_scroll, 0, max_scroll);
        slider8 = new_scroll;
        mouse_wheel = 0;
    );
); 

help_active ? (
    gfx_set(0,0,0,0.85); gfx_rect(0,0,gfx_w,gfx_h);
    hw = 550; hh = 570; hx = (gfx_w-hw)/2; hy = (gfx_h-hh)/2;
    rect(hx, hy, hw, hh, 0.2, 0.2, 0.2, 1);
    gfx_set(1,1,1,1);
    gfx_x = hx+20; gfx_y = hy+20; gfx_drawstr("SCOPE OF SETTINGS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - GLOBAL SETTINGS: Affect all Patterns (Tabs)");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - PATTERN SETTINGS: Affect only the viewed Pattern");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - ROW SETTINGS: Affect only the selected Row");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("TAB & VIEW FUNCTIONS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - Select Tab: Views the Tab's Pattern");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Tab's Lock Box: Green - Playback is locked to the Tab");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Tab's Lock Box: Black - Playback is not locked to the Tab");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Double-Click Tab: View Pattern AND Lock tab to playback");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Follow [x]: View and playback follow incoming MIDI commands");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("GRID EDITING:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - Click+Drag: Paint steps and velocity bars");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - CTRL+Drag: Edit all pattern Bars simultaneously");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - SHIFT+Drag: Edit all pattern Beats simultaneously");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Right-Click Drag: Set Note Durations (create long notes)");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("ROW OPERATIONS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - ALT+Drag Name: Move/Swap Rows");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - Click Color Dot: Change Row Color");
    gfx_y += 25; 
    gfx_x = hx+20;
    gfx_drawstr("SETTINGS:");
    gfx_x = hx+20; 
    gfx_y += 20;
    gfx_drawstr(" - HUM: -1 follows Global Slider");
    gfx_x = hx+20; 
    gfx_y += 16;
    gfx_drawstr(" - Swing P: Uses Project Swing (Numbers2Notes)");
    gfx_x = hx+20; 
    gfx_y += 16;
    gfx_drawstr(" - [1x | 1/2]: Playback speed for 24/32 SubDivs");
    gfx_x = hx+20; 
    gfx_y += 16;
    gfx_drawstr(" - PUSH/PULL: Adjust timing per row (+ = Lag, - = Push)");
    gfx_y += 25; gfx_x = hx+20; gfx_drawstr("FILE OPERATIONS:");
    gfx_x = hx+20; gfx_y += 20; gfx_drawstr(" - <- : Import Single Pattern (.n2drumpat) to current Tab");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - <= : Import Pattern Bank (.n2drumpats)");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - -> : Export Single Pattern (.n2drumpat)");
    gfx_x = hx+20; gfx_y += 16; gfx_drawstr(" - => : Export Pattern Bank (.n2drumpats)");
    ok_w = 60; ok_h = 25; ok_x = hx + hw - ok_w - 20; ok_y = hy + hh - ok_h - 20;
    rect(ok_x, ok_y, ok_w, ok_h, 0.4, 0.4, 0.4, 1);
    gfx_set(1,1,1,1); gfx_x = ok_x + 18; gfx_y = ok_y + 5; gfx_drawstr("OK");
    mb ? (
        (mx>=ok_x && mx<ok_x+ok_w && my>=ok_y && my<ok_y+ok_h) ? (
            help_active = 0;
            capture_id = 90000; 
        ) : (
            capture_id = 90000; 
        );
    );
);
